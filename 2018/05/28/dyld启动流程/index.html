<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="0x01 launchd&amp;emsp;&amp;emsp;  launchd是第一个被内核启动的用户态进程，负责直接或间接的启动系统中的其他进程。它是用户模式里所有进程的父进程，同时也将负责两种后台作业：守护程序和代理程序。  守护程序：后台服务，通常和用户没有交互。比如push通知、外接设备插入的处理和XPC等。 代理程序：可以和用户交互，比如Mac的Finder或iOS的SpringBoard就是其中之">
<meta property="og:type" content="article">
<meta property="og:title" content="dyld启动流程">
<meta property="og:url" content="https://leylfl.github.io/2018/05/28/dyld启动流程/index.html">
<meta property="og:site_name" content="朝暮的闲暇时刻">
<meta property="og:description" content="0x01 launchd&amp;emsp;&amp;emsp;  launchd是第一个被内核启动的用户态进程，负责直接或间接的启动系统中的其他进程。它是用户模式里所有进程的父进程，同时也将负责两种后台作业：守护程序和代理程序。  守护程序：后台服务，通常和用户没有交互。比如push通知、外接设备插入的处理和XPC等。 代理程序：可以和用户交互，比如Mac的Finder或iOS的SpringBoard就是其中之">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://leylfl.github.io/2018/05/28/dyld启动流程/xnu_start.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/28/dyld启动流程/MachO_Format.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/28/dyld启动流程/load_commands.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/28/dyld启动流程/MachO_Stub.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/28/dyld启动流程/stub_lazy.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/28/dyld启动流程/stub_binder.png">
<meta property="og:updated_time" content="2018-07-22T00:23:38.031Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dyld启动流程">
<meta name="twitter:description" content="0x01 launchd&amp;emsp;&amp;emsp;  launchd是第一个被内核启动的用户态进程，负责直接或间接的启动系统中的其他进程。它是用户模式里所有进程的父进程，同时也将负责两种后台作业：守护程序和代理程序。  守护程序：后台服务，通常和用户没有交互。比如push通知、外接设备插入的处理和XPC等。 代理程序：可以和用户交互，比如Mac的Finder或iOS的SpringBoard就是其中之">
<meta name="twitter:image" content="https://leylfl.github.io/2018/05/28/dyld启动流程/xnu_start.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://leylfl.github.io/2018/05/28/dyld启动流程/"/>





  <title>dyld启动流程 | 朝暮的闲暇时刻</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">朝暮的闲暇时刻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/28/dyld启动流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">dyld启动流程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T17:00:34+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="0x01-launchd"><a href="#0x01-launchd" class="headerlink" title="0x01 launchd"></a>0x01 launchd</h1><p>&emsp;&emsp;  launchd是第一个被内核启动的用户态进程，负责直接或间接的启动系统中的其他进程。它是用户模式里所有进程的父进程，同时也将负责两种后台作业：守护程序和代理程序。</p>
<blockquote>
<p>守护程序：后台服务，通常和用户没有交互。比如push通知、外接设备插入的处理和XPC等。</p>
<p>代理程序：可以和用户交互，比如Mac的Finder或iOS的SpringBoard就是其中之一，即广义上我们理解的桌面。</p>
</blockquote>
<p>&emsp;&emsp;  launchd是如何被创建的，得先看下下面这张XNU启动流程图</p>
<p><img src="xnu_start.png" alt="xnu启动示意图"> </p>
<ul>
<li><p>start(iOS)：初始化MSR、物理页映射、安装中断处理函数</p>
</li>
<li><p>arm_init(iOS)：初始化平台，为启动内核做准备</p>
</li>
<li><p>machine_startup：解析命令行参数和调试参数</p>
</li>
<li><p>kernel_bootstrap：安装和初始化mach内核的子系统，包括：进程间通信、时钟、访问策略、进程和线程调度。</p>
</li>
<li><p>kernel_bootstrap_thread：创建idle线程，初始化iokit设备驱动框架，初始化应用程序和dyld运行所需的共享模块。如果内核开启了mac(强制访问控制)策略，则会进行mac的初始化，以确保系统的安全。</p>
</li>
<li><p>bsd_init：内核部分剩余的事情都由其来做，初始化各个子系统。网络、文件系统、管道、内存cache、线程、进程、同步对象、权限策略等等。  一切完成后，会执行/sbin/launchd来创建一个launchd。</p>
</li>
</ul>
<p>  我们看下源码的初始化过程，launchd是怎么被启动起来的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsd_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    bsd_utaskbootstrap();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsd_utaskbootstrap</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">thread_t</span> thread;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">ut</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从内核进程克隆引导进程，但不从内核继承任何任务特性或内存</span></span><br><span class="line">	thread = cloneproc(TASK_NULL, COALITION_NULL, kernproc, FALSE, TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hold the reference as it will be dropped during shutdown */</span></span><br><span class="line">	initproc = proc_find(<span class="number">1</span>);				</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since we aren't going back out the normal way to our parent,</span></span><br><span class="line"><span class="comment">	 * we have to drop the transition locks explicitly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	proc_signalend(initproc, <span class="number">0</span>);</span><br><span class="line">	proc_transend(initproc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ut = (struct uthread *)get_bsdthread_info(thread);</span><br><span class="line">	ut-&gt;uu_sigmask = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为了真正地创建出任务，对创建出的线程调用这个函数</span></span><br><span class="line">    <span class="comment">// 执行后产生一个异步系统陷阱(AST)，Mach的AST异步处理程序会特别处理这个情况，即调用bsd_ast()</span></span><br><span class="line">	act_set_astbsd(thread);</span><br><span class="line">	task_clear_return_wait(get_threadtask(thread));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsd_ast</span><span class="params">(<span class="keyword">thread_t</span> thread)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">if</span> (!bsd_init_done) &#123;</span><br><span class="line">		bsd_init_done = <span class="number">1</span>;</span><br><span class="line">		bsdinit_task();</span><br><span class="line">	&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsdinit_task</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">proc_t</span> p = current_proc();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">ut</span>;</span></span><br><span class="line">	<span class="keyword">thread_t</span> thread;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将这个从内核态克隆到用户态的第一个线程的名字设置为init</span></span><br><span class="line">	process_name(<span class="string">"init"</span>, p);</span><br><span class="line">	<span class="comment">// 内部创建了一个Mach内核线程处理ux_handler，而ux_handler设置了一个消息循环用于监听异常，如果接收到异常，将异常转换为UNIX信号，并投递到出错线程。</span></span><br><span class="line">	ux_handler_init();</span><br><span class="line"></span><br><span class="line">	thread = current_thread();</span><br><span class="line">    <span class="comment">// ux_handler_init()返回时，ux_handler已经在另一个线程中执行了，并注册好了ux_exception_port。</span></span><br><span class="line">    <span class="comment">// 这个函数将所有的Mach异常消息都重定向到ux_exception_port</span></span><br><span class="line">    <span class="comment">// 由于所有程序都是launchld后代，所以都会继承这个异常端口</span></span><br><span class="line">	(<span class="keyword">void</span>) host_set_exception_ports(host_priv_self(),</span><br><span class="line">					EXC_MASK_ALL &amp; ~(EXC_MASK_RPC_ALERT),<span class="comment">//pilotfish (shark) needs this port</span></span><br><span class="line">					(<span class="keyword">mach_port_t</span>) ux_exception_port,</span><br><span class="line">					EXCEPTION_DEFAULT| MACH_EXCEPTION_CODES,</span><br><span class="line">					<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ut = (<span class="keyword">uthread_t</span>)get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">    vm_init_before_launchd();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	bsd_init_kprintf(<span class="string">"bsd_do_post - done"</span>);</span><br><span class="line">	<span class="comment">// 加载launchd</span></span><br><span class="line">	load_init_program(p);</span><br><span class="line">	lock_trace = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_init_program</span><span class="params">(<span class="keyword">proc_t</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">vm_map_t</span> <span class="built_in">map</span> = current_map();</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span> scratch_addr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span> map_page_size = vm_map_page_size(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">	(<span class="keyword">void</span>) mach_vm_allocate_kernel(<span class="built_in">map</span>, &amp;scratch_addr, map_page_size, VM_FLAGS_ANYWHERE, VM_KERN_MEMORY_NONE);</span><br><span class="line">    </span><br><span class="line">    error = ENOENT;</span><br><span class="line">    <span class="comment">// 加载“init”程序，这里指的是launchd</span></span><br><span class="line">    <span class="comment">// init_programs保存着要运行程序的路径</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(init_programs)/<span class="keyword">sizeof</span>(init_programs[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"load_init_program: attempting to load %s\n"</span>, init_programs[i]);</span><br><span class="line">        <span class="comment">// 使用从系统克隆出的那个第一个线程加载这个"init"程序，即加载launchd</span></span><br><span class="line">		error = load_init_program_at_path(p, (<span class="keyword">user_addr_t</span>)scratch_addr, init_programs[i]);</span><br><span class="line">		<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"load_init_program: failed loading %s: errno %d\n"</span>, init_programs[i], error);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">"Process 1 exec of %s failed, errno %d"</span>, ((i == <span class="number">0</span>) ? <span class="string">"&lt;null&gt;"</span> : init_programs[i<span class="number">-1</span>]), error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_init_program_at_path</span><span class="params">(<span class="keyword">proc_t</span> p, <span class="keyword">user_addr_t</span> scratch_addr, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execve(p, &amp;init_exec_args, retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;  init_programs装的就是launchd程序的路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * init_programs[] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG</span><br><span class="line">	<span class="string">"/usr/local/sbin/launchd.debug"</span>,</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> DEVELOPMENT || DEBUG</span><br><span class="line">	<span class="string">"/usr/local/sbin/launchd.development"</span>,</span><br><span class="line">#endif</span><br><span class="line">	<span class="string">"/sbin/launchd"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp; &emsp; 我们知道iOS和Mac执行的都是Mach-O格式的文件，即使是launchd也是一样，所以接下来的步骤，同样适用于其他进程加载app程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">proc_t</span> p, struct execve_args *uap, <span class="keyword">int32_t</span> *retval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">mac_execve_args</span> <span class="title">muap</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	memoryshot(VM_EXECVE, DBG_FUNC_NONE);</span><br><span class="line"></span><br><span class="line">	muap.fname = uap-&gt;fname;</span><br><span class="line">	muap.argp = uap-&gt;argp;</span><br><span class="line">	muap.envp = uap-&gt;envp;</span><br><span class="line">	muap.mac_p = USER_ADDR_NULL;</span><br><span class="line">	err = __mac_execve(p, &amp;muap, retval);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-MACH-O格式"><a href="#0x02-MACH-O格式" class="headerlink" title="0x02 MACH-O格式"></a>0x02 MACH-O格式</h1><p>&emsp;&emsp;Mach-O是OS X和iOS的可执行文件，类似于安卓的elf和微软的PE，但又不仅限于可执行文件，比如iOS的动态库其实也可以Mach-O格式。其格式如下图：</p>
<p><img src="MachO_Format.png" alt="Mach-O格式示意图"> </p>
<p>&emsp;&emsp;Mach-O在加载过程中，在内核态的处理主要是对进程的一些基本设置，比如分配虚拟内存、创建主线程以及代码签名、加密等任务。而在转由去用户态的时候调用动态加载器dyld会继续对Mach-O做处理，比如库加载和符号解析等。</p>
<h3 id="1-header"><a href="#1-header" class="headerlink" title="1. header"></a>1. header</h3><p>&emsp;&emsp;头信息的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* 0xfeedfacf表示64位，而0xfeedface表示32位 */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* CPU平台:arm还是i386 */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* armv7、armv8等等 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* 文件类型，比如是可执行程序还是动态库等 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* load commands的数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* load commands的大小 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* 标签参数 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved，保留字段，暂时没用 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-filetype"><a href="#1-1-filetype" class="headerlink" title="1.1 filetype"></a>1.1 filetype</h4><p>&emsp;&emsp;常见的Mach-O文件类型有以下几种：</p>
<ul>
<li><p>MH_OBJECT </p>
<blockquote>
<p>目标文件，比如编译后得到的.o文件</p>
<p>静态库文件，比如.a文件</p>
</blockquote>
</li>
<li><p>MH_EXECUTE </p>
<blockquote>
<p>可执行文件，广义上我们口中常说的app文件，即ipa拆包后得到的文件</p>
</blockquote>
</li>
<li><p>MH_DYLIB </p>
<blockquote>
<p>动态库文件，比如.dylib或.framework</p>
</blockquote>
</li>
<li><p>MH_DYLINKER </p>
<blockquote>
<p>动态链接器，启动dyld</p>
</blockquote>
</li>
<li><p>MH_DSYM </p>
<blockquote>
<p>存储着二进制文件符号信息的文件，常用于分析闪退信息等</p>
</blockquote>
</li>
</ul>
<h4 id="1-2-flags"><a href="#1-2-flags" class="headerlink" title="1.2 flags"></a>1.2 flags</h4><p>&emsp;&emsp;常见的标签参数有以下几种</p>
<ul>
<li><p>MH_DYLDLINK</p>
<blockquote>
<p>作为动态链接器的输入文件，不能再次被静态链接编辑</p>
</blockquote>
</li>
<li><p>MH_PIE</p>
<blockquote>
<p>加载主程序在一个随机地址。仅文件类型是MH_EXECUTE的才有效</p>
</blockquote>
</li>
</ul>
<h3 id="2-Load-Commands"><a href="#2-Load-Commands" class="headerlink" title="2. Load Commands"></a>2. Load Commands</h3><p>&emsp;&emsp;这个主要描述的是文件在虚拟内存中的逻辑结构和布局，可以在被调用的时候清晰地知道如何设置并加载二进制数据。其结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* load command类型 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* 大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Load Commands紧跟着mach_header，其总的大小保存在mach_header里的sizeofcmds里。所有的load commands都必须有自己的两个成员cmd和cmdsize，其中cmdsize在64架构中必须是8的倍数。而cmd表示的是类型，常见的类型如下</p>
<ul>
<li><p>LC_SEGMENT(LC_SEGMENT_64)</p>
<blockquote>
<p>将文件中(32位或64位)的段映射到进程地址空间。包括__text代码区、常量区和OC类信息等。</p>
</blockquote>
</li>
<li><p>LC_LOAD_DYLINKER</p>
<blockquote>
<p>启动动态链接器，dyld</p>
</blockquote>
</li>
<li><p>LC_UUID</p>
<p>这个id是匹配一个二进制文件及其对应的符号，是个唯一值</p>
</li>
<li><p>LC_THREAD</p>
<blockquote>
<p>开启一个Mach线程，不分配栈</p>
</blockquote>
</li>
<li><p>LC_UNIXTHREAD</p>
<blockquote>
<p>开启一个Unix线程，现被LC_MAIN替代</p>
</blockquote>
</li>
<li><p>LC_CORE_SIGNATURE</p>
<blockquote>
<p>代码签名，如果签名与代码本身不匹配，进程会被杀掉</p>
</blockquote>
</li>
<li><p>LC_ENCRYPTION_INFO</p>
<blockquote>
<p>加密信息</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;load_commands在Mach-O中的实例结构如下：</p>
<p><img src="load_commands.png" alt="load_commands示意图"> </p>
<h3 id="3-通用-Mach-O"><a href="#3-通用-Mach-O" class="headerlink" title="3. 通用 Mach-O"></a>3. 通用 Mach-O</h3><p>&emsp;&emsp;根据编译配置，我们可以生成只包含一种架构的Mach-O文件，比如armv7。当然也可以编译生成多架构的的Mach-O文件，这种包含多种架构的我们称之为通用Mach-O，也可以称为Fat Mach-O。运行通用Mach-O的时候，加载器会选择合适的架构的代码去执行。</p>
<h1 id="0x03-地址空间随机布局-ASLR"><a href="#0x03-地址空间随机布局-ASLR" class="headerlink" title="0x03 地址空间随机布局(ASLR)"></a>0x03 地址空间随机布局(ASLR)</h1><p>&emsp;&emsp;如果应用启动的时候都是进程空间某个固定地址开始，这也就意味着内存中的地址分布具有非常强的可预测性，这就给黑客很大的利用机会。所以现在大部分操作系统都会采用ASLR这样的技术，这将有效防止被攻击。</p>
<p>&emsp;&emsp;进程每一次启动时，地址空间都将被随机化，即偏移。实现方法是通过内核将Mach-O的Segment平移某个随机系数。后面的代码阅读中，我们将会遇到这个技术。</p>
<h1 id="0x04-dyld被加载流程"><a href="#0x04-dyld被加载流程" class="headerlink" title="0x04 dyld被加载流程"></a>0x04 dyld被加载流程</h1><p>&emsp;&emsp;在UNIX中，进程不能被创建出来，只能通过fork( ) 系统调用复制出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __mac_execve(<span class="keyword">proc_t</span> p, struct __mac_execve_args *uap, <span class="keyword">int32_t</span> *retval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *bufp = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">image_params</span> *<span class="title">imgp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vnode_attr</span> *<span class="title">vap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vnode_attr</span> *<span class="title">origvap</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> is_64 = IS_64BIT_PROCESS(p);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfs_context</span> <span class="title">context</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span>	*<span class="title">uthread</span>;</span></span><br><span class="line">	<span class="keyword">task_t</span> new_task = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">boolean_t</span> should_release_proc_ref = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span> exec_done = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span> in_vfexec = FALSE;</span><br><span class="line">	<span class="keyword">void</span> *inherit = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    context.vc_thread = current_thread();</span><br><span class="line">	context.vc_ucred = kauth_cred_proc_ref(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配一大块内存</span></span><br><span class="line">    MALLOC(bufp, <span class="keyword">char</span> *, (<span class="keyword">sizeof</span>(*imgp) + <span class="keyword">sizeof</span>(*vap) + <span class="keyword">sizeof</span>(*origvap)), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">	imgp = (struct image_params *) bufp;</span><br><span class="line">	<span class="keyword">if</span> (bufp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error = ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> exit_with_error;</span><br><span class="line">	&#125;</span><br><span class="line">	vap = (struct vnode_attr *) (bufp + <span class="keyword">sizeof</span>(*imgp));</span><br><span class="line">	origvap = (struct vnode_attr *) (bufp + <span class="keyword">sizeof</span>(*imgp) + <span class="keyword">sizeof</span>(*vap));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    imgp-&gt;ip_user_fname = uap-&gt;fname;</span><br><span class="line">	imgp-&gt;ip_user_argv = uap-&gt;argp;</span><br><span class="line">	imgp-&gt;ip_user_envv = uap-&gt;envp;</span><br><span class="line">	imgp-&gt;ip_vattr = vap;</span><br><span class="line">	imgp-&gt;ip_origvattr = origvap;</span><br><span class="line">	imgp-&gt;ip_vfs_context = &amp;context;</span><br><span class="line">	imgp-&gt;ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE) | ((p-&gt;p_flag &amp; P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE);</span><br><span class="line">	imgp-&gt;ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);</span><br><span class="line">	imgp-&gt;ip_mac_return = <span class="number">0</span>;</span><br><span class="line">	imgp-&gt;ip_cs_error = OS_REASON_NULL;</span><br><span class="line">    </span><br><span class="line">    uthread = get_bsdthread_info(current_thread());</span><br><span class="line">	<span class="keyword">if</span> (uthread-&gt;uu_flag &amp; UT_VFORK) &#123;</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_VFORK_EXEC;</span><br><span class="line">		in_vfexec = TRUE;</span><br><span class="line">    <span class="comment">// 程序启动需要fork一条新的进程，会走这个else分支</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_EXEC;</span><br><span class="line">        <span class="comment">// fork进程</span></span><br><span class="line">        imgp-&gt;ip_new_thread = fork_create_child(current_task(),</span><br><span class="line">					<span class="literal">NULL</span>, p, FALSE, p-&gt;p_flag &amp; P_LP64, TRUE);</span><br><span class="line">		<span class="comment">/* task and thread ref returned by fork_create_child */</span></span><br><span class="line">		<span class="keyword">if</span> (imgp-&gt;ip_new_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			error = ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> exit_with_error;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		new_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">		context.vc_thread = imgp-&gt;ip_new_thread;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析程序</span></span><br><span class="line">    error = exec_activate_image(imgp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (imgp-&gt;ip_new_thread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        new_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!error &amp;&amp; !in_vfexec) &#123;</span><br><span class="line">		p = proc_exec_switch_task(p, current_task(), new_task, imgp-&gt;ip_new_thread);</span><br><span class="line">	</span><br><span class="line">		should_release_proc_ref = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		task_bank_init(get_threadtask(imgp-&gt;ip_new_thread));</span><br><span class="line">		proc_transend(p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Sever any extant thread affinity */</span></span><br><span class="line">		thread_affinity_exec(current_thread());</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Inherit task role from old task to new task for exec */</span></span><br><span class="line">		<span class="keyword">if</span> (!in_vfexec) &#123;</span><br><span class="line">			proc_inherit_task_role(get_threadtask(imgp-&gt;ip_new_thread), current_task());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">thread_t</span> main_thread = imgp-&gt;ip_new_thread;</span><br><span class="line">		<span class="comment">// 设置进程的主线程</span></span><br><span class="line">		task_set_main_thread_qos(new_task, main_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exec_activate_image</span><span class="params">(struct image_params *imgp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// 调用格式对应的加载函数</span></span><br><span class="line">        <span class="comment">// 比如胖指令集有对应的胖指令集加载函数</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; error == <span class="number">-1</span> &amp;&amp; execsw[i].ex_imgact != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">			error = (*execsw[i].ex_imgact)(imgp);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;execsw的结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">execsw</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*ex_imgact)(struct image_params *);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ex_name;</span><br><span class="line">&#125; execsw[] = &#123;</span><br><span class="line">	&#123; exec_mach_imgact,		<span class="string">"Mach-o Binary"</span> &#125;,</span><br><span class="line">	&#123; exec_fat_imgact,		<span class="string">"Fat Binary"</span> &#125;,</span><br><span class="line">	&#123; exec_shell_imgact,		<span class="string">"Interpreter Script"</span> &#125;,</span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对应的指令加载，load_machfile函数加载mach-o文件，activate_exec_state处理拿到的结果信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exec_mach_imgact</span><span class="params">(struct image_params *imgp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    lret = load_machfile(imgp, mach_header, thread, &amp;<span class="built_in">map</span>, &amp;load_result);</span><br><span class="line">    .......</span><br><span class="line">    lret = activate_exec_state(task, p, thread, &amp;load_result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load_return_t</span> load_machfile(</span><br><span class="line">	struct image_params	*imgp,</span><br><span class="line">	struct mach_header	*header,</span><br><span class="line">	<span class="keyword">thread_t</span> 		thread,</span><br><span class="line">	<span class="keyword">vm_map_t</span> 		*mapp,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*result</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	lret = parse_machfile(vp, <span class="built_in">map</span>, thread, header, file_offset, macho_size,</span><br><span class="line">	                      <span class="number">0</span>, aslr_page_offset, dyld_aslr_page_offset, result,</span><br><span class="line">			      <span class="literal">NULL</span>, imgp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">activate_exec_state</span><span class="params">(<span class="keyword">task_t</span> task, <span class="keyword">proc_t</span> p, <span class="keyword">thread_t</span> thread, <span class="keyword">load_result_t</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">     <span class="comment">// 设置入口点</span></span><br><span class="line">    thread_setentrypoint(thread, result-&gt;entry_point);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们再解析完mach-o文件后，就会拿到结果信息取做处理，其中就有一个设置入口点，也就是在解析完毕后就会跳转到这个入口点运行程序，所以这个入口点很关键，那这个入口点是什么呢？其赋值肯定是在解析mach-o的过程中，所以还是得先来看看解析mach-o文件的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">load_return_t</span></span><br><span class="line">parse_machfile(</span><br><span class="line">	struct vnode 		*vp,       </span><br><span class="line">	<span class="keyword">vm_map_t</span>		<span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">thread_t</span>		thread,</span><br><span class="line">	struct mach_header	*header,</span><br><span class="line">	<span class="keyword">off_t</span>			file_offset,</span><br><span class="line">	<span class="keyword">off_t</span>			macho_size,</span><br><span class="line">	<span class="keyword">int</span>			depth,</span><br><span class="line">	<span class="keyword">int64_t</span>			aslr_offset,</span><br><span class="line">	<span class="keyword">int64_t</span>			dyld_aslr_offset,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*result,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*binresult,</span><br><span class="line">	struct image_params	*imgp</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span>		ncmds;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>	*<span class="title">lcp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dylinker_command</span>	*<span class="title">dlp</span> = 0;</span></span><br><span class="line">	<span class="keyword">integer_t</span>		dlarchbits = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span> *			control;</span><br><span class="line">	<span class="keyword">load_return_t</span>		ret = LOAD_SUCCESS;</span><br><span class="line">	<span class="keyword">void</span> *			addr;</span><br><span class="line">	<span class="keyword">vm_size_t</span>		alloc_size, cmds_size;</span><br><span class="line">	<span class="keyword">size_t</span>			offset;</span><br><span class="line">	<span class="keyword">size_t</span>			oldoffset;	<span class="comment">/* for overflow check */</span></span><br><span class="line">	<span class="keyword">int</span>			pass;</span><br><span class="line">	<span class="keyword">proc_t</span>			p = current_proc();		<span class="comment">/* XXXX */</span></span><br><span class="line">	<span class="keyword">int</span>			error;</span><br><span class="line">	<span class="keyword">int</span> 			resid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span>			mach_header_sz = <span class="keyword">sizeof</span>(struct mach_header);</span><br><span class="line">	<span class="keyword">boolean_t</span>		abi64;</span><br><span class="line">	<span class="keyword">boolean_t</span>		got_code_signatures = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span>		found_header_segment = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span>		found_xhdr = FALSE;</span><br><span class="line">	<span class="keyword">int64_t</span>			slide = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">boolean_t</span>		dyld_no_load_addr = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span>		is_dyld = FALSE;</span><br><span class="line">	<span class="keyword">vm_map_offset_t</span>		effective_page_mask = MAX(PAGE_MASK, vm_map_page_mask(<span class="built_in">map</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">	<span class="keyword">uint32_t</span>		pagezero_end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span>		executable_end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span>		writable_start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">vm_map_size_t</span>		effective_page_size;</span><br><span class="line"></span><br><span class="line">	effective_page_size = MAX(PAGE_SIZE, vm_map_page_size(<span class="built_in">map</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __arm64__ */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (header-&gt;magic == MH_MAGIC_64 ||</span><br><span class="line">	    header-&gt;magic == MH_CIGAM_64) &#123;</span><br><span class="line">	    	mach_header_sz = <span class="keyword">sizeof</span>(struct mach_header_64);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Break infinite recursion</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (depth &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(LOAD_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此函数会被遍历两次，第一次解析主程序的Mach-O，第二次解析dyld</span></span><br><span class="line">	depth++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	校验文件的CPU架构和当前运行环境的CPU架构是否一致</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (((<span class="keyword">cpu_type_t</span>)(header-&gt;cputype &amp; ~CPU_ARCH_MASK) != (cpu_type() &amp; ~CPU_ARCH_MASK)) ||</span><br><span class="line">	    !grade_binary(header-&gt;cputype, </span><br><span class="line">	    	header-&gt;cpusubtype &amp; ~CPU_SUBTYPE_MASK))</span><br><span class="line">		<span class="keyword">return</span>(LOAD_BADARCH);</span><br><span class="line">		</span><br><span class="line">	abi64 = ((header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 根据文件类型，区别处理</span></span><br><span class="line">	<span class="keyword">switch</span> (header-&gt;filetype) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果是应用程序，即app</span></span><br><span class="line">	<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">		<span class="keyword">if</span> (depth != <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_EMBEDDED</span></span><br><span class="line">		<span class="comment">// 如果需要作为动态链接器的输入文件，肯定会进入这里，因为dyld还需要解析一次主程序</span></span><br><span class="line">		<span class="keyword">if</span> (header-&gt;flags &amp; MH_DYLDLINK) &#123;</span><br><span class="line">			<span class="comment">/* Check properties of dynamic executables */</span></span><br><span class="line">			<span class="keyword">if</span> (!(header-&gt;flags &amp; MH_PIE) &amp;&amp; pie_required(header-&gt;cputype, header-&gt;cpusubtype &amp; ~CPU_SUBTYPE_MASK)) &#123;</span><br><span class="line">				<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line">			result-&gt;needs_dynlinker = TRUE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Check properties of static executables (disallowed except for development) */</span></span><br><span class="line">#<span class="keyword">if</span> !(DEVELOPMENT || DEBUG)</span><br><span class="line">			<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果是动态链接器</span></span><br><span class="line">	<span class="keyword">case</span> MH_DYLINKER:</span><br><span class="line">		<span class="keyword">if</span> (depth != <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		is_dyld = TRUE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addr = kalloc(alloc_size);</span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> LOAD_NOSPACE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是dyld动态链接器，并且设置了随机地址加载这个动态链接器，就将随机地址的偏移值赋给slide</span></span><br><span class="line">	<span class="keyword">if</span> ((header-&gt;flags &amp; MH_PIE) || is_dyld) &#123;</span><br><span class="line">		slide = aslr_offset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *  遍历四次，每次只做一件事</span></span><br><span class="line"><span class="comment">	 *  0: 检查代码段和数据段是否对齐</span></span><br><span class="line"><span class="comment">	 *  1: 进程状态, uuid, 代码签名</span></span><br><span class="line"><span class="comment">	 *  2: segments</span></span><br><span class="line"><span class="comment">	 *  3: dyld, encryption, check entry point</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean_t</span> slide_realign = FALSE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">	<span class="keyword">if</span> (!abi64) &#123;</span><br><span class="line">		slide_realign = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (pass = <span class="number">0</span>; pass &lt;= <span class="number">3</span>; pass++) &#123;</span><br><span class="line">		<span class="comment">// 如果不需要做对齐校验，直接下一轮</span></span><br><span class="line">		<span class="keyword">if</span> (pass == <span class="number">0</span> &amp;&amp; !slide_realign &amp;&amp; !is_dyld) &#123;</span><br><span class="line">			<span class="comment">/* if we dont need to realign the slide or determine dyld's load</span></span><br><span class="line"><span class="comment">			 * address, pass 0 can be skipped */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pass == <span class="number">1</span>) &#123;</span><br><span class="line">#<span class="keyword">if</span> __arm64__</span><br><span class="line">			<span class="keyword">boolean_t</span>	is_pie;</span><br><span class="line">			<span class="keyword">int64_t</span>		adjust;</span><br><span class="line"></span><br><span class="line">			is_pie = ((header-&gt;flags &amp; MH_PIE) != <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (pagezero_end != <span class="number">0</span> &amp;&amp;</span><br><span class="line">			    pagezero_end &lt; effective_page_size) &#123;</span><br><span class="line">				<span class="comment">/* need at least 1 page for PAGEZERO */</span></span><br><span class="line">				adjust = effective_page_size;</span><br><span class="line">				MACHO_PRINTF((<span class="string">"pagezero boundary at "</span></span><br><span class="line">					      <span class="string">"0x%llx; adjust slide from "</span></span><br><span class="line">					      <span class="string">"0x%llx to 0x%llx%s\n"</span>,</span><br><span class="line">					      (<span class="keyword">uint64_t</span>) pagezero_end,</span><br><span class="line">					      slide,</span><br><span class="line">					      slide + adjust,</span><br><span class="line">					      (is_pie</span><br><span class="line">					       ? <span class="string">""</span></span><br><span class="line">					       : <span class="string">" BUT NO PIE ****** :-("</span>)));</span><br><span class="line">				<span class="keyword">if</span> (is_pie) &#123;</span><br><span class="line">					slide += adjust;</span><br><span class="line">					pagezero_end += adjust;</span><br><span class="line">					executable_end += adjust;</span><br><span class="line">					writable_start += adjust;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pagezero_end != <span class="number">0</span>) &#123;</span><br><span class="line">				result-&gt;has_pagezero = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (executable_end == writable_start &amp;&amp; </span><br><span class="line">			    (executable_end &amp; effective_page_mask) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">			    (executable_end &amp; FOURK_PAGE_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">				 <span class="comment">// 数据段或代码段校对，让其页对齐</span></span><br><span class="line">				adjust =</span><br><span class="line">					(effective_page_size -</span><br><span class="line">					 (executable_end &amp; effective_page_mask));</span><br><span class="line">				MACHO_PRINTF((<span class="string">"page-unaligned X-W boundary at "</span></span><br><span class="line">					      <span class="string">"0x%llx; adjust slide from "</span></span><br><span class="line">					      <span class="string">"0x%llx to 0x%llx%s\n"</span>,</span><br><span class="line">					      (<span class="keyword">uint64_t</span>) executable_end,</span><br><span class="line">					      slide,</span><br><span class="line">					      slide + adjust,</span><br><span class="line">					      (is_pie</span><br><span class="line">					       ? <span class="string">""</span></span><br><span class="line">					       : <span class="string">" BUT NO PIE ****** :-("</span>)));</span><br><span class="line">				<span class="keyword">if</span> (is_pie)</span><br><span class="line">					slide += adjust;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __arm64__ */</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dyld_no_load_addr &amp;&amp; binresult) &#123;</span><br><span class="line">				<span class="comment">// dyld在用户态的地址 = 随机地址 + 文件最大的虚拟地址</span></span><br><span class="line">				slide = vm_map_round_page(slide + binresult-&gt;max_vm_addr, effective_page_mask);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		offset = mach_header_sz;</span><br><span class="line">		ncmds = header-&gt;ncmds;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (ncmds--) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 *	获取要解析的load_command地址</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			lcp = (struct load_command *)(addr + offset);</span><br><span class="line">			oldoffset = offset;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">switch</span>(lcp-&gt;cmd) &#123;</span><br><span class="line">			<span class="comment">// 指导内核如何设置新运行进行的内存空间。这些段直接从Mach-O加载到内存中</span></span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT: &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> *<span class="title">scp</span> = (<span class="title">struct</span> <span class="title">segment_command</span> *) <span class="title">lcp</span>;</span></span><br><span class="line"></span><br><span class="line">				......</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// segment映射和解析</span></span><br><span class="line">				<span class="comment">// segment下还有区的概念，比如__objc_classlist，__objc_protolist</span></span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 映射文件中的特定的字节到虚拟内存</span></span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_64: &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> *<span class="title">scp64</span> = (<span class="title">struct</span> <span class="title">segment_command_64</span> *) <span class="title">lcp</span>;</span></span><br><span class="line">				</span><br><span class="line">				......</span><br><span class="line"></span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// UNIX线程，包含堆栈</span></span><br><span class="line">			<span class="keyword">case</span> LC_UNIXTHREAD:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_unixthread(</span><br><span class="line">						 (struct thread_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 替换LC_UNIXTHREAD</span></span><br><span class="line">			<span class="keyword">case</span> LC_MAIN:</span><br><span class="line">				......</span><br><span class="line">				ret = load_main(</span><br><span class="line">						 (struct entry_point_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 加载动态链接器</span></span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_DYLINKER:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> ((depth == <span class="number">1</span>) &amp;&amp; (dlp == <span class="number">0</span>)) &#123;</span><br><span class="line">					<span class="comment">// 动态解析器地址</span></span><br><span class="line">					dlp = (struct dylinker_command *)lcp;</span><br><span class="line">					dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ret = LOAD_FAILURE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// uuid</span></span><br><span class="line">			<span class="keyword">case</span> LC_UUID:</span><br><span class="line">				<span class="keyword">if</span> (pass == <span class="number">1</span> &amp;&amp; depth == <span class="number">1</span>) &#123;</span><br><span class="line">					ret = load_uuid((struct uuid_command *) lcp,</span><br><span class="line">							(<span class="keyword">char</span> *)addr + cmds_size,</span><br><span class="line">							result);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 代码签名</span></span><br><span class="line">			<span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">				<span class="comment">/* CODE SIGNING */</span></span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">/* pager -&gt; uip -&gt;</span></span><br><span class="line"><span class="comment">				   load signatures &amp; store in uip</span></span><br><span class="line"><span class="comment">				   set VM object "signed_pages"</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				ret = load_code_signature(</span><br><span class="line">					(struct linkedit_data_command *) lcp,</span><br><span class="line">					vp,</span><br><span class="line">					file_offset,</span><br><span class="line">					macho_size,</span><br><span class="line">					header-&gt;cputype,</span><br><span class="line">					result,</span><br><span class="line">					imgp);</span><br><span class="line"></span><br><span class="line">					.......</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_CODE_DECRYPTION</span></span><br><span class="line">			<span class="comment">// 加密的段信息</span></span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = set_code_unprotect(</span><br><span class="line">					(struct encryption_info_command *) lcp,</span><br><span class="line">					addr, <span class="built_in">map</span>, slide, vp, file_offset,</span><br><span class="line">					header-&gt;cputype, header-&gt;cpusubtype);</span><br><span class="line">					......</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* Other commands are ignored by the kernel */</span></span><br><span class="line">				ret = LOAD_SUCCESS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == LOAD_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Make sure if we need dyld, we got it */</span></span><br><span class="line">		<span class="keyword">if</span> (result-&gt;needs_dynlinker &amp;&amp; !dlp) &#123;</span><br><span class="line">			ret = LOAD_FAILURE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((ret == LOAD_SUCCESS) &amp;&amp; (dlp != <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 加载动态解析器, 会再次调用一次parse_machfile</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ret = load_dylinker(dlp, dlarchbits, <span class="built_in">map</span>, thread, depth,</span><br><span class="line">					    dyld_aslr_offset, result, imgp);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		.......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == LOAD_BADMACHO &amp;&amp; found_xhdr) &#123;</span><br><span class="line">		ret = LOAD_BADMACHO_UPX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(addr, alloc_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的过程得到的结果会被赋值进load_result_t这个结果体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">load_result</span> &#123;</span></span><br><span class="line">	<span class="keyword">user_addr_t</span>		mach_header;</span><br><span class="line">	<span class="keyword">user_addr_t</span>		entry_point;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">user_addr_t</span>		user_stack;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>		user_stack_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">user_addr_t</span>		user_stack_alloc;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>		user_stack_alloc_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>	all_image_info_addr;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>		all_image_info_size;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span>			thread_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">		<span class="comment">/* boolean_t */</span>	unixproc	:<span class="number">1</span>,</span><br><span class="line">				needs_dynlinker : <span class="number">1</span>,</span><br><span class="line">				dynlinker	:<span class="number">1</span>,</span><br><span class="line">				validentry	:<span class="number">1</span>,</span><br><span class="line">				has_pagezero    :<span class="number">1</span>,</span><br><span class="line">				using_lcmain	:<span class="number">1</span>,</span><br><span class="line">				is64bit         :<span class="number">1</span>,</span><br><span class="line">						:<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		csflags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		uuid[<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>	min_vm_addr;</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>	max_vm_addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		platform_binary;</span><br><span class="line">	<span class="keyword">off_t</span>			cs_end_offset;</span><br><span class="line">	<span class="keyword">void</span>			*threadstate;</span><br><span class="line">	<span class="keyword">size_t</span>			threadstate_sz;</span><br><span class="line">&#125; <span class="keyword">load_result_t</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么在哪里设置entry_point，其实entry_point的设置在load_dylinker里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">load_return_t</span> load_dylinker&#123;</span><br><span class="line">    .......</span><br><span class="line">	*myresult = load_result_null;</span><br><span class="line">	myresult-&gt;is64bit = result-&gt;is64bit;</span><br><span class="line"></span><br><span class="line">	ret = parse_machfile(vp, <span class="built_in">map</span>, thread, header, file_offset,</span><br><span class="line">	                     macho_size, depth, slide, <span class="number">0</span>, myresult, result, imgp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == LOAD_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">if</span> (result-&gt;threadstate) &#123;</span><br><span class="line">			<span class="comment">/* don't use the app's threadstate if we have a dyld */</span></span><br><span class="line">			kfree(result-&gt;threadstate, result-&gt;threadstate_sz);</span><br><span class="line">		&#125;</span><br><span class="line">		result-&gt;threadstate = myresult-&gt;threadstate;</span><br><span class="line">		result-&gt;threadstate_sz = myresult-&gt;threadstate_sz;</span><br><span class="line"></span><br><span class="line">		result-&gt;dynlinker = TRUE;</span><br><span class="line">        <span class="comment">// 将load_result_t的entry_point，设置为dyld动态链接库的entrypoint，所以启动的时候首先加载的会是dyld。</span></span><br><span class="line">		result-&gt;entry_point = myresult-&gt;entry_point;</span><br><span class="line">		result-&gt;validentry = myresult-&gt;validentry;</span><br><span class="line">		result-&gt;all_image_info_addr = myresult-&gt;all_image_info_addr;</span><br><span class="line">		result-&gt;all_image_info_size = myresult-&gt;all_image_info_size;</span><br><span class="line">		<span class="keyword">if</span> (myresult-&gt;platform_binary) &#123;</span><br><span class="line">			result-&gt;csflags |= CS_DYLD_PLATFORM;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后，梳理下这个app启动流程：</p>
<ul>
<li><p>fork一条新的进程出来</p>
</li>
<li><p>激活app</p>
<blockquote>
<p>a.  区分文件，Mach-o Binary和Fat Binary都有对应的加载函数</p>
<p>b.  分配内存</p>
<p>c.  解析主程序的Mach-O信息</p>
<p>d.  读取主程序Mach-O头信息</p>
<p>e.  遍历主程序每条load command信息，装载进内存</p>
<p>f.  解析dyld，再把d,e的内容再做一遍，期间会将entry_point入口地址改为dyld的入口地址。</p>
</blockquote>
</li>
<li><p>进入entry_point对应的入口，启动dyld</p>
</li>
<li><p>设置进程的主线程</p>
</li>
</ul>
<p>&emsp;&emsp;所有的操作做完，这时候也已经从内核态进入用户态了。</p>
<h1 id="0x05-dyld加载程序流程"><a href="#0x05-dyld加载程序流程" class="headerlink" title="0x05 dyld加载程序流程"></a>0x05 dyld加载程序流程</h1><p>&emsp;&emsp;上面在最后一次加载完dyld后，就进入dyld的入口函数，即<code>__dyld_start</code>，这段其实是一段汇编代码</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__dyld_start</span>:</span><br><span class="line">	// 一些准备工作，获取头、参数等等这类的信息</span><br><span class="line">	<span class="keyword">mov </span>	x28, <span class="built_in">sp</span></span><br><span class="line">	<span class="keyword">and </span>    <span class="built_in">sp</span>, x28, #~<span class="number">15</span>		// force <span class="number">16</span>-<span class="keyword">byte </span>alignment of stack</span><br><span class="line">	<span class="keyword">mov	</span>x0, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">mov	</span>x1, <span class="number">#0</span></span><br><span class="line">	stp	x1, x0, [<span class="built_in">sp</span>, #-<span class="number">16</span>]!	// make aligned terminating frame</span><br><span class="line">	<span class="keyword">mov	</span><span class="built_in">fp</span>, <span class="built_in">sp</span>			// set up <span class="built_in">fp</span> to point to terminating frame</span><br><span class="line">	<span class="keyword">sub	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             // make room for local variables</span><br><span class="line">	<span class="keyword">ldr </span>    x0, [x28]		// <span class="meta">get</span> app<span class="string">'s mh into x0</span></span><br><span class="line"><span class="string"> 	ldr     x1, [x28, #8]           // get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="string">	add     x2, x28, #16		// get argv into x2</span></span><br><span class="line"><span class="string">	adrp	x4,___dso_handle@page</span></span><br><span class="line"><span class="string">	add 	x4,x4,___dso_handle@pageoff // get dyld'</span>s mh in to x4</span><br><span class="line">	<span class="keyword">adrp	</span>x3,__dso_static<span class="comment">@page</span></span><br><span class="line">	<span class="keyword">ldr </span>	x3,[x3,__dso_static<span class="comment">@pageoff] // get unslid start of dyld</span></span><br><span class="line">	<span class="keyword">sub </span>	x3,x4,x3		// x3 now has slide of dyld</span><br><span class="line">	<span class="keyword">mov	</span>x5,<span class="built_in">sp</span>                   // x5 has &amp;startGlue</span><br><span class="line">	</span><br><span class="line">	// 启动引导，入口为dyldbootstrap::start函数</span><br><span class="line">	<span class="keyword">bl	</span>__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br><span class="line">	// 会返回主程序的入口地址，并保存到x16寄存器</span><br><span class="line">	<span class="keyword">mov	</span>x16,x0                  </span><br><span class="line">	<span class="keyword">ldr </span>    x1, [<span class="built_in">sp</span>]</span><br><span class="line">	<span class="keyword">cmp	</span>x1, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">b.ne	</span>Lnew</span><br><span class="line"></span><br><span class="line">	// LC_UNIXTHREAD，由LC_MAIN代替，所以直接看下面的LC_MAIN</span><br><span class="line">	<span class="keyword">add	</span><span class="built_in">sp</span>, x28, <span class="number">#8</span>		</span><br><span class="line">	<span class="keyword">br	</span>x16			</span><br><span class="line"></span><br><span class="line">	// LC_MAIN ，设置栈信息，并跳入到主程序的入口</span><br><span class="line"><span class="symbol">Lnew</span>:	<span class="keyword">mov	</span><span class="built_in">lr</span>, x1		    // simulate return <span class="keyword">address </span>into _start in libdyld.dylib</span><br><span class="line">	<span class="keyword">ldr </span>    x0, [x28, <span class="number">#8</span>] 	    // 参数<span class="number">1</span> = argc</span><br><span class="line">	<span class="keyword">add </span>    x1, x28, <span class="number">#16</span>	    // 参数<span class="number">2</span> = argv</span><br><span class="line">	<span class="keyword">add	</span>x2, x1, x0, <span class="keyword">lsl </span><span class="number">#3</span>  </span><br><span class="line">	<span class="keyword">add	</span>x2, x2, <span class="number">#8</span>	    // 参数<span class="number">3</span> = &amp;env[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">mov	</span>x3, x2</span><br><span class="line"><span class="symbol">Lapple</span>:	<span class="keyword">ldr	</span>x4, [x3]</span><br><span class="line">	<span class="keyword">add	</span>x3, x3, <span class="number">#8</span></span><br><span class="line">	<span class="keyword">cmp	</span>x4, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">b.ne	</span>Lapple		    // 参数<span class="number">4</span> = apple</span><br><span class="line">	// 跳转到主程序的main函数</span><br><span class="line">	<span class="keyword">br	</span>x16</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>__dyld_start</code>首先会调用<code>dyldbootstrap::start</code>函数对主程序再次进行一些处理，比如加载动态库，处理完成后会返回主程序的入口地址，然后设置好主程序入口的一些参数后就进入到主程序的main函数。我们关注的是主程序启动前还做了些什么事情？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> start(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span><br><span class="line">				<span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span><br><span class="line">				<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( slide != <span class="number">0</span> ) &#123;</span><br><span class="line">		rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	mach_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line">	<span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> _main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	dyld3::kdebug_trace_dyld_signpost(DBG_DYLD_SIGNPOST_START_DYLD, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line">	<span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> ( hexToBytes(_simple_getenv(apple, <span class="string">"executable_cdhash"</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line">		mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trace dyld's load</span></span><br><span class="line">	notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">"dyld_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">	<span class="comment">// Trace the main executable's load</span></span><br><span class="line">	notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, <span class="string">"executable_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line">	sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line">	sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line"></span><br><span class="line">	CRSetCrashLogMessage(<span class="string">"dyld: launch started"</span>);</span><br><span class="line">	<span class="comment">// 设置上下文运行环境</span></span><br><span class="line">	setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line">	sExecPath = _simple_getenv(apple, <span class="string">"executable_path"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remember short name of process for later logging</span></span><br><span class="line">	sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">'/'</span>);</span><br><span class="line">	<span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">		++sExecShortName;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置进程限制</span></span><br><span class="line">    configureProcessRestrictions(mainExecutableMH);</span><br><span class="line"></span><br><span class="line">	checkEnvironmentVariables(envp);</span><br><span class="line">    </span><br><span class="line">	defaultUninitializedFallbackPaths(envp);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">		printOptions(argv);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">		printEnvironmentVariables(envp);</span><br><span class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	checkSharedRegionDisable((mach_header*)mainExecutableMH);</span><br><span class="line">	<span class="comment">// 加载共享缓存库</span></span><br><span class="line">	<span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">		mapSharedCache();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// install gdb notifier</span></span><br><span class="line">	stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB);</span><br><span class="line">	stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages);</span><br><span class="line">	<span class="comment">// make initial allocations large enough that it is unlikely to need to be re-alloced</span></span><br><span class="line">	sImageRoots.reserve(<span class="number">16</span>);</span><br><span class="line">	sAddImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">	sRemoveImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">	sImageFilesNeedingTermination.reserve(<span class="number">16</span>);</span><br><span class="line">	sImageFilesNeedingDOFUnregistration.reserve(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// add dyld itself to UUID list</span></span><br><span class="line">		addDyldImageToUUIDList();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		<span class="keyword">bool</span> mainExcutableAlreadyRebased = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> ( (sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span>) &amp;&amp; !dylibsCanOverrideCache() &amp;&amp; !sDisableAcceleratorTables &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.accelerateInfoAddr != <span class="number">0</span>) ) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statBuf</span>;</span></span><br><span class="line">			<span class="keyword">if</span> ( ::stat(IPHONE_DYLD_SHARED_CACHE_DIR <span class="string">"no-dyld2-accelerator-tables"</span>, &amp;statBuf) != <span class="number">0</span> )</span><br><span class="line">				sAllCacheImagesProxy = ImageLoaderMegaDylib::makeImageLoaderMegaDylib(&amp;sSharedCacheLoadInfo.loadAddress-&gt;header, sSharedCacheLoadInfo.slide, mainExecutableMH, gLinkContext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">reloadAllImages:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line">		<span class="comment">// 初始化主程序</span></span><br><span class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">		gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		gLinkContext.strictMachORequired = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		sAllImages.reserve((sAllCacheImagesProxy != <span class="literal">NULL</span>) ? <span class="number">16</span> : INITIAL_IMAGE_COUNT);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		sAllImages.reserve(INITIAL_IMAGE_COUNT);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line">		checkVersionedPaths();</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line">		<span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line">		<span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">		<span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line">		<span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="comment">// get path of dyld itself</span></span><br><span class="line">		<span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> len = proc_regionfilename(getpid(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line">		<span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			dyldPathBuffer[len] = <span class="string">'\0'</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">				gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加载插入的动态库</span></span><br><span class="line">		<span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">				loadInsertedDylib(*lib);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line">		<span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">		sInsertedDylibCount = sAllImages.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 链接主程序</span></span><br><span class="line">		gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">		<span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">			gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 链接插入的动态库</span></span><br><span class="line">		<span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line">		<span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line">		<span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">				link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">				image-&gt;setNeverUnloadRecursive();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line">			<span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">				image-&gt;registerInterposing();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">			ImageLoader* image = sAllImages[i];</span><br><span class="line">			<span class="keyword">if</span> ( image-&gt;inSharedCache() )</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			image-&gt;registerInterposing();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		<span class="keyword">if</span> ( (sAllCacheImagesProxy != <span class="literal">NULL</span>) &amp;&amp; ImageLoader::haveInterposingTuples() ) &#123;</span><br><span class="line">			<span class="comment">// Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled</span></span><br><span class="line">			ImageLoader::clearInterposingTuples();</span><br><span class="line">			<span class="comment">// unmap all loaded dylibs (but not main executable)</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> i=<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i];</span><br><span class="line">				<span class="keyword">if</span> ( image == sMainExecutable )</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> ( image == sAllCacheImagesProxy )</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				image-&gt;setCanUnload();</span><br><span class="line">				ImageLoader::deleteImage(image);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table</span></span><br><span class="line">			sAllImages.clear();</span><br><span class="line">			sImageRoots.clear();</span><br><span class="line">			sImageFilesNeedingTermination.clear();</span><br><span class="line">			sImageFilesNeedingDOFUnregistration.clear();</span><br><span class="line">			sAddImageCallbacks.clear();</span><br><span class="line">			sRemoveImageCallbacks.clear();</span><br><span class="line">			sDisableAcceleratorTables = <span class="literal">true</span>;</span><br><span class="line">			sAllCacheImagesProxy = <span class="literal">NULL</span>;</span><br><span class="line">			sMappedRangesStart = <span class="literal">NULL</span>;</span><br><span class="line">			mainExcutableAlreadyRebased = <span class="literal">true</span>;</span><br><span class="line">			gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">			resetAllImages();</span><br><span class="line">			<span class="keyword">goto</span> reloadAllImages;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// apply interposing to initial set of images</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.size(); ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;applyInterposing(gLinkContext);</span><br><span class="line">		&#125;</span><br><span class="line">		gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">        <span class="comment">// 弱符号绑定</span></span><br><span class="line">		sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		CRSetCrashLogMessage(<span class="string">"dyld: launch, running initializers"</span>);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">		initializeMainExecutable(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line">		dyld3::kdebug_trace_dyld_signpost(DBG_DYLD_SIGNPOST_START_MAIN_DYLD2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		notifyMonitoringDyldMain();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 寻找主程序入口点</span></span><br><span class="line">		result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getThreadPC();</span><br><span class="line">		<span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="comment">// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib</span></span><br><span class="line">			<span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">				*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				halt(<span class="string">"libdyld.dylib support not present for LC_MAIN"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let "start" in program set up for main()</span></span><br><span class="line">			result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getMain();</span><br><span class="line">			*startGlue = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* message) &#123;</span><br><span class="line">		syncAllImages();</span><br><span class="line">		halt(message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(...) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: launch failed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CRSetCrashLogMessage(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sSkipMain) &#123;</span><br><span class="line">		dyld3::kdebug_trace_dyld_signpost(DBG_DYLD_SIGNPOST_START_MAIN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		result = (<span class="keyword">uintptr_t</span>)&amp;fake_main;</span><br><span class="line">		*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;主要的步骤如下：</p>
<ul>
<li>设置上下文运行环境</li>
<li>加载共享缓存库</li>
<li>初始化主程序</li>
<li>加载插入的动态库</li>
<li>链接主程序</li>
<li>链接插入的动态库</li>
<li>初始化主程序</li>
<li>寻找主程序入口点</li>
<li>进入主程序入口点</li>
</ul>
<h4 id="加载共享缓存库：mapSharedCache"><a href="#加载共享缓存库：mapSharedCache" class="headerlink" title="加载共享缓存库：mapSharedCache"></a>加载共享缓存库：mapSharedCache</h4><p>&emsp;&emsp;我们需要知道，像每个app自带的动态库，比如libobj或者libdispatch，都是被映射到在一个共享区，每个app都是从这里读取动态库的内容。这样就可以大大节省了内存空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapSharedCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dyld3::SharedCacheOptions opts;</span><br><span class="line">	opts.cacheDirOverride	= sSharedCacheOverrideDir;</span><br><span class="line">	opts.forcePrivate		= (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion);</span><br><span class="line">	opts.useHaswell			= sHaswell;</span><br><span class="line">	opts.verbose			= gLinkContext.verboseMapping;</span><br><span class="line">    <span class="comment">// 加载动态库缓存</span></span><br><span class="line">	loadDyldCache(opts, &amp;sSharedCacheLoadInfo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update global state</span></span><br><span class="line">	<span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">		dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate;</span><br><span class="line">		dyld::gProcessInfo-&gt;sharedCacheSlide                = sSharedCacheLoadInfo.slide;</span><br><span class="line">		dyld::gProcessInfo-&gt;sharedCacheBaseAddress          = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">		sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID);</span><br><span class="line">		dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, (<span class="keyword">const</span> <span class="keyword">uuid_t</span> *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[<span class="number">0</span>], &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;&#123; <span class="number">0</span>, <span class="number">0</span> &#125;&#125;, (<span class="keyword">const</span> mach_header *)sSharedCacheLoadInfo.loadAddress);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadDyldCache</span><span class="params">(<span class="keyword">const</span> SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    results-&gt;loadAddress        = <span class="number">0</span>;</span><br><span class="line">    results-&gt;slide              = <span class="number">0</span>;</span><br><span class="line">    results-&gt;cachedDylibsGroup  = <span class="literal">nullptr</span>;</span><br><span class="line">    results-&gt;errorMessage       = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( options.forcePrivate ) &#123;</span><br><span class="line">        <span class="comment">// mmap cache into this process only</span></span><br><span class="line">        <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经映射到了共享区域了，直接将它在共享内存中的内存地址映射到进程的内存地址空间</span></span><br><span class="line">        <span class="keyword">if</span> ( reuseExistingCache(options, results) )</span><br><span class="line">            <span class="keyword">return</span> (results-&gt;errorMessage != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是第一个程序刚刚启动，共享区其实没内容的，需要将库映射到共享区</span></span><br><span class="line">        <span class="keyword">return</span> mapCacheSystemWide(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化主程序：instantiateFromLoadedImage"><a href="#初始化主程序：instantiateFromLoadedImage" class="headerlink" title="初始化主程序：instantiateFromLoadedImage"></a>初始化主程序：instantiateFromLoadedImage</h4><p>&emsp;&emsp;主要工作就是创建一个装在主程序的映像加载器(ImageLoader)。主要流程就三步：</p>
<ul>
<li>检查主程序运行的CPU架构与当前设备的CPU架构是否匹配</li>
<li>实例化一个ImageLoader</li>
<li>把ImageLoader添加到一个管理表中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">		addImage(image);</span><br><span class="line">		<span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;主要看下<code>instantiateMainExecutable</code>的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> compressed;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line">	<span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line">	<span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line">    <span class="comment">// 判断主程序是否压缩的，现在基本的程序都是压缩的</span></span><br><span class="line">    <span class="comment">// 判断方式通过段类型为LC_DYLD_INFO和LC_DYLD_INFO_ONLY的信息</span></span><br><span class="line">    <span class="comment">// switch (cmd-&gt;cmd) &#123;</span></span><br><span class="line">	<span class="comment">// 		case LC_DYLD_INFO:</span></span><br><span class="line">	<span class="comment">// 		case LC_DYLD_INFO_ONLY:</span></span><br><span class="line">	<span class="comment">// 			if ( cmd-&gt;cmdsize != sizeof(dyld_info_command) )</span></span><br><span class="line">	<span class="comment">// 				throw "malformed mach-o image: LC_DYLD_INFO size wrong";</span></span><br><span class="line">	<span class="comment">// 			dyldInfoCmd = (struct dyld_info_command*)cmd;</span></span><br><span class="line">	<span class="comment">//			*compressed = true;</span></span><br><span class="line">	<span class="comment">//			break;</span></span><br><span class="line">    <span class="comment">//      .......</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//  ......</span></span><br><span class="line">	sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line">	<span class="comment">// 根据load commands的内容来实例化具体类，这里返回一个ImageLoaderMachOCompressed对象</span></span><br><span class="line">	<span class="keyword">if</span> ( compressed ) </span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加载插入的动态库：loadInsertedDylib"><a href="#加载插入的动态库：loadInsertedDylib" class="headerlink" title="加载插入的动态库：loadInsertedDylib"></a>加载插入的动态库：loadInsertedDylib</h4><p>&emsp;&emsp;循环遍历<code>DYLD_INSERT_LIBRARIES</code>环境变量中指定的动态库列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInsertedDylib</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> cacheIndex;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		LoadContext context;</span><br><span class="line">		.......</span><br><span class="line">		image = load(path, context, cacheIndex);</span><br><span class="line">	&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从DYLD_ROOT_PATH路径进行查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase0</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ROOT_PATH</span></span><br><span class="line">	<span class="comment">// handle DYLD_ROOT_PATH which forces absolute paths to use a new root</span></span><br><span class="line">	<span class="keyword">if</span> ( (gLinkContext.rootPaths != <span class="literal">NULL</span>) &amp;&amp; (path[<span class="number">0</span>] == <span class="string">'/'</span>) ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rootPath = gLinkContext.rootPaths ; *rootPath != <span class="literal">NULL</span>; ++rootPath) &#123;</span><br><span class="line">			<span class="keyword">char</span> newPath[<span class="built_in">strlen</span>(*rootPath) + <span class="built_in">strlen</span>(path)+<span class="number">2</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(newPath, *rootPath);</span><br><span class="line">			<span class="built_in">strcat</span>(newPath, path);</span><br><span class="line">			ImageLoader* image = loadPhase1(newPath, orgPath, context, cacheIndex, exceptions);</span><br><span class="line">			<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">				<span class="keyword">return</span> image;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// try raw path</span></span><br><span class="line">	<span class="keyword">return</span> loadPhase1(path, orgPath, context, cacheIndex, exceptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loadPhase1从LD_LIBRARY_PATH路径进行查找</span></span><br><span class="line"><span class="comment">// loadPhase2从executable_path路径进行查找</span></span><br><span class="line"><span class="comment">// loadPhase3 ~ loadPhase4类似的路径查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DylibOverride&gt;::iterator it = sDylibOverrides.begin(); it != sDylibOverrides.end(); ++it) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(it-&gt;installName, path) == <span class="number">0</span> ) &#123;</span><br><span class="line">			path = it-&gt;override;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( exceptions != <span class="literal">NULL</span> ) </span><br><span class="line">        <span class="comment">// 尝试打开，如果在共享区，直接返回该动态库对应的加载器(ImageLoader)，如果不是则在硬盘区，则尝试打开，如果能打开调用loadPhase6将动态库映射到一个加载器</span></span><br><span class="line">		<span class="keyword">return</span> loadPhase5load(path, orgPath, context, cacheIndex, exceptions);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 检查是否已经存在，如果已经存在直接返回</span></span><br><span class="line">		<span class="keyword">return</span> loadPhase5check(path, orgPath, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase6</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct stat&amp; stat_buf, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ( isCompatibleMachO(firstPages, path) ) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查MACH-0类型，只有MH_BUNDLE, MH_DYLIB, 和一些MH_EXECUTE类型才可以被动态加载</span></span><br><span class="line">		<span class="keyword">const</span> mach_header* mh = (mach_header*)firstPages;</span><br><span class="line">		<span class="keyword">switch</span> ( mh-&gt;filetype ) &#123;</span><br><span class="line">			<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">			<span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> MH_BUNDLE:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"mach-o, but wrong filetype"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 初始化一个映像加载器</span></span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateFromFile(path, fd, firstPages, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 添加到全局管理</span></span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链接主程序：link"><a href="#链接主程序：link" class="headerlink" title="链接主程序：link"></a>链接主程序：link</h4><p>&emsp;&emsp;这步主要加载所有的动态库，符号绑定等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::link(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// clear error strings</span></span><br><span class="line">	(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">    <span class="comment">// 递归加载所有动态库</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">	context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we only do the loading step for preflights</span></span><br><span class="line">	<span class="keyword">if</span> ( preflightOnly )</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	context.clearAllDepths();</span><br><span class="line">    <span class="comment">// 刷新库依赖的层级。层级越深，depth越大</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">    <span class="comment">// 递归修正自己和加载动态库的基地址</span></span><br><span class="line"> 	<span class="keyword">this</span>-&gt;recursiveRebase(context);</span><br><span class="line">	context.notifyBatch(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uint64_t</span> t3 = mach_absolute_time();</span><br><span class="line">    <span class="comment">// 对no-lazy符号进行绑定，修正那些指向其他二进制文件所包含的符号的指针</span></span><br><span class="line">    <span class="comment">// lazy在运行时绑定。</span></span><br><span class="line"> 	<span class="keyword">this</span>-&gt;recursiveBind(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> t4 = mach_absolute_time();</span><br><span class="line">    <span class="comment">// 弱符号绑定</span></span><br><span class="line">	<span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">		<span class="keyword">this</span>-&gt;weakBind(context);</span><br><span class="line">	<span class="keyword">uint64_t</span> t5 = mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	context.notifyBatch(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> t6 = mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DOFInfo&gt; dofs;</span><br><span class="line">    <span class="comment">// 注册程序的DOF节区，供dtrace使用</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">	context.registerDOFs(dofs);</span><br><span class="line">	<span class="keyword">uint64_t</span> t7 = mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line">	<span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != <span class="number">0</span>) ) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;recursiveApplyInterposing(context);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// clear error strings</span></span><br><span class="line">	(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">	fgTotalRebaseTime += t3 - t2;</span><br><span class="line">	fgTotalBindTime += t4 - t3;</span><br><span class="line">	fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">	fgTotalDOF += t7 - t6;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// done with initial dylib loads</span></span><br><span class="line">	fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;继续看Mach-O格式图，我们可以看到text段下有<code>__stubs</code>和<code>__stb_helper</code>，以及data段下有<code>__nl_symbol_ptr</code>和<code>__la_symbol_ptr</code>。</p>
<p><img src="MachO_Stub.png" alt="Mach-O示意图"> </p>
<p>&emsp;&emsp;<code>__nl_symbol_ptr</code>和<code>__la_symbol_ptr</code> 分别表示non lazy binding指针表和lazy binding指针表，这两个指针表分别保存的是字符串标对应的函数地址。</p>
<p>&emsp;&emsp;我们通过一个例子来了解<code>__stubs</code>、<code>__stb_helper</code>和<code>__nl_symbol_ptr</code>、<code>__la_symbol_ptr</code> 之间的关系。测试代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"测试1"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"测试2"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在第一个printf打下断点，进入汇编模式进行查看</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">testData</span>`main:</span><br><span class="line">    <span class="number">0x1000ca618</span> &lt;+<span class="number">0</span>&gt;:  <span class="keyword">sub </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x30</span>             <span class="comment">; =0x30 </span></span><br><span class="line">    <span class="number">0x1000ca61c</span> &lt;+<span class="number">4</span>&gt;:  stp    x29, x30, [<span class="built_in">sp</span>, <span class="number">#0x20</span>]</span><br><span class="line">    <span class="number">0x1000ca620</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">add </span>   x29, <span class="built_in">sp</span>, <span class="number">#0x20</span>            <span class="comment">; =0x20 </span></span><br><span class="line">    <span class="number">0x1000ca624</span> &lt;+<span class="number">12</span>&gt;: stur   wzr, [x29, #-<span class="number">0x4</span>]</span><br><span class="line">    <span class="number">0x1000ca628</span> &lt;+<span class="number">16</span>&gt;: stur   w0, [x29, #-<span class="number">0x8</span>]</span><br><span class="line">    <span class="number">0x1000ca62c</span> &lt;+<span class="number">20</span>&gt;: <span class="keyword">str </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">-&gt;  <span class="number">0x1000ca630</span> &lt;+<span class="number">24</span>&gt;: <span class="keyword">adrp </span>  x0, <span class="number">4</span></span><br><span class="line">    <span class="number">0x1000ca634</span> &lt;+<span class="number">28</span>&gt;: <span class="keyword">add </span>   x0, x0, <span class="number">#0x871</span>            <span class="comment">; =0x871 </span></span><br><span class="line">    <span class="comment">; 跳入__stubs区</span></span><br><span class="line">    <span class="number">0x1000ca638</span> &lt;+<span class="number">32</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x1000cc67c</span>               <span class="comment">; symbol stub for: printf</span></span><br><span class="line">   </span><br><span class="line">// 查看<span class="number">0x1000cc67c</span>处内存内容是什么</span><br><span class="line">// 的确是跳入stubs区</span><br><span class="line">(lldb) image lookup --<span class="keyword">address </span><span class="number">0x1000cc67c</span></span><br><span class="line"><span class="symbol">      Address:</span> testData[<span class="number">0x000000010000867c</span>] (testData.__TEXT.__stubs + <span class="number">540</span>)</span><br><span class="line"><span class="symbol">      Summary:</span> testData`symbol stub for: printf</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;给<code>0x1000cc67c</code>下断点，继续看进入stub做什么了</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">testData</span>`printf:</span><br><span class="line">-&gt;  <span class="number">0x1000cc67c</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">nop</span></span><br><span class="line"><span class="keyword">	</span><span class="comment">; 跳入0x00000001000cc934，即进入stub_helper</span></span><br><span class="line">    <span class="number">0x1000cc680</span> &lt;+<span class="number">4</span>&gt;: <span class="keyword">ldr </span>   x16, <span class="number">#0x3b70</span>              <span class="comment">; (void *)0x0000000100080934</span></span><br><span class="line">    <span class="number">0x1000cc684</span> &lt;+<span class="number">8</span>&gt;: <span class="keyword">br </span>    x16</span><br><span class="line">    </span><br><span class="line"> // 查看<span class="number">0x00000001000cc934</span>内容，发现进入了stub_helper</span><br><span class="line"> (lldb) image lookup --<span class="keyword">address </span><span class="number">0x0000000100080934</span></span><br><span class="line"><span class="symbol">      Address:</span> testData[<span class="number">0x0000000100008934</span>] (testData.__TEXT.__stub_helper + <span class="number">588</span>)</span><br><span class="line"><span class="symbol">      Summary:</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;0x0000000100080934  - 0x0000000000078000  = 0x0000000100008934 ，而这个0x0000000100008934在Mach-O的位置，就是<code>__la_symbol_ptr</code> 内指向printf位置的地址</p>
<p><img src="stub_lazy.png" alt="Mach-O示意图"> </p>
<p>&emsp;&emsp;继续给0x0000000100080934 下断点，查看后面指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0x1000cc934</span>: <span class="keyword">ldr </span>   w16, <span class="number">0x1000cc93c</span></span><br><span class="line">    <span class="number">0x1000cc938</span>: <span class="keyword">b </span>     <span class="number">0x1000cc6e8</span></span><br><span class="line">  </span><br><span class="line"> (lldb) image lookup --<span class="keyword">address </span><span class="number">0x1001046e8</span></span><br><span class="line"><span class="symbol">      Address:</span> testData[<span class="number">0x00000001000086e8</span>] (testData.__TEXT.__stub_helper + <span class="number">0</span>)</span><br><span class="line"><span class="symbol">      Summary:</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;0x1000cc6e8处下断点</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1001046e8</span>: <span class="keyword">adr </span>   x17, <span class="number">#0x3998</span>              <span class="comment">; (void *)0x00000001200da038: initialPoolContent + 2856</span></span><br><span class="line"><span class="number">0x1001046ec</span>: <span class="keyword">nop </span>   </span><br><span class="line"><span class="number">0x1001046f0</span>: stp    x16, x17, [<span class="built_in">sp</span>, #-<span class="number">0x10</span>]!</span><br><span class="line"><span class="number">0x1001046f4</span>: <span class="keyword">nop </span></span><br><span class="line"><span class="comment">;跳入dyld_stub_binder函数</span></span><br><span class="line"><span class="number">0x1001046f8</span>: <span class="keyword">ldr </span>   x16, <span class="number">#0x3980</span>              <span class="comment">; (void *)0x00000001944e915c: dyld_stub_binder</span></span><br><span class="line"><span class="number">0x1001046fc</span>: <span class="keyword">br </span>    x16</span><br><span class="line"><span class="number">0x100104700</span>: <span class="keyword">ldr </span>   w16, <span class="number">0x100104708</span></span><br><span class="line"><span class="number">0x100104704</span>: <span class="keyword">b </span>     <span class="number">0x1001046e8</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>dyld_stub_binder</code>函数是个汇编函数，它函数地址其实是从<code>__nl_symbol_ptr</code>取到的，在ARM中<code>__nl_symbol_ptr</code>就是<code>__got</code>。</p>
<p><img src="stub_binder.png" alt="Mach-O示意图"></p>
<p>&emsp;&emsp;总结，第一次访问printf符号的时候先去<code>stub</code>，<code>stub</code>告诉从<code>__la_symbol_ptr</code>查找，<code>__la_symbol_ptr</code>表示还没有printf符号真实函数地址，需要动态绑定，于是去<code>__nl_symbol_ptr</code>查找<code>dyld_stub_binder</code>函数的地址，进行查找真实的printf地址。找到后调用printf函数，并把这个地址保存进<code>__la_symbol_ptr</code>。下次调用printf函数的时候在<code>__la_symbol_ptr</code>就能得到真实地址进行跳转。</p>
<h4 id="初始化主程序：initializeMainExecutable"><a href="#初始化主程序：initializeMainExecutable" class="headerlink" title="初始化主程序：initializeMainExecutable"></a>初始化主程序：initializeMainExecutable</h4><p>&emsp;&emsp;初始化主程序和以及其相关的模块，比如动态库。这时候就会执行以前文章说的libobjc库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record that we've reached this step</span></span><br><span class="line">	gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">	initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.size();</span><br><span class="line">	<span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">	<span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dump info if requested</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">		ImageLoader::printStatistics((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">		ImageLoaderMachO::printStatisticsDetails((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImageLoader::runInitializers(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	<span class="keyword">mach_port_t</span> thisThread = mach_thread_self();</span><br><span class="line">	ImageLoader::UninitedUpwards up;</span><br><span class="line">	up.count = <span class="number">1</span>;</span><br><span class="line">	up.images[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line">	processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">	context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line">	mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line">	<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">	fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImageLoader::processInitializers(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread,</span><br><span class="line">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> maxImageCount = context.imageCount()+<span class="number">2</span>;</span><br><span class="line">	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">	ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">	ups.count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 递归初始化所有的映像加载器内的数据，Load方法也在这里被初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line">	<span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line">		processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="寻找主程序入口点：getThreadPC"><a href="#寻找主程序入口点：getThreadPC" class="headerlink" title="寻找主程序入口点：getThreadPC"></a>寻找主程序入口点：getThreadPC</h4><p>&emsp;&emsp;在<code>LC_MAIN</code>段，程序入口点的保存位置是程序的头的起始位置 + 段记录的偏移地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* ImageLoaderMachO::getThreadPC() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">const</span> <span class="title">cmds</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)&amp;<span class="title">fMachOData</span>[<span class="title">sizeof</span>(<span class="title">macho_header</span>)];</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">cmd</span> = <span class="title">cmds</span>;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( cmd-&gt;cmd == LC_MAIN ) &#123;</span><br><span class="line">			entry_point_command* mainCmd = (entry_point_command*)cmd;</span><br><span class="line">			<span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(mainCmd-&gt;entryoff + (<span class="keyword">char</span>*)fMachOData);</span><br><span class="line">			<span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line">				<span class="keyword">return</span> entry;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"LC_MAIN entryoff is out of range"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/26/iOS的内存管理/" rel="next" title="iOS的内存管理">
                <i class="fa fa-chevron-left"></i> iOS的内存管理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/30/iOS逆向的基本操作/" rel="prev" title="iOS逆向的基本操作">
                iOS逆向的基本操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">朝暮</p>
              <p class="site-description motion-element" itemprop="description">联系方式：leylfl@foxmail.com</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-launchd"><span class="nav-number">1.</span> <span class="nav-text">0x01 launchd</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-MACH-O格式"><span class="nav-number">2.</span> <span class="nav-text">0x02 MACH-O格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-header"><span class="nav-number">2.0.1.</span> <span class="nav-text">1. header</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-filetype"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">1.1 filetype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-flags"><span class="nav-number">2.0.1.2.</span> <span class="nav-text">1.2 flags</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Load-Commands"><span class="nav-number">2.0.2.</span> <span class="nav-text">2. Load Commands</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-通用-Mach-O"><span class="nav-number">2.0.3.</span> <span class="nav-text">3. 通用 Mach-O</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-地址空间随机布局-ASLR"><span class="nav-number">3.</span> <span class="nav-text">0x03 地址空间随机布局(ASLR)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x04-dyld被加载流程"><span class="nav-number">4.</span> <span class="nav-text">0x04 dyld被加载流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x05-dyld加载程序流程"><span class="nav-number">5.</span> <span class="nav-text">0x05 dyld加载程序流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加载共享缓存库：mapSharedCache"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">加载共享缓存库：mapSharedCache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化主程序：instantiateFromLoadedImage"><span class="nav-number">5.0.0.2.</span> <span class="nav-text">初始化主程序：instantiateFromLoadedImage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加载插入的动态库：loadInsertedDylib"><span class="nav-number">5.0.0.3.</span> <span class="nav-text">加载插入的动态库：loadInsertedDylib</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接主程序：link"><span class="nav-number">5.0.0.4.</span> <span class="nav-text">链接主程序：link</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化主程序：initializeMainExecutable"><span class="nav-number">5.0.0.5.</span> <span class="nav-text">初始化主程序：initializeMainExecutable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻找主程序入口点：getThreadPC"><span class="nav-number">5.0.0.6.</span> <span class="nav-text">寻找主程序入口点：getThreadPC</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朝暮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
