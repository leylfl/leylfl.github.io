<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="&amp;emsp; &amp;emsp; Objective-C作为一门动态语言，其核心就是Runtime。本篇将从源码着手，分析Runtime的几个关键地方，使得我们可以更好的理解Runtime的运行机制。我们所有的类都继承于NSObject，所以我们先把结构列出来 123456789101112131415161718192021222324252627282930313233343536373839404">
<meta property="og:type" content="article">
<meta property="og:title" content="深入分析Runtime">
<meta property="og:url" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/index.html">
<meta property="og:site_name" content="朝暮的闲暇时刻">
<meta property="og:description" content="&amp;emsp; &amp;emsp; Objective-C作为一门动态语言，其核心就是Runtime。本篇将从源码着手，分析Runtime的几个关键地方，使得我们可以更好的理解Runtime的运行机制。我们所有的类都继承于NSObject，所以我们先把结构列出来 123456789101112131415161718192021222324252627282930313233343536373839404">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/isa_super.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/Data_Objc_CatList.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/encode.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/encode_property.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/stack_layout_01.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/stack_layout_02.png">
<meta property="og:image" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/stack_layout_03.png">
<meta property="og:updated_time" content="2018-06-16T13:43:06.624Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入分析Runtime">
<meta name="twitter:description" content="&amp;emsp; &amp;emsp; Objective-C作为一门动态语言，其核心就是Runtime。本篇将从源码着手，分析Runtime的几个关键地方，使得我们可以更好的理解Runtime的运行机制。我们所有的类都继承于NSObject，所以我们先把结构列出来 123456789101112131415161718192021222324252627282930313233343536373839404">
<meta name="twitter:image" content="https://leylfl.github.io/2018/05/21/深入分析Runtime/isa_super.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://leylfl.github.io/2018/05/21/深入分析Runtime/"/>





  <title>深入分析Runtime | 朝暮的闲暇时刻</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">朝暮的闲暇时刻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/21/深入分析Runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入分析Runtime</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-21T08:46:24+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp; &emsp; Objective-C作为一门动态语言，其核心就是Runtime。本篇将从源码着手，分析Runtime的几个关键地方，使得我们可以更好的理解Runtime的运行机制。我们所有的类都继承于NSObject，所以我们先把结构列出来</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个OC对象都有一个isa成员</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isa又是一个obc_class的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             </span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc_class又继承objc_object</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp; &emsp; 所以NSObject的结构可以大致看成下面这样的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             </span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-isa"><a href="#0x01-isa" class="headerlink" title="0x01 isa"></a>0x01 isa</h1><p>&emsp;&emsp;在ARM64之前，isa是直接指向类对象或元类对象的地址，但是在ARM64的时候，isa包含了更多的信息。isa_t是一个共用体(union)，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits; <span class="comment">// unsigned long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;作为共用体，所有成员共享一块区域。uintptr_t表示的是unsigned long，大小是8个字节，其作为共用体里最大的成员，所以这个共用体也占据8个字节的大小，可能这里有些人会觉得疑惑，明明struct里有9个uintptr_t成员，怎么会共用体才8个字节。要解释这个问题，我们需要知道位域这个概念。</p>
<p>&emsp;&emsp;位域，是指信息在存储时，并不需要占用一个完整的字节，我们可以指定其大小。这样做的目的可以使得我们可以节省空间。举个例子，假设我们养一个宠物，给它设定三个属性，分别为吃饭了没，喝水了没，洗澡了没。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> eat;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> drink;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> sleep;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们知道，BOOL占用一个字节，三个属性占用了三个字节。对于这三个属性的值非真即假，用三个字节我觉得很浪费，那么如何使用位域更节省的使用空间呢？对于一个属性非真即假，我们用二进制就可以来满足，1个字节又有8位，所以三个属性的结果只需要3位即可满足。比如睡觉在最后一位，喝水倒数第二位，睡觉倒数第三位，假如满足吃饭的条件，值就是0b0000 0001。如果满足吃饭也满足喝水，值就是0b0000 0011，以此类推。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEat:(<span class="built_in">BOOL</span>)eat;</span><br><span class="line">- (<span class="keyword">void</span>)setDrink:(<span class="built_in">BOOL</span>)drink;</span><br><span class="line">- (<span class="keyword">void</span>)setSleep:(<span class="built_in">BOOL</span>)sleep;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">BOOL</span>)eat;</span><br><span class="line">-(<span class="built_in">BOOL</span>)drink;</span><br><span class="line">-(<span class="built_in">BOOL</span>)sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> bits; <span class="comment">// 共用体占据1个字节</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> eat : <span class="number">1</span>; <span class="comment">// 指定占据1位</span></span><br><span class="line">            <span class="keyword">bool</span> drink : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> sleep : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;_action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEat:(<span class="built_in">BOOL</span>)eat &#123;</span><br><span class="line">    <span class="keyword">if</span> (eat) &#123;</span><br><span class="line">        _action.bits |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>); <span class="comment">// 1 &lt;&lt; 0即0000 0001;或上1将对应位设置为1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _action.bits &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>); <span class="comment">// ~(1 &lt;&lt; 0)即1111 1110;与上，将对应为设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDrink:(<span class="built_in">BOOL</span>)drink &#123;</span><br><span class="line">    <span class="keyword">if</span> (drink) &#123;</span><br><span class="line">        _action.bits |= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>); <span class="comment">// 1 &lt;&lt; 1，左移1位，即0000 0010;或上1将对应位设置为1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _action.bits &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">1</span>); <span class="comment">// ~(1 &lt;&lt; 1)即1111 1101;与上，将对应为设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSleep:(<span class="built_in">BOOL</span>)sleep &#123;</span><br><span class="line">    <span class="keyword">if</span> (sleep) &#123;</span><br><span class="line">        _action.bits |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">// 1 &lt;&lt; 2即0000 0100;或上1将对应位设置为1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _action.bits &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">// ~(1 &lt;&lt; 2)即1111 1011;与上，将对应为设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)eat &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(_action.bits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)); <span class="comment">// 与上,来进行取值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)drink &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(_action.bits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)sleep &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(_action.bits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    Animal *a = [Animal new];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"宠物%@，%@，%@"</span>, [a eat] ? <span class="string">@"有吃饭"</span>:<span class="string">@"没有吃饭"</span>, [a drink] ? <span class="string">@"有喝水"</span>:<span class="string">@"没有喝水"</span>, [a sleep] ? <span class="string">@"有睡觉"</span>:<span class="string">@"没有睡觉"</span>]);</span><br><span class="line">    [a setEat:<span class="literal">YES</span>];</span><br><span class="line">    [a setDrink:<span class="literal">NO</span>];</span><br><span class="line">    [a setSleep:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"宠物%@，%@，%@"</span>, [a eat] ? <span class="string">@"有吃饭"</span>:<span class="string">@"没有吃饭"</span>, [a drink] ? <span class="string">@"有喝水"</span>:<span class="string">@"没有喝水"</span>, [a sleep] ? <span class="string">@"有睡觉"</span>:<span class="string">@"没有睡觉"</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">24.118022</span>+<span class="number">0800</span> testData[<span class="number">67088</span>:<span class="number">104712921</span>] 宠物没有吃饭，没有喝水，没有睡觉</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">24.119529</span>+<span class="number">0800</span> testData[<span class="number">67088</span>:<span class="number">104712921</span>] 宠物有吃饭，没有喝水，有睡觉</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;回到isa_t共用体，我们详细解释下里面每一位的意思：</p>
<ul>
<li><p>nonpointer，占据1位</p>
<blockquote>
<p>0 : 直接执行类地址或者元类地址</p>
<p>1：包含更多信息</p>
</blockquote>
</li>
<li><p>has_assoc，占据1位</p>
<blockquote>
<p>0：没有关联对象</p>
<p>1：有关联对象</p>
</blockquote>
</li>
<li><p>has_cxx_dtor，占据1位</p>
<blockquote>
<p>0：没有C++类的析构函数</p>
<p>1：有C++类的析构函数</p>
</blockquote>
</li>
<li><p>shiftcls， 占据33位</p>
<blockquote>
<p>类地址或元类地址，具体值的算法= isa的地址 &amp; 0x0000000ffffffff8</p>
</blockquote>
</li>
<li><p>magic，占据1位</p>
<blockquote>
<p>0：对象没有完成初始化</p>
<p>1：对象完成初始化</p>
</blockquote>
</li>
<li><p>weakly_referenced，占位1位</p>
<blockquote>
<p>0：没有被弱引用指向</p>
<p>1：有被弱引用指向</p>
</blockquote>
</li>
<li><p>deallocating，占据1位</p>
<blockquote>
<p>0：没有正在被释放</p>
<p>1：正在被释放</p>
</blockquote>
</li>
<li><p>has_sidetable_rc，占据1位</p>
<blockquote>
<p>0：引用计数器可以被保存在isa里</p>
<p>1：引用计数器太大，不能保存在isa里</p>
</blockquote>
</li>
<li><p>extra_rc，占据19位</p>
<blockquote>
<p>存储引用计数 - 1的值</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;首先，证明在ARM64上isa已经不是直接指向类对象或元类对象，测试代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    Animal *a = [Animal new];</span><br><span class="line">    Class cls = object_getClass(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印a-&gt;isa的值</span></span><br><span class="line">(lldb) p/x a-&gt;isa</span><br><span class="line">(Class) $<span class="number">1</span> = <span class="number">0x000001a1025496d5</span></span><br><span class="line"><span class="comment">// 打印cls的值</span></span><br><span class="line">(lldb) p/x cls</span><br><span class="line">(Class) $<span class="number">0</span> = <span class="number">0x00000001025496d0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们发现的确isa的地址跟类地址的值是不一致的，要通过isa拿到真实的类地址需要与上0x0000000ffffffff8</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p/x <span class="number">0x000001a1025496d5</span> &amp; <span class="number">0x0000000ffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">2</span> = <span class="number">0x00000001025496d0</span> <span class="comment">// 即cls的地址值</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将0x0000000ffffffff8转换成二进制值</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p/t <span class="number">0x0000000ffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">3</span> = <span class="number">0</span>b0000000000000000000000000000111111111111111111111111111111111000</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;与上面说的shiftcls一致，即倒数第四位开始的33位。我们知道如果要取值，就是与1进行取与操作</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x000001a1025496d</span>  = <span class="number">0</span>b0000000000000000000000011010000100000010010101001001011011010101</span><br><span class="line"><span class="number">0x0000000ffffffff8</span> = <span class="number">0</span>b0000000000000000000000000000111111111111111111111111111111111000</span><br><span class="line">    	&amp;		   = <span class="number">0</span>b0000000000000000000000000000000100000010010101001001011011010000</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着，我们设置一下关联对象，证明has_assoc是否会变为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置前:<span class="number">0b0000000000000000000000011010000100000010010101001001011011010101</span>  <span class="comment">// 倒数第二位为0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Animal *a = [Animal <span class="keyword">new</span>];</span><br><span class="line">objc_setAssociatedObject(a, @selector(age), @<span class="number">100</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">设置后:<span class="number">0b0000000000000000000000011010000100000000010010011001011011101111</span> <span class="comment">// 倒数第二位为1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其他位就不一一做实验了。</p>
<h1 id="0x02-方法查找流程"><a href="#0x02-方法查找流程" class="headerlink" title="0x02 方法查找流程"></a>0x02 方法查找流程</h1><p><img src="isa_super.png" alt="isa和superClass关系示意图"> </p>
<p>&emsp;&emsp;在之前的Category文章里，其实已经提到这个，所有的调用流程如上图所示。我们只需要记住，实例对象只保存成员变量的值，实例对象的方法(比如<code>- (void)eat;</code>)保存在其类对象的方法表里，以及协议信息和成员变量信息(名字，大小等)也是保存在类对象对应的协议表和成员变量表中。而类方法(比如<code>+ (void)eat</code>)，则保存在元类(meta-class)的的方法表中。</p>
<p>&emsp;&emsp;所以下文的表述中，如果说的是类的方法表，说明找的是实例方法；如果说的是元类的方法表，说明找的是类方法。</p>
<h1 id="0x03-objc-msgSend"><a href="#0x03-objc-msgSend" class="headerlink" title="0x03 objc_msgSend"></a>0x03 objc_msgSend</h1><p>&emsp;&emsp;objc_msgSend是通过汇编代码实现的，Objective-C中调用方法实际都是走的objc_msgSend函数，所以这个函数是会被十分频繁的调用，以汇编实现将提升效率。</p>
<p>&emsp;&emsp;我们首先写下测试代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal *a = [Animal new];</span><br><span class="line">[a eat];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;符号断点在eat方法上，看下objc_msgSend汇编代码，所有方法调用都会带两个参数，一个是self，即调用者，第二个是_cmd，即调用方法，分别保存在x0和x1寄存器里。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">libobjc.A.dylib</span>`objc_msgSend:</span><br><span class="line">	<span class="comment">; x0即调用者Animal对象，#0x0即nil，也就是Animal对象是不是为0</span></span><br><span class="line">-&gt;  <span class="number">0x183c5c900</span> &lt;+<span class="number">0</span>&gt;:   <span class="keyword">cmp </span>   x0, <span class="number">#0x0</span>   </span><br><span class="line">	<span class="comment">; 如果是nil，就跳转到0x183c5c96c地址处继续执行</span></span><br><span class="line">    <span class="number">0x183c5c904</span> &lt;+<span class="number">4</span>&gt;:   <span class="keyword">b.le </span>  <span class="number">0x183c5c96c</span>  </span><br><span class="line">    <span class="comment">; 相当于a-&gt;isa的地址保存到x13寄存器。x0表示Animal实例对象a的地址，[x0]表示a-&gt;isa的地址</span></span><br><span class="line">    <span class="number">0x183c5c908</span> &lt;+<span class="number">8</span>&gt;:   <span class="keyword">ldr </span>   x13, [x0]</span><br><span class="line">    <span class="comment">; 这个上面提过，isa地址 与上 #0xffffffff8得到类对象地址，并将类对象的地址保存到x16寄存器</span></span><br><span class="line">    <span class="number">0x183c5c90c</span> &lt;+<span class="number">12</span>&gt;:  <span class="keyword">and </span>   x16, x13, <span class="number">#0xffffffff8</span></span><br><span class="line">    <span class="comment">; 在类对象地址偏移16个字节的位置，读取16个字节，分别放进x10寄存器和x11寄存器，详细看下面注解①</span></span><br><span class="line">    <span class="number">0x183c5c910</span> &lt;+<span class="number">16</span>&gt;:  ldp    x10, x11, [x16, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="comment">; w11保存的是cache_t结构体的mask成员，也就是将_cmd的低32位与mask做与运算。目的是取出方法的在散列表中的位置，保存到x12寄存器的低32位</span></span><br><span class="line">    <span class="number">0x183c5c914</span> &lt;+<span class="number">20</span>&gt;:  <span class="keyword">and </span>   w12, w1, w11</span><br><span class="line">    <span class="comment">; x10保存着散列表的首地址，x12保存着方法的位置(假设为index)，lsl #4表示左移4位，相当于乘以16，而且散列表每个成员(bucket_t)也正好占用16个字节，所以方法的实际地址 = 首地址 + index * 16。结果保存到x12寄存器</span></span><br><span class="line">    <span class="number">0x183c5c918</span> &lt;+<span class="number">24</span>&gt;:  <span class="keyword">add </span>   x12, x10, x12, <span class="keyword">lsl </span><span class="number">#4</span></span><br><span class="line">    <span class="comment">;取出x12地址开始的16个字节，前8个字节保存到x9寄存器，后8个字节保存到x17寄存器。我们知道x12保存的是我们所调用的方法在散列表中的地址，其结构是bucket_t结构体，所以方法名key保存在x9寄存器，方法地址imp保存在x17寄存器。</span></span><br><span class="line">    <span class="number">0x183c5c91c</span> &lt;+<span class="number">28</span>&gt;:  ldp    x9, x17, [x12]</span><br><span class="line">    <span class="comment">; 比较_cmd名字和散列表中所找到的方法的名字是否一致</span></span><br><span class="line">    <span class="number">0x183c5c920</span> &lt;+<span class="number">32</span>&gt;:  <span class="keyword">cmp </span>   x9, x1</span><br><span class="line">    <span class="comment">; 如果不一致，就跳转到0x183c5c92c地址</span></span><br><span class="line">    <span class="number">0x183c5c924</span> &lt;+<span class="number">36</span>&gt;:  <span class="keyword">b.ne </span>  <span class="number">0x183c5c92c</span>               <span class="comment">; &lt;+44&gt;</span></span><br><span class="line">    <span class="comment">; 如果名字一致，就直接跳转到方法的实现地址。	</span></span><br><span class="line">    <span class="number">0x183c5c928</span> &lt;+<span class="number">40</span>&gt;:  <span class="keyword">br </span>    x17</span><br><span class="line">    <span class="comment">; 之前如果方法和找到的缓存方法的名字不一样，就来到了这里，如果x9是0，那就执行_objc_msgSend_uncached函数</span></span><br><span class="line">    <span class="number">0x183c5c92c</span> &lt;+<span class="number">44</span>&gt;:  <span class="keyword">cbz </span>   x9, <span class="number">0x183c5cc00</span>           <span class="comment">; _objc_msgSend_uncached</span></span><br><span class="line">    <span class="comment">; x10保存是散列表首地址，x12保存的是当前back_t成员的地址</span></span><br><span class="line">    <span class="number">0x183c5c930</span> &lt;+<span class="number">48</span>&gt;:  <span class="keyword">cmp </span>   x12, x10</span><br><span class="line">    <span class="comment">; 如果x12跟x10值一样，说明散列表已经遍历完了, 跳转到0x183c5c940</span></span><br><span class="line">    <span class="number">0x183c5c934</span> &lt;+<span class="number">52</span>&gt;:  <span class="keyword">b.eq </span>  <span class="number">0x183c5c940</span>               <span class="comment">; &lt;+64&gt;</span></span><br><span class="line">    <span class="comment">; 如果x12跟x10值不一致，说明没遍历结束，[x12, #-0x10]!往前移动16个字节，即来到前一个bucket_t成员。</span></span><br><span class="line">    <span class="number">0x183c5c938</span> &lt;+<span class="number">56</span>&gt;:  ldp    x9, x17, [x12, #-<span class="number">0x10</span>]!</span><br><span class="line">    <span class="comment">; 跳转到上面的cmp x9, x1，继续比较方法名字是否一致</span></span><br><span class="line">    <span class="number">0x183c5c93c</span> &lt;+<span class="number">60</span>&gt;:  <span class="keyword">b </span>     <span class="number">0x183c5c920</span>               <span class="comment">; &lt;+32&gt;</span></span><br><span class="line">    <span class="comment">; 散列表遍历完成后，会来到这里。w11是掩码mask，将掩码左移4位，即左移16个字节，我们知道掩码保存的是散列表的长度减1。x12此时是散列表首地址，两者相加再次保存进x12寄存器，也就是x12保存的就是散列表最后一个成员的地址。</span></span><br><span class="line">    <span class="number">0x183c5c940</span> &lt;+<span class="number">64</span>&gt;:  <span class="keyword">add </span>   x12, x12, w11, uxtw <span class="number">#4</span></span><br><span class="line">    <span class="comment">; 同&lt;+28&gt;</span></span><br><span class="line">    <span class="number">0x183c5c944</span> &lt;+<span class="number">68</span>&gt;:  ldp    x9, x17, [x12]</span><br><span class="line">    <span class="comment">; 比较名字</span></span><br><span class="line">    <span class="number">0x183c5c948</span> &lt;+<span class="number">72</span>&gt;:  <span class="keyword">cmp </span>   x9, x1</span><br><span class="line">    <span class="comment">; 不一致就执行_objc_msgSend_uncached</span></span><br><span class="line">    <span class="number">0x183c5c94c</span> &lt;+<span class="number">76</span>&gt;:  <span class="keyword">b.ne </span>  <span class="number">0x183c5c954</span>               <span class="comment">; &lt;+84&gt;</span></span><br><span class="line">    <span class="comment">; 一致就调用方法，接下来就跟前面差不多了，后面不做解释</span></span><br><span class="line">    <span class="number">0x183c5c950</span> &lt;+<span class="number">80</span>&gt;:  <span class="keyword">br </span>    x17</span><br><span class="line">    <span class="number">0x183c5c954</span> &lt;+<span class="number">84</span>&gt;:  <span class="keyword">cbz </span>   x9, <span class="number">0x183c5cc00</span>           <span class="comment">; _objc_msgSend_uncached</span></span><br><span class="line">    <span class="number">0x183c5c958</span> &lt;+<span class="number">88</span>&gt;:  <span class="keyword">cmp </span>   x12, x10</span><br><span class="line">    <span class="comment">; 如果又回到了表头，则跳转到0x183c5c968处</span></span><br><span class="line">    <span class="number">0x183c5c95c</span> &lt;+<span class="number">92</span>&gt;:  <span class="keyword">b.eq </span>  <span class="number">0x183c5c968</span>               <span class="comment">; &lt;+104&gt;</span></span><br><span class="line">    <span class="number">0x183c5c960</span> &lt;+<span class="number">96</span>&gt;:  ldp    x9, x17, [x12, #-<span class="number">0x10</span>]!</span><br><span class="line">    <span class="number">0x183c5c964</span> &lt;+<span class="number">100</span>&gt;: <span class="keyword">b </span>     <span class="number">0x183c5c948</span>               <span class="comment">; &lt;+72&gt;</span></span><br><span class="line">    <span class="comment">; 即执行_objc_msgSend_uncached函数</span></span><br><span class="line">    <span class="number">0x183c5c968</span> &lt;+<span class="number">104</span>&gt;: <span class="keyword">b </span>     <span class="number">0x183c5cc00</span>               <span class="comment">; _objc_msgSend_uncached</span></span><br><span class="line">    <span class="number">0x183c5c96c</span> &lt;+<span class="number">108</span>&gt;: <span class="keyword">b.eq </span>  <span class="number">0x183c5c9a4</span>               <span class="comment">; &lt;+164&gt;</span></span><br><span class="line">    <span class="number">0x183c5c970</span> &lt;+<span class="number">112</span>&gt;: <span class="keyword">mov </span>   x10, #-<span class="number">0x1000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c974</span> &lt;+<span class="number">116</span>&gt;: <span class="keyword">cmp </span>   x0, x10</span><br><span class="line">    <span class="number">0x183c5c978</span> &lt;+<span class="number">120</span>&gt;: <span class="keyword">b.hs </span>  <span class="number">0x183c5c990</span>               <span class="comment">; &lt;+144&gt;</span></span><br><span class="line">    <span class="number">0x183c5c97c</span> &lt;+<span class="number">124</span>&gt;: <span class="keyword">adrp </span>  x10, <span class="number">209389</span></span><br><span class="line">    <span class="number">0x183c5c980</span> &lt;+<span class="number">128</span>&gt;: <span class="keyword">add </span>   x10, x10, <span class="number">#0x270</span>          <span class="comment">; =0x270 </span></span><br><span class="line">    <span class="number">0x183c5c984</span> &lt;+<span class="number">132</span>&gt;: <span class="keyword">lsr </span>   x11, x0, <span class="number">#60</span></span><br><span class="line">    <span class="number">0x183c5c988</span> &lt;+<span class="number">136</span>&gt;: <span class="keyword">ldr </span>   x16, [x10, x11, <span class="keyword">lsl </span><span class="number">#3</span>]</span><br><span class="line">    <span class="number">0x183c5c98c</span> &lt;+<span class="number">140</span>&gt;: <span class="keyword">b </span>     <span class="number">0x183c5c910</span>               <span class="comment">; &lt;+16&gt;</span></span><br><span class="line">    <span class="number">0x183c5c990</span> &lt;+<span class="number">144</span>&gt;: <span class="keyword">adrp </span>  x10, <span class="number">209389</span></span><br><span class="line">    <span class="number">0x183c5c994</span> &lt;+<span class="number">148</span>&gt;: <span class="keyword">add </span>   x10, x10, <span class="number">#0x2f0</span>          <span class="comment">; =0x2f0 </span></span><br><span class="line">    <span class="number">0x183c5c998</span> &lt;+<span class="number">152</span>&gt;: <span class="keyword">ubfx </span>  x11, x0, <span class="number">#52</span>, <span class="number">#8</span></span><br><span class="line">    <span class="number">0x183c5c99c</span> &lt;+<span class="number">156</span>&gt;: <span class="keyword">ldr </span>   x16, [x10, x11, <span class="keyword">lsl </span><span class="number">#3</span>]</span><br><span class="line">    <span class="number">0x183c5c9a0</span> &lt;+<span class="number">160</span>&gt;: <span class="keyword">b </span>     <span class="number">0x183c5c910</span>               <span class="comment">; &lt;+16&gt;</span></span><br><span class="line">    <span class="number">0x183c5c9a4</span> &lt;+<span class="number">164</span>&gt;: <span class="keyword">mov </span>   x1, <span class="number">#0x0</span></span><br><span class="line">    <span class="number">0x183c5c9a8</span> &lt;+<span class="number">168</span>&gt;: <span class="keyword">movi </span>  <span class="built_in">d0</span>, <span class="number">#0000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c9ac</span> &lt;+<span class="number">172</span>&gt;: <span class="keyword">movi </span>  <span class="built_in">d1</span>, <span class="number">#0000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c9b0</span> &lt;+<span class="number">176</span>&gt;: <span class="keyword">movi </span>  <span class="built_in">d2</span>, <span class="number">#0000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c9b4</span> &lt;+<span class="number">180</span>&gt;: <span class="keyword">movi </span>  <span class="built_in">d3</span>, <span class="number">#0000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c9b8</span> &lt;+<span class="number">184</span>&gt;: ret    </span><br><span class="line">    <span class="number">0x183c5c9bc</span> &lt;+<span class="number">188</span>&gt;: <span class="keyword">nop</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>注解①</strong> 回到NSObject结构，我们可以发现偏移16个字节就是cache_t成员的位置。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    isa_t isa; <span class="comment">// 8个字节</span></span><br><span class="line">    Class superclass; <span class="comment">// class其实也就是isa_t，也是8个字节</span></span><br><span class="line">    cache_t cache;              </span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache_t结构体</span></span><br><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets; <span class="comment">// 指针8个字节，指向一个散列表</span></span><br><span class="line">    mask_t _mask; <span class="comment">// 掩码。 mask_t 即uint32_t，是4个字节。表示的是散列表长度 - 1，类似于数组，数组长度为n，但是取值从0开始的，所以需要n-1。</span></span><br><span class="line">    mask_t _occupied; <span class="comment">// 4个字节。表示的缓存方法的个数</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket_t结构体</span></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">    cache_key_t _key; <span class="comment">// 方法名，cache_key_t即unsigned long，8个字节</span></span><br><span class="line">    IMP _imp; <span class="comment">// 方法的实现地址，指针8个字节</span></span><br><span class="line">    ......</span><br><span class="line">&#125;; <span class="comment">// bucket_t占用16个字节</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以，我们可以发现cache成员位置开始取16个字节，其实就是把散列表bucket_t的首地址保存到x10寄存器；我们知道一个寄存器占用8个字节，所以mask掩码保存到x11寄存器的低32位，occupied保存到x11寄存器的高32位。</p>
<p>&emsp;&emsp;上面的流程总结如下：</p>
<ul>
<li>判断对象是否为空</li>
<li>取到isa地址</li>
<li>根据isa地址拿到类对象的地址</li>
<li>来到缓存成员cache_t的地址，为的是开始遍历缓存散列表</li>
<li>计算出我们调用方法在散列表的位置index</li>
<li>根据散列表首地址和散列表成员长度计算出方法在散列表的具体地址：方法地址 = 首地址 + 成员长度 * index</li>
<li>比较我们调用的方法名字和散列表中找到的方法的名字是否一致，如果方法名字为空(说明肯定没被缓存过)，那么就跳转到_objc_msgSend_uncached函数，一般第一次调用方法都会执行到这里的时候就跳转走了。</li>
<li>如果调用的方法有名字(说明被缓存过了)，且一致的话就直接调用函数执行地址。</li>
<li>不一致的话，往前找前一个成员，也是进行名字比较。依次类推，直到来到首地址。</li>
<li>如果来到首地址，这时候还是没找到跟我们调用方法名字一致的散列表成员，就扩大搜索范围，来到散列表尾部再往前一个个遍历，查找与调用方法名字一致的散列表成员。</li>
<li>第二次来到表头还是没找到，就调用_objc_msgSend_uncached函数。</li>
</ul>
<p>&emsp;&emsp;前面说到，如果缓存里找不到缓存，就会调用_objc_msgSend_uncached，我们看下源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">// THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">// Out-of-band x16 is the class to search</span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">br	x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;源码里有一个MethodTableLookup的宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">	......</span><br><span class="line">	bl	__class_lookupMethodAndLoadCache3</span><br><span class="line">	......</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;里面调用c函数__class_lookupMethodAndLoadCache3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为缓存里没找到，所以入参cache为NO</span></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj,</span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找主要在这个函数里面</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果cache为YES，显然这里是NO</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    runtimeLock.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果类还没被构造好，即class_rw_t结构体还没被初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        runtimeLock.write();</span><br><span class="line"></span><br><span class="line">        realizeClass(cls);</span><br><span class="line"></span><br><span class="line">        runtimeLock.unlockWrite();</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果类还是没初始化，一般第一次来到某个函数，就会执行一次也是唯一一次的initialize方法。</span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertReading();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 再次尝试在本类缓存中查找，如果找到了就结束本函数</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是没在缓存中找到，就来到类的方法表中进行查找，如果找到了，在调用者缓存中保存，然后结束本函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试到父类的缓存表中查找，如果父类缓存表中没有找到，就去父类的方法表查找</span></span><br><span class="line">    <span class="comment">// 这是一个for循环，所以会遍历直到基类，即NSObject结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> attempts = unreasonableClassCount();</span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//    cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 方法表中如果找到了，在缓存中保存，然后结束本函数</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 都没有找到，进入动态方法解析流程：首先看看是否元类，是元类调用resolveClassMethod方法和resolveInstanceMethod方法，如果不是元类调用resolveInstanceMethod方法</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 如果是resolveClassMethod方法或resolveInstanceMethod方法也没被调用，直接调用转发机制。</span></span><br><span class="line">    <span class="comment">// 即先调用forwardingTargetForSelector，如果这个方法返回nil，继续调用methodSignatureForSelector，如果返回不为空继续调用forwardInvocation；如果还是为空，调用doesNotRecognizeSelector，则闪退报错</span></span><br><span class="line">    <span class="comment">// _objc_msgForward_impcache会在下文做解释</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断不是元类，调用resolveInstanceMethod方法</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是元类，首先调用resolveClassMethod方法，再次从类或者方法列表中查找，如果还是没有，再次调用resolveInstanceMethod方法</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;_objc_msgForward_impcache又是一个汇编函数</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">b </span>     <span class="number">0x183c5cda0</span>               <span class="comment">; _objc_msgForward</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;内部就是调用_objc_msgForward函数，里面就是跳转到CoreFoundation里的CF_forwarding_prep_0</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x183c5cda0</span> &lt;+<span class="number">0</span>&gt;:  <span class="keyword">adrp </span>  x17, <span class="number">209389</span></span><br><span class="line">    <span class="number">0x183c5cda4</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">ldr </span>   x17, [x17, <span class="number">#0x168</span>]</span><br><span class="line">-&gt;  <span class="number">0x183c5cda8</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">br </span>    x17</span><br><span class="line"></span><br><span class="line"><span class="comment">; 读取x17寄存器的值，即_CF_forwarding_prep_0函数</span></span><br><span class="line">(lldb) register read x17</span><br><span class="line">     x17 = <span class="number">0x000000018497a3c0</span>  CoreFoundation`_CF_forwarding_prep_0</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;_CF_forwarding_prep_0继续会调用<code>___forwarding___</code>函数，</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">CoreFoundation</span>`_CF_forwarding_prep_0:</span><br><span class="line">	<span class="comment">; 保存fp和lr寄存器</span></span><br><span class="line">-&gt;  <span class="number">0x18497a3c0</span> &lt;+<span class="number">0</span>&gt;:   stp    x29, x30, [<span class="built_in">sp</span>, #-<span class="number">0x10</span>]!</span><br><span class="line">    <span class="number">0x18497a3c4</span> &lt;+<span class="number">4</span>&gt;:   <span class="keyword">mov </span>   x29, <span class="built_in">sp</span></span><br><span class="line">    <span class="number">0x18497a3c8</span> &lt;+<span class="number">8</span>&gt;:   <span class="keyword">sub </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0xd0</span>             <span class="comment">; =0xd0 </span></span><br><span class="line">    <span class="number">0x18497a3cc</span> &lt;+<span class="number">12</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q7</span>, [<span class="built_in">sp</span>, <span class="number">#0xc0</span>]</span><br><span class="line">    <span class="number">0x18497a3d0</span> &lt;+<span class="number">16</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q6</span>, [<span class="built_in">sp</span>, <span class="number">#0xb0</span>]</span><br><span class="line">    <span class="number">0x18497a3d4</span> &lt;+<span class="number">20</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q5</span>, [<span class="built_in">sp</span>, <span class="number">#0xa0</span>]</span><br><span class="line">    <span class="number">0x18497a3d8</span> &lt;+<span class="number">24</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q4</span>, [<span class="built_in">sp</span>, <span class="number">#0x90</span>]</span><br><span class="line">    <span class="number">0x18497a3dc</span> &lt;+<span class="number">28</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q3</span>, [<span class="built_in">sp</span>, <span class="number">#0x80</span>]</span><br><span class="line">    <span class="number">0x18497a3e0</span> &lt;+<span class="number">32</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q2</span>, [<span class="built_in">sp</span>, <span class="number">#0x70</span>]</span><br><span class="line">    <span class="number">0x18497a3e4</span> &lt;+<span class="number">36</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q1</span>, [<span class="built_in">sp</span>, <span class="number">#0x60</span>]</span><br><span class="line">    <span class="number">0x18497a3e8</span> &lt;+<span class="number">40</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q0</span>, [<span class="built_in">sp</span>, <span class="number">#0x50</span>]</span><br><span class="line">    <span class="number">0x18497a3ec</span> &lt;+<span class="number">44</span>&gt;:  <span class="keyword">str </span>   x8, [<span class="built_in">sp</span>, <span class="number">#0x40</span>]</span><br><span class="line">    <span class="number">0x18497a3f0</span> &lt;+<span class="number">48</span>&gt;:  <span class="keyword">str </span>   x7, [<span class="built_in">sp</span>, <span class="number">#0x38</span>]</span><br><span class="line">    <span class="number">0x18497a3f4</span> &lt;+<span class="number">52</span>&gt;:  <span class="keyword">str </span>   x6, [<span class="built_in">sp</span>, <span class="number">#0x30</span>]</span><br><span class="line">    <span class="number">0x18497a3f8</span> &lt;+<span class="number">56</span>&gt;:  <span class="keyword">str </span>   x5, [<span class="built_in">sp</span>, <span class="number">#0x28</span>]</span><br><span class="line">    <span class="number">0x18497a3fc</span> &lt;+<span class="number">60</span>&gt;:  <span class="keyword">str </span>   x4, [<span class="built_in">sp</span>, <span class="number">#0x20</span>]</span><br><span class="line">    <span class="number">0x18497a400</span> &lt;+<span class="number">64</span>&gt;:  <span class="keyword">str </span>   x3, [<span class="built_in">sp</span>, <span class="number">#0x18</span>]</span><br><span class="line">    <span class="number">0x18497a404</span> &lt;+<span class="number">68</span>&gt;:  <span class="keyword">str </span>   x2, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="comment">; sp偏移8位开始的8位，存放方法，即_cmd</span></span><br><span class="line">    <span class="number">0x18497a408</span> &lt;+<span class="number">72</span>&gt;:  <span class="keyword">str </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">    <span class="comment">; sp开始的8位保存对象，即self</span></span><br><span class="line">    <span class="number">0x18497a40c</span> &lt;+<span class="number">76</span>&gt;:  <span class="keyword">str </span>   x0, [<span class="built_in">sp</span>]</span><br><span class="line">    <span class="comment">; sp保存到x0</span></span><br><span class="line">    <span class="number">0x18497a410</span> &lt;+<span class="number">80</span>&gt;:  <span class="keyword">mov </span>   x0, <span class="built_in">sp</span></span><br><span class="line">    <span class="number">0x18497a414</span> &lt;+<span class="number">84</span>&gt;:  <span class="keyword">mov </span>   x1, <span class="number">#0x0</span></span><br><span class="line">    <span class="comment">; 跳转到___forwarding___函数</span></span><br><span class="line">    <span class="number">0x18497a418</span> &lt;+<span class="number">88</span>&gt;:  <span class="keyword">bl </span>    <span class="number">0x184a94064</span>               <span class="comment">; ___forwarding___</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;里面进行转发流程，如果转发流程中的方法都没被实现，那么调用调用doesNotRecognizeSelector方法，程序就此闪退。汇编还是比较好理解，所以直接阅读一部分汇编代码，如果有兴趣阅读全部的汇编代码，只需要自己下符号断点，自己观察即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">CoreFoundation`___forwarding___:</span><br><span class="line">    0x184a94064 &lt;+0&gt;:    stp    x26, x25, [sp, #-0x50]!</span><br><span class="line">    0x184a94068 &lt;+4&gt;:    stp    x24, x23, [sp, #0x10]</span><br><span class="line">    0x184a9406c &lt;+8&gt;:    stp    x22, x21, [sp, #0x20]</span><br><span class="line">    0x184a94070 &lt;+12&gt;:   stp    x20, x19, [sp, #0x30]</span><br><span class="line">    0x184a94074 &lt;+16&gt;:   stp    x29, x30, [sp, #0x40]</span><br><span class="line">    0x184a94078 &lt;+20&gt;:   add    x29, sp, #0x40            ; =0x40 </span><br><span class="line">    0x184a9407c &lt;+24&gt;:   sub    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x184a94080 &lt;+28&gt;:   mov    x24, x1</span><br><span class="line">    ; 在_CF_forwarding_prep_0函数里，sp保存到了x0里面，这里又将地址赋值给了x20</span><br><span class="line">    0x184a94084 &lt;+32&gt;:   mov    x20, x0</span><br><span class="line">    0x184a94088 &lt;+36&gt;:   adrp   x8, 174263</span><br><span class="line">    0x184a9408c &lt;+40&gt;:   ldr    x8, [x8, #0x770]</span><br><span class="line">    0x184a94090 &lt;+44&gt;:   ldr    x8, [x8]</span><br><span class="line">    0x184a94094 &lt;+48&gt;:   stur   x8, [x29, #-0x48]</span><br><span class="line">    ; 从x20的地址开始取16位字节分别存到x19和x22，在在_CF_forwarding_prep_0函数里sp开始的16个字节分别存了self和_cmd，所以x19就是self，x22就是_cmd</span><br><span class="line">    0x184a94098 &lt;+52&gt;:   ldp    x19, x22, [x20]</span><br><span class="line">-&gt;  0x184a9409c &lt;+56&gt;:   tbz    x19, #0x3f, 0x184a940b8   ; &lt;+84&gt;</span><br><span class="line">    0x184a940a0 &lt;+60&gt;:   ubfx   x8, x19, #60, #3</span><br><span class="line">    0x184a940a4 &lt;+64&gt;:   cmp    x8, #0x7                  ; =0x7 </span><br><span class="line">    0x184a940a8 &lt;+68&gt;:   ubfx   x9, x19, #52, #8</span><br><span class="line">    0x184a940ac &lt;+72&gt;:   add    x9, x9, #0x8              ; =0x8 </span><br><span class="line">    0x184a940b0 &lt;+76&gt;:   csel   x8, x8, x9, ne</span><br><span class="line">    0x184a940b4 &lt;+80&gt;:   cbz    w8, 0x184a9441c           ; &lt;+952&gt;</span><br><span class="line">    ;将self移到x0寄存器</span><br><span class="line">    0x184a940b8 &lt;+84&gt;:   mov    x0, x19</span><br><span class="line">    ;调用object_getClass函数，获取Class对象，返回结果保存在x0</span><br><span class="line">    0x184a940bc &lt;+88&gt;:   bl     0x183c466c4               ; object_getClass</span><br><span class="line">    ; 将返回结果保存在x21</span><br><span class="line">    0x184a940c0 &lt;+92&gt;:   mov    x21, x0</span><br><span class="line">    ; 根据class对象得到字符串</span><br><span class="line">    0x184a940c4 &lt;+96&gt;:   bl     0x183c51810               ; class_getName</span><br><span class="line">    0x184a940c8 &lt;+100&gt;:  mov    x23, x0</span><br><span class="line">    0x184a940cc &lt;+104&gt;:  adrp   x8, 199366</span><br><span class="line">    ; 得到SEL对象forwardingTargetForSelector:并保存到x25</span><br><span class="line">    0x184a940d0 &lt;+108&gt;:  ldr    x25, [x8, #0x340]</span><br><span class="line">    ; 将class对象保存到x0</span><br><span class="line">-&gt;  0x184a940d4 &lt;+112&gt;:  mov    x0, x21</span><br><span class="line">	; 将sel对象保存到x1</span><br><span class="line">    0x184a940d8 &lt;+116&gt;:  mov    x1, x25</span><br><span class="line">    ; 调用class_respondsToSelector方法，是否实现了得到SEL对象forwardingTargetForSelector:方法</span><br><span class="line">    0x184a940dc &lt;+120&gt;:  bl     0x183c47550               ; class_respondsToSelector</span><br><span class="line">    0x184a940e0 &lt;+124&gt;:  cbz    w0, 0x184a94100           ; &lt;+156&gt;</span><br><span class="line">    0x184a940e4 &lt;+128&gt;:  mov    x0, x19</span><br><span class="line">    0x184a940e8 &lt;+132&gt;:  mov    x1, x25</span><br><span class="line">-&gt;  0x184a940ec &lt;+136&gt;:  mov    x2, x22</span><br><span class="line">	; 如果实现了就调用得到SEL对象forwardingTargetForSelector:方法</span><br><span class="line">    0x184a940f0 &lt;+140&gt;:  bl     0x183c5c900               ; objc_msgSend</span><br><span class="line">    ; 后面流程大致差不多，如果没实现得到SEL对象forwardingTargetForSelector:方法，就看下有没有methodSignatureForSelector方法，如果实现了methodSignatureForSelector方法，看下有没有调用forwardInvocation:....</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这部分流程总结如下：</p>
<ul>
<li>再次从缓存查找一次。</li>
<li>如果缓存还是没找到，去类对象的方法表里查找方法，如果找到，就保存到缓存，并执行这个方法。</li>
<li>如果类对象方法表里也没找到，就先去父类的缓存表里找，如果缓存表也没找到，就取找父类的方法表，如果找到，同样缓存方法到缓存，如果还是没找到，继续往上一层父类查找。</li>
<li>以此类推，直到找到基类，即NSObject类的方法表。</li>
<li>到了基类还是没找到，那么就先判断自己是不是元类，不是元类的话调用resolveInstanceMethod方法；是元类的话，先调用resolveClassMethod方法，接着去类的方法表一层一层查找有没有实现这个实例方法，如果也没找到就调用resolveInstanceMethod方法。</li>
<li>如果resolveInstanceMethod方法或者resolveClassMethod方法也没被调用，开启转发流程。</li>
<li>先调用forwardingTargetForSelector，如果这个方法返回nil，继续调用methodSignatureForSelector，如果返回不为空继续调用forwardInvocation；如果还是为空，调用doesNotRecognizeSelector，则闪退报错</li>
</ul>
<h1 id="0x04-Runtime的初始化"><a href="#0x04-Runtime的初始化" class="headerlink" title="0x04 Runtime的初始化"></a>0x04 Runtime的初始化</h1><p>&emsp;&emsp;这部分内容在Category文章里粗略讲述过一遍，这里将会带着源码详细走下初始化流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;load_images函数其实就是调用类的<code>+load</code>方法，这里不重复介绍，Category文章里讲的很详细了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们直接看如何加载Mach-O信息，通过map_images函数获取所有的类相关的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">map_images_nolock</span><span class="params">(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 之前做的操作，就是读取Mach-O的信息</span></span><br><span class="line">     _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Mach-O信息加载进来后，就要从数据段里读取相应的内容，并将构建成我们具体使用的类，我们的类，协议，分类等 都在数据段里，如下图。</p>
<p><img src="Data_Objc_CatList.png" alt="数据段信息示意图"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">uint32_t</span> hIndex;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    Class *resolvedFutureClasses = nil;</span><br><span class="line">    <span class="keyword">size_t</span> resolvedFutureClassCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> doneOnce;</span><br><span class="line">    <span class="function">TimeLogger <span class="title">ts</span><span class="params">(PrintImageTimes)</span></span>;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: found %d classes during launch"</span>, totalClasses);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// namedClasses</span></span><br><span class="line">        <span class="comment">// Preoptimized classes don't go in this table.</span></span><br><span class="line">        <span class="comment">// 4/3 is NXMapTable's load factor</span></span><br><span class="line">        <span class="keyword">int</span> namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line"></span><br><span class="line">        ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: first time tasks"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类的信息</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! mustReadClasses(hi)) &#123;</span><br><span class="line">            <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">        <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">		<span class="comment">// 从数据段的__objc_classlist里查找有哪些类，项目里有多少类，这里就有多少</span></span><br><span class="line">        <span class="keyword">classref_t</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// 得到类</span></span><br><span class="line">            Class cls = (Class)classlist[i];</span><br><span class="line">            <span class="comment">// 以类名有key，类为value注册进一个类映射表</span></span><br><span class="line">            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">                <span class="comment">// 跟objc_getFutureClass有关，这里可以忽略</span></span><br><span class="line">                resolvedFutureClasses = (Class *)</span><br><span class="line">                    <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                            (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover classes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修复类列表和懒加载类列表还没映射的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="comment">// 获取被引用的类，只有项目里被import的才会在这里出现</span></span><br><span class="line">            <span class="comment">// 所以_getObjc2ClassList得到的总数 - _getObjc2ClassRefs得到的总数 = 项目中没有被用到的类，可以做优化参考。</span></span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            <span class="comment">// 在类映射表重新映射</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新映射被引用的父类</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: remap classes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取被引用的方法列表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">    sel_lock();</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;isPreoptimized()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">        SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">        UnfixedSelectors += count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">            <span class="comment">// 在方法映射表中注册</span></span><br><span class="line">            sels[i] = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sel_unlock();</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up selector references"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取协议列表</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols();</span><br><span class="line">        <span class="keyword">bool</span> isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// 在协议映射表中注册</span></span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover protocols"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取被引用的协议，并重新映射</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up @protocol references"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现+load的类列表</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">            _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = remapClass(classlist[i]);</span><br><span class="line">            <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 构造类信息，只有被构造好的类才可以被使用</span></span><br><span class="line">            realizeClass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: realize non-lazy classes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取分类列表</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">			<span class="comment">// 如果类映射表里没有分类对应的类，报错</span></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理分类</span></span><br><span class="line">            <span class="comment">// 首先，注册分类到其目标类</span></span><br><span class="line">            <span class="comment">// 其次，重建类的方法表、协议表和成员变量表</span></span><br><span class="line">            <span class="keyword">bool</span> classExists = NO;</span><br><span class="line">            <span class="comment">// 实例信息</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将分类表插入到分类映射表里，供后面取出使用加入到类的方法表、协议表等</span></span><br><span class="line">                <span class="comment">// 因为此时类的结构还没被构造完成，就算要加也加不进去，所以先保存下</span></span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="comment">// 如果类已经被构造好，比如有实现+load方法的类会被先构造好，那么这里就需要重建类的结构，把类的方法、协议等重新加入进类的方法表、协议表里，并且刷新</span></span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 类信息</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover categories"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 勾建所有类的信息，以便其可以被使用</span></span><br><span class="line">    <span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">        realizeAllClasses();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EACH_HEADER</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态链接所有的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">realizeAllClasses</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi; hi = hi-&gt;getNext()) &#123;</span><br><span class="line">        realizeAllClassesInImage(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">realizeAllClassesInImage</span><span class="params">(header_info *hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    <span class="keyword">classref_t</span> *classlist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;areAllClassesRealized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">	<span class="comment">// 动态链接类，其类处于可用状态</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        realizeClass(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hi-&gt;setAllClassesRealized(YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRealized()) <span class="keyword">return</span> cls;</span><br><span class="line">    assert(cls == remapClass(cls));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取RO信息</span></span><br><span class="line">    ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line">    <span class="comment">// 之前类的信息是只读的，这时候构建成可读可写的</span></span><br><span class="line">    rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">    cls-&gt;setData(rw);</span><br><span class="line"></span><br><span class="line">    isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line"></span><br><span class="line">    rw-&gt;version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类和元类也需要构建</span></span><br><span class="line">    supercls = realizeClass(remapClass(cls-&gt;superclass));</span><br><span class="line">    metacls = realizeClass(remapClass(cls-&gt;ISA()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新被重新映射的父类和元类</span></span><br><span class="line">    cls-&gt;superclass = supercls;</span><br><span class="line">    cls-&gt;initClassIsa(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转实例变量的偏移和布局</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;setHasCxxDtor();</span><br><span class="line">        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接这个类到父类的父子关系表中</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addRootClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分类数据，比如方法表、协议表加载进类的方法表、协议表中。是前插操作，具体分类的文章里有说够</span></span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methodizing for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: methodizing class '%s' %s"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 附加属性</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 附加协议</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加分类信息</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats-&gt;count; i++) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"CLASS: attached category %c%s(%s)"</span>, </span><br><span class="line">                             isMeta ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), cats-&gt;<span class="built_in">list</span>[i].cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上面的源代码，可以知道，我们的类的都是从Mach-O得到的，一开始还没被动态链接，所以这个类是不能被使用的，整个初始化流程可以总结如下：</p>
<ul>
<li>通过Mach-O数据区里的<code>__objc_classlist</code>段，获取所有类，并注册进一个类映射表，通过这个表以后可以根据类名可以很快的得到这个类。</li>
<li>读取数据区<code>__objc_selrefs</code>段，获取所有被引用的方法，并注册进一个方法映射表</li>
<li>读取数据区<code>__objc_protolist</code>段，获取所有协议，并注册进一个协议映射表</li>
<li>读取数据区<code>__objc_nlclslist</code>段，获取所有实现了+(void)load的类，并提前链接好类，使得这个类已经准备好被使用</li>
<li>读取数据区<code>__objc_catlist</code>段，获取所有分类，并注册进一个分类映射表</li>
<li>链接所有类，使得所有类做好被使用的准备。其中包括开辟class_rw_t区，使得类的数据可以即可读又可以写，并且排列好父子关系链，最后将分类的信息前插进类的各个信息表中。</li>
</ul>
<h1 id="0x05-property分析"><a href="#0x05-property分析" class="headerlink" title="0x05 @property分析"></a>0x05 @property分析</h1><p>&emsp;&emsp;@property定义的属性，我们知道在不是分类的情况下，会自动生成getter、setter和成员变量。其实这一切都是在编译器完成的，虽然这块不涉及runtime，但是前面我们知道类构建的时候会基于class_ro_t结构重新生成一个class_rw_t结构。而class_ro_t保存的其实就是编译期类的信息，其中包括属性拆解后的信息。</p>
<p>&emsp;&emsp;定义测试代码如下</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;clang转成c++代码看下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> instanceStart;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> instanceSize;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ivarLayout;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">baseMethods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">objc_protocol_list</span> *<span class="title">baseProtocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ivar_list_t</span> *<span class="title">ivars</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *weakIvarLayout;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">isa</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">superclass</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *cache;</span><br><span class="line">	<span class="keyword">void</span> *vtable;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_ro_t</span> *<span class="title">ro</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员变量表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">ivar_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ivar_t</span> <span class="title">ivar_list</span>[2];</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_ivar_t</span>),</span><br><span class="line">	<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 属性age和name变成了_age和_name的成员变量</span></span><br><span class="line">	&#123;&#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_Animal$_age, <span class="string">"_age"</span>, <span class="string">"i"</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">	 &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_Animal$_name, <span class="string">"_name"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[4];</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">4</span>,</span><br><span class="line">    <span class="comment">// 生成对应的setter和get方法</span></span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">"age"</span>, <span class="string">"i16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_age&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setAge:"</span>, <span class="string">"v20@0:8i16"</span>, (<span class="keyword">void</span> *)_I_Animal_setAge_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"name"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_name&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setName:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_Animal_setName_&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 属性表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[2];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">	<span class="number">2</span>,</span><br><span class="line">	&#123;&#123;<span class="string">"age"</span>,<span class="string">"Ti,N,V_age"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N,V_name"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化_class_ro_t结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">class_ro_t</span> _<span class="title">OBJC_CLASS_RO_</span>$_<span class="title">Animal</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = &#123;</span></span><br><span class="line">	<span class="number">0</span>, __OFFSETOFIVAR__(struct Animal, _age), <span class="keyword">sizeof</span>(struct Animal_IMPL), </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="string">"Animal"</span>,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_INSTANCE_METHODS_Animal,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_ivar_list_t</span> *)&amp;_OBJC_$_INSTANCE_VARIABLES_Animal,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Animal,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过转换的代码可以很清楚看到，属性的确是在编译期被拆解到class_ro_t结构的各个表中。我们看下成员变量表的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">ivar_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ivar_t</span> <span class="title">ivar_list</span>[2];</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_ivar_t</span>),</span><br><span class="line">	<span class="number">2</span>, <span class="comment">// 表内元素个数</span></span><br><span class="line">	&#123;&#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_Animal$_age, <span class="string">"_age"</span>, <span class="string">"i"</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">	 &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_Animal$_name, <span class="string">"_name"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ivar_list装的是ivar_t，其结构如下，拿上面第一个ivar_t结构举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset; <span class="comment">// 成员的偏移地址，对应&amp;OBJC_IVAR_$_Animal$_age</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 名字，对应"_age"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type; <span class="comment">// 类型，对应"i"</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw; <span class="comment">//内存对齐， 对应2</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size; <span class="comment">// 对应4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>OBJC_IVAR_$_Animal$_age</code>表示成员的偏移地址，这样做的好处是只要拿到实例的地址，再加上偏移地址就能直接访问成员变量，快速的进行取值和赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> OBJC_IVAR_$_Animal$_age __attribute__ ((used, section (<span class="string">"__DATA,__objc_ivar"</span>))) = __OFFSETOFIVAR__(struct Animal, _age);</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;其他方法表和属性表初始化也类似，这里不做复述，但是我们看到在方法表中还有这样的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;(struct objc_selector *)<span class="string">"age"</span>, <span class="string">"i16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_age&#125;,</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;i16@0:8是什么样的格式，这其实是@encode指令，可以将具体的类型表示成字符串编码。</p>
<p><img src="encode.png" alt="encode示意图"> </p>
<p>&emsp;&emsp;那么i16@0:8是什么意思呢？</p>
<blockquote>
<p>i：表示返回int类型</p>
<p>16：表示整个方法占据16个字节</p>
<p>@：表示第一个参数，即对象，方法中默认带两个参数self和_cmd，这里就是指self</p>
<p>0：表示其从偏移位置0开始的8个字节，之前说过这个方法占据16个字节，self占据其中8个字节</p>
<p>：:表示第二个参数，是一个方法，即_cmd</p>
<p>8：表示偏移位置8开始的8个字节，即方法占据16个字节的后8个字节。</p>
</blockquote>
<p>&emsp;&emsp;v20@0:8i16再来一个setter方法</p>
<blockquote>
<p>v：表示返回void</p>
<p>20：表示整个方法占据20字节</p>
<p>@：表示第一个参数对象，即self，占据8个字节</p>
<p>0：表示对象从偏移值0开始占据8个字节</p>
<p>：表示第二个参数，是一个方法，即_cmd</p>
<p>8：表示方法是从偏移值8开始占据8个字节</p>
<p>i：表示第三个参数，int类型的参数</p>
<p>16：表示第三个参数从偏移值16开始占据4个字节</p>
</blockquote>
<p>&emsp;&emsp;所有参数加起来的确是20个字节。继续回到这个方法表中，_I_Animal_age就是函数的实际执行地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;(struct objc_selector *)<span class="string">"age"</span>, <span class="string">"i16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_age&#125;,</span><br></pre></td></tr></table></figure>
<p>&emsp;这里也验证了默认带的两个参数：self、cmd。<code>OBJC_IVAR_$_Animal$_age</code>前面说过表示的是成员变量的偏移地址。，通过self+偏移地址直接拿到值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _I_Animal_age(Animal * self, SEL _cmd) &#123; </span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_Animal$_age)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不同于getter，setter的执行函数内部是这样的，拿到成员变量偏移地址后赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Animal_setAge_(Animal * self, SEL _cmd, <span class="keyword">int</span> age) &#123; </span><br><span class="line">    (*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_Animal$_age)) = age; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果我自己实现了setter方法，代码又会如何变化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换代码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Animal_setAge_(Animal * self, SEL _cmd, <span class="keyword">int</span> age) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;setter方法就变成了自己定义的方法了，如果里面不写<code>_age = age</code>，那不会对成员变量_age进行赋值。</p>
<hr>
<p>&emsp;&emsp;在回来说下属性表，之前说过对方法的定义上，苹果有一套自己的@encode指令，属性同样也有这样的@endcode指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[2];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">	<span class="number">2</span>,</span><br><span class="line">	&#123;&#123;<span class="string">"age"</span>,<span class="string">"Ti,N,V_age"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N,V_name"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其参照表如下</p>
<p><img src="encode_property.png" alt="encode示意图"> </p>
<p>&emsp;&emsp;<code>Ti,N,V_age</code>的理解如下</p>
<blockquote>
<p>T：类型，后面紧跟着的就是对应类型</p>
<p>i：int类型</p>
<p>N：nonatomic</p>
<p>V_age：对应的变量名是_age</p>
</blockquote>
<p>&emsp;&emsp;<code>T@\&quot;NSString\&quot;,C,N,V_name</code>，对于这样的可以理解为如下，对于我们定义属性时的<code>@property(nonatomic, copy) NSString *name</code>是不是一一对应了。</p>
<blockquote>
<p>T@\”NSString\”：类型是个OC对象，对象名是NSString</p>
<p>C：copy</p>
<p>N：nonatomic</p>
<p>V_name：对应的变量名是_name</p>
</blockquote>
<hr>
<p>&emsp;&emsp;我们已经知道属性在编译期会自动被拆成成员变量、setter、getter以及相关属性信息放到各个对应的表中。那么我们在运行时想要创建一个属性，下面这样做可以吗？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        class_addIvar([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log2(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span>*)), <span class="keyword">@encode</span>(<span class="built_in">NSString</span> *));</span><br><span class="line">        objc_property_attribute_t attrs[] = &#123; &#123; <span class="string">"T"</span>, <span class="string">"@\"NSString\""</span> &#125;, &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;, &#123; <span class="string">"V"</span>, <span class="string">"_name"</span> &#125; &#125;;</span><br><span class="line">        class_addProperty([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"name"</span>, attrs, <span class="number">3</span>);</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(name), (IMP)nameGetter, <span class="string">"@@:"</span>);</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(setName:), (IMP)nameSetter, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *nameGetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>);</span><br><span class="line">    <span class="keyword">return</span> object_getIvar(<span class="keyword">self</span>, ivar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> nameSetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *name) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>);</span><br><span class="line">    <span class="keyword">id</span> oldName = object_getIvar(<span class="keyword">self</span>, ivar);</span><br><span class="line">    <span class="keyword">if</span> (oldName != name) object_setIvar(<span class="keyword">self</span>, ivar, [name <span class="keyword">copy</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;答案是不可以，问题出在class_addIvar函数里，所在添加ivar的类有一个是<code>RW_CONSTRUCTING</code>的标签。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL  <span class="title">class_addIvar</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type) type = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (name  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">""</span>)) name = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 来到这里返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((name  &amp;&amp;  getIvar(cls, name))  ||  size &gt; UINT32_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么在哪里设置了这个标签，<code>objc_allocateClassPair</code>函数里调用的<code>objc_initializeClassPair_internal</code>函数里设置了这个标签，而<code>objc_allocateClassPair</code>则是我们动态生成一个类的时候用到的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cls, meta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="literal">true</span><span class="comment">/*rootOK*/</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate new classes.</span></span><br><span class="line">    cls  = alloc_class_for_subclass(superclass, extraBytes);</span><br><span class="line">    meta = alloc_class_for_subclass(superclass, extraBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme mangle the name if it looks swift-y?</span></span><br><span class="line">    objc_initializeClassPair_internal(superclass, name, cls, meta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">objc_initializeClassPair_internal</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, Class cls, Class meta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set basic info</span></span><br><span class="line"></span><br><span class="line">    cls-&gt;data()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    meta-&gt;data()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以要想使用class_addIvar必须是动态生成的一个类，还不是一个在编译期就存在的类。</p>
<h4 id="一个特殊的例子"><a href="#一个特殊的例子" class="headerlink" title="一个特殊的例子"></a>一个特殊的例子</h4><p>&emsp;&emsp;下面的例子中，程序是否可以正常运行，如果可以正常运行，那么得出的结果会是什么？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)print &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"动物的名字叫：%@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *a = <span class="string">@"占位数据，测试中...."</span>;</span><br><span class="line">    </span><br><span class="line">    Class cls = [Animal <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj print];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行程序后，我们可以看到print方法顺利被调用，但是结果有点出乎预料</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动物的名字叫：占位数据，测试中....</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面已经说过，我们方法的调用首先是取isa地址，取到isa地址后，isa地址与上 #0xffffffff8得到类对象地址。而此例中，我们获取到类对象后，然后<code>&amp;cls</code>也取到了Animal类对象地址。从这里开始流程上就跟Animal实例对象调用print方法一致了，所以可以顺利调用print方法。</p>
<p>&emsp;&emsp;为了我验证说的，我们首先实例化一个Aniaml对象</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Animal *animal = [Animal new];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印animal的地址</span></span><br><span class="line">(lldb) p animal</span><br><span class="line">(Animal *) $<span class="number">0</span> = <span class="number">0x00000001d0007f00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个地址保存的第一个位置就是isa，看过class结构都清楚isa是第一个成员</span></span><br><span class="line"><span class="comment">// isa的地址为0x000001a50000e59d</span></span><br><span class="line">(lldb) x/<span class="number">4</span>g <span class="number">0x170000c80</span></span><br><span class="line"><span class="number">0x1d0007f00</span>: <span class="number">0x000001a104b8659d</span> <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x1d0007f10</span>: <span class="number">0xbadd7e6de908bead</span> <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 与上&amp; 0xffffffff8得到类对象地址</span></span><br><span class="line">(lldb) p/x <span class="number">0x000001a104b8659d</span>  &amp; <span class="number">0xffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">1</span> = <span class="number">0x0000000104b86598</span> <span class="comment">// 记住这个类地址</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 我们打断点读取obj的地址为</span></span><br><span class="line">(lldb) po obj</span><br><span class="line">&lt;Animal: <span class="number">0x16b287978</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj保存的是cls指针的地址，实际上obj就是指向cls的。要想重新拿回cls对象的地址，需要看看这个地址保存的内容是什么</span></span><br><span class="line"><span class="comment">// 我们的类对象地址再次出现了</span></span><br><span class="line">(lldb) x/<span class="number">4</span>g <span class="number">0x16b287978</span></span><br><span class="line"><span class="number">0x16b287978</span>: <span class="number">0x0000000104b86598</span> <span class="number">0x00000001d0007f00</span></span><br><span class="line"><span class="number">0x16b287988</span>: <span class="number">0x0000000104b84330</span> <span class="number">0x000000016b2879e0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以<code>[(__bridge id)obj print];</code>的时候，汇编代码中[x0]取的就是<code>0x0000000104b86598</code>，<code>0x0000000104b86598</code> &amp; <code>0xffffffff8</code>还是<code>0x0000000104b86598</code>，剩下的步骤就跟<code>[animal print]</code>流程一样的，最后调用成功。</p>
<p>&emsp;&emsp;我们的函数栈关系如下：</p>
<p><img src="stack_layout_01.png" alt="函数栈示意图"> </p>
<p>​    那么，为什么打印结果会那么奇怪呢？我们先看下正常实例调用流程是怎么样的</p>
<p><img src="stack_layout_02.png" alt="函数栈示意图"> </p>
<p>&emsp;&emsp;我们变量a指向 <code>Animal</code>实例对象所在的内存地址。调用<code>self.name</code>的时候，对象内存中第二个8个字节保存的就是变量<code>_name</code>的值，第一个8个字节肯定是isa。</p>
<p>&emsp;&emsp;那么同样的，在我们这个例子里，我们的obj指向的是cls的地址，读取<code>_name</code>就是读取cls地址开始的第二个8个字节。</p>
<p><img src="stack_layout_03.png" alt="函数栈示意图"> </p>
<p>&emsp;&emsp;我们证明下我们之前说的，断点打在print方法内，打印obj指向的内存的内容，<code>0x000000010007e5a8</code>是第一个8个字节，指的是isa指针；<code>0x000000010007c340</code>是第二个8个字节，就是我们字符串的内容，<code>self.name</code>读取的就是这块字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po self</span><br><span class="line">&lt;Animal: <span class="number">0x16fd8f970</span>&gt;</span><br><span class="line"></span><br><span class="line">(lldb) x/<span class="number">4</span>g <span class="number">0x16fd8f970</span></span><br><span class="line"><span class="number">0x16fd8f970</span>: <span class="number">0x000000010007e5a8</span> <span class="number">0x000000010007c340</span></span><br><span class="line"><span class="number">0x16fd8f980</span>: <span class="number">0x000000016fd8f9d8</span> <span class="number">0x0000000000000001</span></span><br><span class="line">(lldb) po <span class="number">0x000000010007c340</span></span><br><span class="line">占位数据，测试中....</span><br></pre></td></tr></table></figure>
<h1 id="0x06-Super"><a href="#0x06-Super" class="headerlink" title="0x06 Super"></a>0x06 Super</h1><p>&emsp;&emsp;super在我们项目中用的熟的不能再熟了，比如调用父类的方法。这里我们先举个例子，有个继承自NSObject的类，下面的打印猜猜会是什么样的？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)print &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self class is %@\n"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self superclass is %@\n"</span>, [<span class="keyword">self</span> superclass]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super class is %@\n"</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super superclass is %@\n"</span>, [<span class="keyword">super</span> superclass]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个细节很多人很容易忽视掉，我们发现[self class]、[self superclass]和[super class]、[super superclass]打印结果其实是一样的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">17.169031</span>+<span class="number">0800</span> testData[<span class="number">59785</span>:<span class="number">156959813</span>] <span class="keyword">self</span> <span class="keyword">class</span> is Animal</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">17.169237</span>+<span class="number">0800</span> testData[<span class="number">59785</span>:<span class="number">156959813</span>] <span class="keyword">self</span> superclass is <span class="built_in">NSObject</span></span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">17.169353</span>+<span class="number">0800</span> testData[<span class="number">59785</span>:<span class="number">156959813</span>] <span class="keyword">super</span> <span class="keyword">class</span> is Animal</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">17.169484</span>+<span class="number">0800</span> testData[<span class="number">59785</span>:<span class="number">156959813</span>] <span class="keyword">super</span> superclass is <span class="built_in">NSObject</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那要解开这个原因，我们还是得先将代码转换一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Animal_print(Animal * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_Animal_cb9872_mi_0, ((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"class"</span>)));</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_Animal_cb9872_mi_1, ((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"superclass"</span>)));</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_Animal_cb9872_mi_2, ((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Animal"</span>))&#125;, sel_registerName(<span class="string">"class"</span>)));</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_Animal_cb9872_mi_3, ((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Animal"</span>))&#125;, sel_registerName(<span class="string">"superclass"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有个__rw_objc_super结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">object</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">superClass</span>;</span> </span><br><span class="line">	__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;调用super的时候消息接收者实际了一个<code>__rw_objc_super</code>对象，赋值的时候<code>__rw_objc_super</code>对象的object实际是self，superClass实际是class_getSuperclass(objc_getClass(“Animal”))，即NSObject。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Animal"</span>))&#125;, sel_registerName(<span class="string">"class"</span>))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;消息发送通过<code>objc_msgSendSuper</code>，但是真机调试中我们发现，实际调用的是<code>objc_msgSendSuper2</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100799638</span> &lt;+<span class="number">64</span>&gt;:  bl     <span class="number">0x100799f64</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSendSuper2</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样<code>objc_msgSendSuper2</code>是一个汇编函数，我们需要看下其实现过程，这里其实只要看一行就够了</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">libobjc.A.dylib</span>`objc_msgSendSuper2:</span><br><span class="line">	<span class="comment">; x0即__rw_objc_super对象，取出16位分别给x0和x16寄存器，我们知道__rw_objc_super装了两个对象一个object和superClass，所以x0寄存器里装的就是self</span></span><br><span class="line">    <span class="number">0x183c5cb00</span> &lt;+<span class="number">0</span>&gt;:   ldp    x0, x16, [x0]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据函数调用约定，x0装的是消息接收者，所以实际消息接收者是self。所以[self class]和[super class]，实际消息接收者都是self，那么这两个的区别就是[self class]从自己的方法表开始查找方法，而[super class]是直接从父类的方法表开始查找方法。</p>
<h1 id="0x07-isKindOfClass-amp-isMemberOfClass"><a href="#0x07-isKindOfClass-amp-isMemberOfClass" class="headerlink" title="0x07 isKindOfClass &amp; isMemberOfClass"></a>0x07 isKindOfClass &amp; isMemberOfClass</h1><p>&emsp;&emsp;有如下测试代码，其结果如何？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Animal *animal = [Animal new];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">BOOL</span> a = [animal isKindOfClass:[animal <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> b = [animal isMemberOfClass:[animal <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> c = [animal isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> d = [animal isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> e = [Animal isKindOfClass:[Animal <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> f = [Animal isMemberOfClass:[Animal <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> g = [Animal isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> h = [Animal isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不卖关子，结果如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">① a = YES;</span><br><span class="line">② b = YES;</span><br><span class="line">③ c = YES;</span><br><span class="line">④ d = NO;</span><br><span class="line">⑤ e = NO;</span><br><span class="line">⑥ f = NO;</span><br><span class="line">⑦ g = YES;</span><br><span class="line">⑧ h = NO;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;分析为什么结果之前，我们先看下源代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((id)self) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object_getClass如果传入类对象，得到元类对象</span></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;源代码可以看出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实例方法：</span><br><span class="line">isKindOfClass： 从自己类对象开始遍历父类对象，如果跟cls相等，就返回YES</span><br><span class="line">isMemberOfClass：直接判断自己类对象与cls是否相等</span><br><span class="line"></span><br><span class="line">类方法：</span><br><span class="line">isKindOfClass： 从自己元类对象开始遍历父类元类对象，如果跟cls相等，就返回YES</span><br><span class="line">isMemberOfClass：直接判断自己元类对象与cls是否相等</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据上面得出的结论，我们的例子可以分析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animal是实例对象，其类对象是Animal，[animal class]即Animal，所以返回YES</span></span><br><span class="line">BOOL a = [animal isKindOfClass:[animal class]];</span><br><span class="line"><span class="comment">// animal是实例对象，其类对象是Animal，[animal class]即Animal，所以返回YES</span></span><br><span class="line">BOOL b = [animal isMemberOfClass:[animal class]];</span><br><span class="line"><span class="comment">// animal是实例对象，其类对象是Animal，遍历的时候回找到NSObject，所以返回YES</span></span><br><span class="line">BOOL c = [animal isKindOfClass:[NSObject class]];</span><br><span class="line"><span class="comment">// animal是实例对象，其类对象是Animal，[NSObject class]即NSObject，两者不相等，所以返回NO</span></span><br><span class="line">BOOL d = [animal isMemberOfClass:[NSObject class]];</span><br><span class="line"><span class="comment">// Animal是类对象，内部是比较元类对象，而[Animal class]是类对象，遍历只是找此元类对象的父类，两者肯定不相等，所以返回NO</span></span><br><span class="line">BOOL e = [Animal isKindOfClass:[Animal class]];</span><br><span class="line"><span class="comment">// Animal是类对象，内部是比较元类对象，而[Animal class]是类对象，两者比较肯定不相等，所以返回NO</span></span><br><span class="line">BOOL f = [Animal isMemberOfClass:[Animal class]];</span><br><span class="line"><span class="comment">// Animal是类对象，内部是比较元类对象，而[NSObject class]是类对象，遍历的时候查找元类对象的父类，然而又因为NSObject是基类，我们知道元类查找父类的时候，当找到元类的基类也没找到的话，会指向类对象，所以Animal元类对象查找super的时候找到NSObject元类对象的时候，发现还是不匹配，会继续匹配NSObject的类对象，而这时[NSObject class]就是NSObject类对象，所以相等，返回YES。</span></span><br><span class="line">BOOL g = [Animal isKindOfClass:[NSObject class]];</span><br><span class="line"><span class="comment">// 因为没有遍历，元类对象跟类对象肯定不相等，所以返回NO</span></span><br><span class="line">BOOL h = [Animal isMemberOfClass:[NSObject class]];</span><br></pre></td></tr></table></figure>
<h1 id="0x08-方法交换"><a href="#0x08-方法交换" class="headerlink" title="0x08 方法交换"></a>0x08 方法交换</h1><p>&emsp;&emsp;首先看下方法的结构信息，包含了函数实现的具体地址IMP。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以其实很好猜了，交换imp地址就能完成方法交换操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m1  ||  !m2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">	<span class="comment">// 交换</span></span><br><span class="line">    IMP m1_imp = m1-&gt;imp;</span><br><span class="line">    m1-&gt;imp = m2-&gt;imp;</span><br><span class="line">    m2-&gt;imp = m1_imp;</span><br><span class="line">	<span class="comment">// 缓存刷新下</span></span><br><span class="line">    flushCaches(nil);</span><br><span class="line"></span><br><span class="line">    updateCustomRR_AWZ(nil, m1);</span><br><span class="line">    updateCustomRR_AWZ(nil, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x09-Hook-Block"><a href="#0x09-Hook-Block" class="headerlink" title="0x09 Hook Block"></a>0x09 Hook Block</h1><p>&emsp;&emsp;我们知道可以通过<code>method_exchangeImplementations</code>可以hook我们OC方法。那么如果我想要hook block又该如何实现呢？</p>
<p>&emsp;&emsp;之前Block篇里我们知道block结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">xxxx_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="comment">// 下面两个是可选的，是捕获对象的时候会被加入到这个结构</span></span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __xxxx_block_impl_0*, struct __xxx_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __xxxx_block_impl_0*);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">xxx_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">xxx_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过<a href="https://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">官方的ABI</a>，我们看到对其完整定义如下，signature描述了方法的参数类型和返回值类型等信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_literal_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa; </span><br><span class="line">    <span class="keyword">int</span> flags; <span class="comment">// 标志位</span></span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;       </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;         </span><br><span class="line">    <span class="comment">// optional helper functions</span></span><br><span class="line">    <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);     </span><br><span class="line">    <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src);             </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;                        </span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以我们可以自己定义一个这样的结构体，然后将block对象强转为这样的结构体，这样我们就可以拿到block对象的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">blockDescription</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> block_size;</span><br><span class="line">&#125;*BlockDescription;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">blockMemoryDescription</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *blockImpl);</span><br><span class="line">&#125;*BlockMemoryDescription;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">blockSignDescription</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *signature;</span><br><span class="line">&#125;*BlockSignDescription;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">    BlockDescription description;</span><br><span class="line">&#125;HBlock, *PHBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应block对象的flag成员</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>),</span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>),</span><br><span class="line">    BLOCK_HAS_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// IFF BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE =     (<span class="number">1</span> &lt;&lt; <span class="number">30</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们知道进入消息转发流程后，会调用<code>NSBlock</code>的<code>methodSignatureForSelector</code>和<code>hookForwardInvocation</code>方法，<code>NSBlock</code>是官方的对象所以我们不能进行修改，所以需要替换<code>methodSignatureForSelector</code>和<code>hookForwardInvocation</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXCHANGE_METHOD(originalM, replaceM) \</span></span><br><span class="line">&#123;   Class <span class="class"><span class="keyword">class</span> = [<span class="title">NSObject</span> <span class="title">class</span>];</span> \</span><br><span class="line">    Class swizzledClass = [HookBlock class];\</span><br><span class="line">    SEL originalSelector = @selector(originalM);\</span><br><span class="line">    SEL swizzledSelector = @selector(replaceM); \</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector); \</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector); \</span><br><span class="line">    BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); \</span><br><span class="line">    <span class="keyword">if</span> (success) &#123; \</span><br><span class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);\</span><br><span class="line">    &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hookBlock:(id)block &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    EXCHANGE_METHOD(methodSignatureForSelector:, hookMethodSignatureForSelector:)</span><br><span class="line">    EXCHANGE_METHOD(forwardInvocation:, hookForwardInvocation:)</span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">// 强转为自定义的block结构</span></span><br><span class="line">    PHBlock hBlock = (__bridge PHBlock)(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换原来的block实现"><a href="#替换原来的block实现" class="headerlink" title="替换原来的block实现"></a>替换原来的block实现</h3><p>&emsp;&emsp;现在有这样一个需求，我拦截block后，需要替换其原本实现，我们原本定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>(^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"很高兴认识你"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HookBlock *hook = [HookBlock <span class="keyword">new</span>];</span><br><span class="line">    [hook hookBlock:testBlock];</span><br><span class="line"></span><br><span class="line">    testBlock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果正常调用，将会打印<code>很高兴认识你</code>，我们现在想要改变其打印为<code>很讨厌认识你</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hookBlock:(id)block &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    EXCHANGE_METHOD(methodSignatureForSelector:, hookMethodSignatureForSelector:)</span><br><span class="line">    EXCHANGE_METHOD(forwardInvocation:, hookForwardInvocation:)</span><br><span class="line">&#125;);</span><br><span class="line">    PHBlock hBlock = (__bridge PHBlock)(block);</span><br><span class="line">    </span><br><span class="line">    Method replaceMethod = class_getInstanceMethod([self class], @selector(replaceBlock));</span><br><span class="line">    IMP replaceMethodIMP = method_getImplementation(replaceMethod);</span><br><span class="line">    hBlock-&gt;FuncPtr = replaceMethodIMP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)replaceBlock &#123;</span><br><span class="line">    NSLog(@<span class="string">"很讨厌认识你"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行后，可以看到成功替换了实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-23</span> <span class="number">20</span>:<span class="number">55</span>:<span class="number">31.041306</span>+<span class="number">0800</span> testData[<span class="number">29327</span>:<span class="number">25955322</span>] 很讨厌认识你</span><br></pre></td></tr></table></figure>
<h3 id="打印block的参数"><a href="#打印block的参数" class="headerlink" title="打印block的参数"></a>打印block的参数</h3><p>&emsp;&emsp;我们再次改变需求，这次我们想要先打印下block的参数，然后再调用其实现方法。</p>
<p>&emsp;&emsp;先看下初始化代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>(^testBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        NSString *result = [NSString stringWithFormat:@<span class="string">"%d + %d = %d"</span>, a, b, a + b];</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, result);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HookBlock *hook = [HookBlock <span class="keyword">new</span>];</span><br><span class="line">    [hook hookBlock:testBlock];</span><br><span class="line"></span><br><span class="line">    testBlock(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们首先拦截block，然后进入消息转发流程，根据<code>NSMethodSignature</code>可以获得参数类型，根据<code>NSInvocation</code>可以获得参数值，所以我们的实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hookBlock:(id)block &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    EXCHANGE_METHOD(methodSignatureForSelector:, hookMethodSignatureForSelector:)</span><br><span class="line">    EXCHANGE_METHOD(forwardInvocation:, hookForwardInvocation:)</span><br><span class="line">&#125;);</span><br><span class="line">    PHBlock hBlock = (__bridge PHBlock)(block);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存原来实现函数地址</span></span><br><span class="line">    objc_setAssociatedObject(block, <span class="string">"originImp"</span>, [NSValue valueWithPointer:hBlock-&gt;FuncPtr], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    <span class="comment">// 指向进入消息转发流程的函数地址</span></span><br><span class="line">    hBlock-&gt;FuncPtr = _objc_msgForward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)hookMethodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    PHBlock block = (__bridge PHBlock)self;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> *desc = (<span class="keyword">uint8_t</span> *)block-&gt;description;</span><br><span class="line">    desc += <span class="keyword">sizeof</span>(struct _blockDescription);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(block-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">        desc += <span class="keyword">sizeof</span>(struct _blockMemoryDescription);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BlockSignDescription signDesc = (BlockSignDescription)desc;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * signature = signDesc-&gt;signature;</span><br><span class="line">    <span class="keyword">return</span> [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hookForwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    PHBlock block = (__bridge PHBlock)self;</span><br><span class="line">    </span><br><span class="line">    NSMethodSignature *methodSignature = [anInvocation methodSignature];</span><br><span class="line">    NSInteger numberOfArguments = [methodSignature numberOfArguments];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">1</span>; i &lt; numberOfArguments; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *argTypeName = [methodSignature getArgumentTypeAtIndex:i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (argTypeName[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'@'</span>: &#123;</span><br><span class="line">                __unsafe_unretained id type;</span><br><span class="line">                [anInvocation getArgument:&amp;type atIndex:i];</span><br><span class="line">                NSLog(@<span class="string">"%@"</span>, [NSString stringWithFormat:@<span class="string">"第%@个参数值为%@"</span>, @(i), type]);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TYPE_ARG(_typeSymbol, _type) \</span></span><br><span class="line">    <span class="keyword">case</span> _typeSymbol: &#123; \</span><br><span class="line">        _type type; \</span><br><span class="line">        [anInvocation getArgument:&amp;type atIndex:i]; \</span><br><span class="line">        NSString *result = [NSString stringWithFormat:@<span class="string">"第%@个参数值为%@"</span>, @(i), @(type)];       \</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, result); \</span><br><span class="line">    &#125;<span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'i'</span>, <span class="keyword">int</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'I'</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'l'</span>, <span class="keyword">long</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'L'</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'q'</span>, <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'Q'</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'f'</span>, <span class="keyword">float</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'d'</span>, <span class="keyword">double</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'B'</span>, BOOL);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'c'</span>, <span class="keyword">char</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'C'</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新调用自己的实现</span></span><br><span class="line">    NSValue *pointerValue = objc_getAssociatedObject(anInvocation.target, <span class="string">"originImp"</span>);</span><br><span class="line">    block-&gt;FuncPtr = pointerValue.pointerValue;</span><br><span class="line">    [anInvocation invoke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/15/浅谈ARM64汇编/" rel="next" title="浅谈ARM64汇编">
                <i class="fa fa-chevron-left"></i> 浅谈ARM64汇编
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/24/深入分析Runloop/" rel="prev" title="深入分析Runloop">
                深入分析Runloop <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">朝暮</p>
              <p class="site-description motion-element" itemprop="description">联系方式：leylfl@foxmail.com</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-isa"><span class="nav-number">1.</span> <span class="nav-text">0x01 isa</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-方法查找流程"><span class="nav-number">2.</span> <span class="nav-text">0x02 方法查找流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-objc-msgSend"><span class="nav-number">3.</span> <span class="nav-text">0x03 objc_msgSend</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x04-Runtime的初始化"><span class="nav-number">4.</span> <span class="nav-text">0x04 Runtime的初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x05-property分析"><span class="nav-number">5.</span> <span class="nav-text">0x05 @property分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个特殊的例子"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">一个特殊的例子</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x06-Super"><span class="nav-number">6.</span> <span class="nav-text">0x06 Super</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x07-isKindOfClass-amp-isMemberOfClass"><span class="nav-number">7.</span> <span class="nav-text">0x07 isKindOfClass &amp; isMemberOfClass</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x08-方法交换"><span class="nav-number">8.</span> <span class="nav-text">0x08 方法交换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x09-Hook-Block"><span class="nav-number">9.</span> <span class="nav-text">0x09 Hook Block</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#替换原来的block实现"><span class="nav-number">9.0.1.</span> <span class="nav-text">替换原来的block实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打印block的参数"><span class="nav-number">9.0.2.</span> <span class="nav-text">打印block的参数</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朝暮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
