<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="0x00 开篇&amp;emsp;&amp;emsp;上一篇文章，我们对于常用的GCD使用方法大致理了一遍，那么在使用过程中，我们肯定有这样的疑问？队列是怎么被创建的？任务是怎么放进队列的？为什么会造成死锁？等等等问题，所以在这一篇文章里，我们会从源码的阅读过程中解答这些疑问。虽然网上也有很多讲解源码的文章，但文章对应的源码都不是最新的，这篇文章是根据最新源码来进行阅读的。&amp;emsp;&amp;emsp;进入正题之前，我">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈iOS多线程(源码)">
<meta property="og:url" content="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/index.html">
<meta property="og:site_name" content="朝暮的闲暇时刻">
<meta property="og:description" content="0x00 开篇&amp;emsp;&amp;emsp;上一篇文章，我们对于常用的GCD使用方法大致理了一遍，那么在使用过程中，我们肯定有这样的疑问？队列是怎么被创建的？任务是怎么放进队列的？为什么会造成死锁？等等等问题，所以在这一篇文章里，我们会从源码的阅读过程中解答这些疑问。虽然网上也有很多讲解源码的文章，但文章对应的源码都不是最新的，这篇文章是根据最新源码来进行阅读的。&amp;emsp;&amp;emsp;进入正题之前，我">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/gcd_opensource.png">
<meta property="og:updated_time" content="2018-06-05T07:54:07.142Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈iOS多线程(源码)">
<meta name="twitter:description" content="0x00 开篇&amp;emsp;&amp;emsp;上一篇文章，我们对于常用的GCD使用方法大致理了一遍，那么在使用过程中，我们肯定有这样的疑问？队列是怎么被创建的？任务是怎么放进队列的？为什么会造成死锁？等等等问题，所以在这一篇文章里，我们会从源码的阅读过程中解答这些疑问。虽然网上也有很多讲解源码的文章，但文章对应的源码都不是最新的，这篇文章是根据最新源码来进行阅读的。&amp;emsp;&amp;emsp;进入正题之前，我">
<meta name="twitter:image" content="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/gcd_opensource.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/"/>





  <title>浅谈iOS多线程(源码) | 朝暮的闲暇时刻</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">朝暮的闲暇时刻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">浅谈iOS多线程(源码)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T14:57:43+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="0x00-开篇"><a href="#0x00-开篇" class="headerlink" title="0x00 开篇"></a>0x00 开篇</h1><p>&emsp;&emsp;上一篇文章，我们对于常用的GCD使用方法大致理了一遍，那么在使用过程中，我们肯定有这样的疑问？队列是怎么被创建的？任务是怎么放进队列的？为什么会造成死锁？等等等问题，所以在这一篇文章里，我们会从源码的阅读过程中解答这些疑问。虽然网上也有很多讲解源码的文章，但文章对应的源码都不是最新的，这篇文章是根据最新源码来进行阅读的。<br>&emsp;&emsp;进入正题之前，我们需要做些准备工作。了解消息的本质</p>
<h1 id="0x01-Mach"><a href="#0x01-Mach" class="headerlink" title="0x01 Mach"></a>0x01 Mach</h1><p>&emsp;&emsp;Mach是XNU的核心，被BSD层包装。XNU由以下几个组件组成：</p>
<ul>
<li>MACH内核<ul>
<li>进程和线程抽象</li>
<li>虚拟内存管理</li>
<li>任务调度</li>
<li>进程间通信和消息传递机制</li>
</ul>
</li>
<li>BSD<ul>
<li>UNIX进程模型</li>
<li>POSIX线程模型</li>
<li>UNIX用户与组</li>
<li>网络协议栈</li>
<li>文件系统访问</li>
<li>设备访问</li>
</ul>
</li>
<li>libKern</li>
<li>I/O Kit</li>
</ul>
<p>&emsp;&emsp;Mach的独特之处在于选择了通过消息传递的方式实现对象与对象之间的通信。而其他架构一个对象要访问另一个对象需要通过一个大家都知道的接口，而Mach对象不能直接调用另一个对象，而是必须传递消息。</p>
<p>&emsp;&emsp;一条消息就像网络包一样，定义为透明的blob(binary larger object，二进制大对象)，通过固定的包头进行分装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">mach_msg_header_t</span>       header;</span><br><span class="line">        <span class="keyword">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span>	msgh_bits; <span class="comment">// 消息头标志位</span></span><br><span class="line">  <span class="keyword">mach_msg_size_t</span>	msgh_size; <span class="comment">// 大小</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>		msgh_remote_port; <span class="comment">// 目标(发消息)或源(接消息)</span></span><br><span class="line">  <span class="keyword">mach_port_t</span>		msgh_local_port; <span class="comment">// 源(发消息)或目标(接消息)</span></span><br><span class="line">  <span class="keyword">mach_port_name_t</span>	msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span>		msgh_id; <span class="comment">// 唯一id</span></span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Mach消息的发送和接收都是通过同一个API函数<code>mach_msg()</code>进行的。这个函数在用户态和内核态都有实现。为了实现消息的发送和接收，<code>mach_msg()</code>函数调用了一个Mach陷阱(trap)。Mach陷阱就是Mach中和系统调用等同的概念。在用户态调用<code>mach_msg_trap()</code>会引发陷阱机制，切换到内核态，在内核态中，内核实现的<code>mach_msg()</code>会完成实际的工作。这个函数也将会在下面的源码分析中遇到。</p>
<p>&emsp;&emsp;每一个BSD进程都在底层关联一个Mach任务对象，因为Mach提供的都是非常底层的抽象，提供的API从设计上讲很基础且不完整，所以需要在这之上提供一个更高的层次以实现完整的功能。我们开发层遇到的进程和线程就是BSD层对Mach的任务和线程的复杂包装。</p>
<p>&emsp;&emsp;进程填充的是线程，而线程是二进制代码的实际执行单元。用户态的线程始于对pthread_create的调用。这个函数的又由bsdthread_create系统调用完成，而bsdthread_create又其实是Mach中的thread_create的复杂包装，说到底真正的线程创建还是有Mach层完成。</p>
<p>&emsp;&emsp;在UNIX中，进程不能被创建出来，都是通过fork()系统调用复制出来的。复制出来的进程都会被要加载的执行程序覆盖整个内存空间。</p>
<p>&emsp;&emsp;接着，了解下常用的宏和常用的数据结构体。</p>
<h1 id="0x02-源码中常见的宏"><a href="#0x02-源码中常见的宏" class="headerlink" title="0x02 源码中常见的宏"></a>0x02 源码中常见的宏</h1><h3 id="1-builtin-expect"><a href="#1-builtin-expect" class="headerlink" title="1. __builtin_expect"></a>1. __builtin_expect</h3><p>&emsp;&emsp;这个其实是个函数，针对编译器优化的一个函数，后面几个宏是对这个函数的封装，所以提前拎出来说一下。写代码中我们经常会遇到条件判断语句<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(今天是工作日) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"好好上班"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"好好睡觉"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;CPU读取指令的时候并非一条一条的来读，而是多条一起加载进来，比如已经加载了if(今天是工作日) printf(“好好上班”);的指令，这时候条件式如果为非，也就是非工作日，那么CPU继续把printf(“好好睡觉”);这条指令加载进来，这样就造成了性能浪费的现象。<br>&emsp;&emsp;__builtin_expect的第一个参数是实际值，第二个参数是预测值。使用这个目的是告诉编译器if条件式是不是有更大的可能被满足。</p>
<h3 id="2-likely和unlikely"><a href="#2-likely和unlikely" class="headerlink" title="2. likely和unlikely"></a>2. likely和unlikely</h3><p>&emsp;&emsp;解开这个宏后其实是对__builtin_expect封装，likely表示更大可能成立，unlikely表示更大可能不成立。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;遇到这样的,if(likely(a == 0))理解成if(a==0)即可，unlikely也是同样的。</p>
<h3 id="3-fastpath和slowpath"><a href="#3-fastpath和slowpath" class="headerlink" title="3. fastpath和slowpath"></a>3. fastpath和slowpath</h3><p>&emsp;&emsp;跟上面也是差不多的，fastpath表示更大可能成立，slowpath表示更大可能不成立<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) ((typeof(x))__builtin_expect(_safe_cast_to_long(x), ~0l))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) ((typeof(x))__builtin_expect(_safe_cast_to_long(x), 0l))</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这两个理解起来跟likely和unlikely一样，只需要关注里面的条件式是否满足即可。</p>
<h3 id="4-os-atomic-cmpxchg"><a href="#4-os-atomic-cmpxchg" class="headerlink" title="4. os_atomic_cmpxchg"></a>4. os_atomic_cmpxchg</h3><p>&emsp;&emsp;其内部就是atomic_compare_exchange_strong_explicit函数，这个函数的作用是：第二个参数与第一个参数值比较，如果相等，第三个参数的值替换第一个参数的值。如果不相等，把第一个参数的值赋值到第二个参数上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_cmpxchg(p, e, v, m) \</span></span><br><span class="line">        (&#123; _os_atomic_basetypeof(p) _r = (e); \</span><br><span class="line">        atomic_compare_exchange_strong_explicit(_os_atomic_c11_atomic(p), \</span><br><span class="line">        &amp;_r, v, memory_order_##m, memory_order_relaxed); &#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="5-os-atomic-store2o"><a href="#5-os-atomic-store2o" class="headerlink" title="5. os_atomic_store2o"></a>5. os_atomic_store2o</h3><p>&emsp;&emsp;将第二个参数，保存到第一个参数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_store2o(p, f, v, m)  os_atomic_store(&amp;(p)-&gt;f, (v), m)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_store(p, v, m) \</span></span><br><span class="line">        atomic_store_explicit(_os_atomic_c11_atomic(p), v, memory_order_##m)</span><br></pre></td></tr></table></figure></p>
<h3 id="6-os-atomic-inc-orig"><a href="#6-os-atomic-inc-orig" class="headerlink" title="6. os_atomic_inc_orig"></a>6. os_atomic_inc_orig</h3><p>&emsp;&emsp;将1保存到第一个参数中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_inc_orig(p, m)  os_atomic_add_orig((p), 1, m)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_add_orig(p, v, m) _os_atomic_c11_op_orig((p), (v), m, add, +)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _os_atomic_c11_op_orig(p, v, m, o, op) \</span></span><br><span class="line">        atomic_fetch_#<span class="meta">#o##_explicit(_os_atomic_c11_atomic(p), v, \</span></span><br><span class="line">        memory_order_#<span class="meta">#m)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="0x03-数据结构体"><a href="#0x03-数据结构体" class="headerlink" title="0x03 数据结构体"></a>0x03 数据结构体</h1><p>&emsp;&emsp;接着，了解一些常用数据结构体。</p>
<h3 id="1-dispatch-queue-t"><a href="#1-dispatch-queue-t" class="headerlink" title="1. dispatch_queue_t"></a>1. dispatch_queue_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们看下dispatch_queue_s怎么定义的。发现其内部有个_DISPATCH_QUEUE_HEADER宏定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    _DISPATCH_QUEUE_HEADER(<span class="built_in">queue</span>);</span><br><span class="line">    DISPATCH_QUEUE_CACHELINE_PADDING; </span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;解开_DISPATCH_QUEUE_HEADER后发现又一个DISPATCH_OBJECT_HEADER宏定义，继续拆解<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_QUEUE_HEADER(x) \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">os_mpsc_queue_s</span> _<span class="title">as_oq</span>[0];</span> \</span><br><span class="line">    DISPATCH_OBJECT_HEADER(x); \</span><br><span class="line">    _OS_MPSC_QUEUE_FIELDS(dq, dq_state); \</span><br><span class="line">    <span class="keyword">uint32_t</span> dq_side_suspend_cnt; \</span><br><span class="line">    dispatch_unfair_lock_s dq_sidelock; \</span><br><span class="line">    <span class="keyword">union</span> &#123; \</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq_specific_q; \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_refs_s</span> *<span class="title">ds_refs</span>;</span> \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_source_refs_s</span> *<span class="title">ds_timer_refs</span>;</span> \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_recv_refs_s</span> *<span class="title">dm_recv_refs</span>;</span> \</span><br><span class="line">    &#125;; \</span><br><span class="line">    DISPATCH_UNION_LE(<span class="keyword">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags, \</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint16_t</span> dq_width, \</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint16_t</span> __dq_opaque \</span><br><span class="line">    ); \</span><br><span class="line">    DISPATCH_INTROSPECTION_QUEUE_HEADER</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;还有一层宏_DISPATCH_OBJECT_HEADER<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_HEADER(x) \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> _<span class="title">as_do</span>[0];</span> \</span><br><span class="line">    _DISPATCH_OBJECT_HEADER(x)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;不熟悉##的作用的同学，这里先说明下这个作用就拼接成字符串，比如x为group的话，下面就会拼接为dispatch_group这样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_OBJECT_HEADER(x) \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> \</span><br><span class="line">    OS_OBJECT_STRUCT_HEADER(dispatch_##x); \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \</span><br><span class="line">    <span class="keyword">void</span> *do_ctxt; \</span><br><span class="line">    <span class="keyword">void</span> *do_finalizer</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;来到OS_OBJECT_STRUCT_HEADER之后，我们需要注意一个成员变量，记住这个成员变量名字叫做<strong>do_vtable</strong>。再继续拆解_OS_OBJECT_HEADER发现里面起就是一个isa指针和引用计数一些信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_OBJECT_STRUCT_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER(\</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *_objc_isa, \</span><br><span class="line">    do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \</span><br><span class="line">    <span class="comment">// 注意这个成员变量，后面将任务Push到队列就是通过这个变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">x</span>##_<span class="title">vtable_s</span> *<span class="title">do_vtable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> _<span class="title">OS_OBJECT_HEADER</span>(<span class="title">isa</span>, <span class="title">ref_cnt</span>, <span class="title">xref_cnt</span>) \</span></span><br><span class="line"><span class="class">        <span class="title">isa</span>;</span> <span class="comment">/* must be pointer-sized */</span> \</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> ref_cnt; \</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> xref_cnt</span><br></pre></td></tr></table></figure></p>
<h3 id="2-dispatch-continuation-t"><a href="#2-dispatch-continuation-t" class="headerlink" title="2. dispatch_continuation_t"></a>2. dispatch_continuation_t</h3><p>&emsp;&emsp;说到这个结构体，如果没看过源码的话，肯定对这个结构体很陌生，因为对外的api里面没有跟continuation有关的。所以这里先说下这个结构体就是用来封装block对象的，保存block的上下文环境和block执行函数等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> _<span class="title">as_do</span>[0];</span></span><br><span class="line">    DISPATCH_CONTINUATION_HEADER(continuation);</span><br><span class="line">&#125; *<span class="keyword">dispatch_continuation_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;看下里面的宏DISPATCH_CONTINUATION_HEADER<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_CONTINUATION_HEADER(x) \</span></span><br><span class="line">    <span class="keyword">union</span> &#123; \</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *do_vtable; \</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_flags; \</span><br><span class="line">    &#125;; \</span><br><span class="line">    <span class="keyword">union</span> &#123; \</span><br><span class="line">        <span class="keyword">pthread_priority_t</span> dc_priority; \</span><br><span class="line">        <span class="keyword">int</span> dc_cache_cnt; \</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_pad; \</span><br><span class="line">    &#125;; \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">voucher_s</span> *<span class="title">dc_voucher</span>;</span> \</span><br><span class="line">    <span class="keyword">dispatch_function_t</span> dc_func; \</span><br><span class="line">    <span class="keyword">void</span> *dc_ctxt; \</span><br><span class="line">    <span class="keyword">void</span> *dc_data; \</span><br><span class="line">    <span class="keyword">void</span> *dc_other</span><br></pre></td></tr></table></figure></p>
<h3 id="3-dispatch-object-t"><a href="#3-dispatch-object-t" class="headerlink" title="3. dispatch_object_t"></a>3. dispatch_object_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *_<span class="title">dc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_attr_s</span> *_<span class="title">dsa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_operation_s</span> *_<span class="title">doperation</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_disk_s</span> *_<span class="title">ddisk</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> DISPATCH_TRANSPARENT_UNION;</span><br></pre></td></tr></table></figure>
<h3 id="4-dispatch-function-t"><a href="#4-dispatch-function-t" class="headerlink" title="4. dispatch_function_t"></a>4. dispatch_function_t</h3><p>&emsp;&emsp;dispatch_function_t 只是一个函数指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">dispatch_function_t</span>)</span><span class="params">(<span class="keyword">void</span> *_Nullable)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，一些常用的宏和数据结构体介绍完毕，接下来，我们真正的要一起阅读GCD相关的源码了。</p>
<h1 id="0x03-创建队列"><a href="#0x03-创建队列" class="headerlink" title="0x03 创建队列"></a>0x03 创建队列</h1><p>&emsp;&emsp;首先我们先从创建队列讲起。我们已经很熟悉，创建队列的方法是调用dispatch_queue_create函数。</p>
<ul>
<li>其内部又调用了_dispatch_queue_create_with_target函数  </li>
<li>DISPATCH_TARGET_QUEUE_DEFAULT这个宏其实就是null<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span><br><span class="line">&#123;   <span class="comment">// attr一般我们都是传DISPATCH_QUEUE_SERIAL、DISPATCH_QUEUE_CONCURRENT或者nil</span></span><br><span class="line">    <span class="comment">// 而DISPATCH_QUEUE_SERIAL其实就是null</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_create_with_target(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;_dispatch_queue_create_with_target函数，这里会创建一个root队列,并将自己新建的队列绑定到所对应的root队列上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> _dispatch_queue_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;   <span class="comment">// 根据上文代码注释里提到的，作者认为调用者传入DISPATCH_QUEUE_SERIAL和nil的几率要大于传DISPATCH_QUEUE_CONCURRENT。所以这里设置个默认值。</span></span><br><span class="line">    <span class="comment">// 这里怎么理解呢？只要看做if(!dqa)即可</span></span><br><span class="line">    <span class="keyword">if</span> (!slowpath(dqa)) &#123;</span><br><span class="line">        <span class="comment">// _dispatch_get_default_queue_attr里面会将dqa的dqa_autorelease_frequency指定为DISPATCH_AUTORELEASE_FREQUENCY_INHERIT的，inactive也指定为false。这里就不展开了，只需要知道赋了哪些值。因为后面会用到。</span></span><br><span class="line">        dqa = _dispatch_get_default_queue_attr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;do_vtable != DISPATCH_VTABLE(queue_attr)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出优先级</span></span><br><span class="line">    <span class="keyword">dispatch_qos_t</span> qos = _dispatch_priority_qos(dqa-&gt;dqa_qos_and_relpri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overcommit单纯从英文理解表示过量使用的意思，那这里这个overcommit就是一个标识符，表示是不是就算负荷很高了，但还是得给我新开一个线程出来给我执行任务。</span></span><br><span class="line">    <span class="keyword">_dispatch_queue_attr_overcommit_t</span> overcommit = dqa-&gt;dqa_overcommit;</span><br><span class="line">    <span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify both overcommit and "</span></span><br><span class="line">                    <span class="string">"a non-global target queue"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果overcommit没有被指定</span></span><br><span class="line">    <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">         <span class="comment">// 所以对于overcommit，如果是串行的话默认是开启的，而并行是关闭的</span></span><br><span class="line">        overcommit = dqa-&gt;dqa_concurrent ?</span><br><span class="line">                _dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">                _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前说过初始化队列默认传了DISPATCH_TARGET_QUEUE_DEFAULT，也就是null，所以进入if语句。</span></span><br><span class="line">    <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">        <span class="comment">// 获取一个管理自己队列的root队列。</span></span><br><span class="line">        tq = _dispatch_get_root_queue(</span><br><span class="line">                qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">                overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!tq)) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// legacy默认是true的</span></span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        <span class="comment">// 之前说过，默认是会给dqa_autorelease_frequency指定为DISPATCH_AUTORELEASE_FREQUENCY_INHERIT，所以这个判断式是成立的</span></span><br><span class="line">        <span class="keyword">if</span> (dqa-&gt;dqa_inactive || dqa-&gt;dqa_autorelease_frequency) &#123;</span><br><span class="line">            legacy = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vtable变量很重要，之后会被赋值到之前说的dispatch_queue_t结构体里的do_vtable变量上</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">    <span class="keyword">dispatch_queue_flags_t</span> dqf = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// legacy变为false了</span></span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        vtable = DISPATCH_VTABLE(<span class="built_in">queue</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;dqa_concurrent) &#123;</span><br><span class="line">        <span class="comment">// 如果创建队列的时候传了DISPATCH_QUEUE_CONCURRENT，就是走这里</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果创建线程没有指定为并行队列，无论你传DISPATCH_QUEUE_SERIAL还是nil，都会创建一个串行队列。</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (label) &#123;</span><br><span class="line">        <span class="comment">// 判断传进来的字符串是否可变的，如果可变的copy成一份不可变的</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">        <span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">            dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">            label = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _dispatch_object_alloc里面就将vtable赋值给do_vtable变量上了。</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">    <span class="comment">// 第三个参数根据是否并行队列，如果不是则最多开一个线程，如果是则最多开0x1000 - 2个线程，这个数量很惊人了已经,换成十进制就是（4096 - 2）个。</span></span><br><span class="line">    <span class="comment">// dqa_inactive之前说串行是false的</span></span><br><span class="line">    <span class="comment">// DISPATCH_QUEUE_ROLE_INNER 也是0，所以这里串行队列的话dqa-&gt;dqa_state是0</span></span><br><span class="line">    _dispatch_queue_init(dq, dqf, dqa-&gt;dqa_concurrent ?</span><br><span class="line">            DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">            (dqa-&gt;dqa_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    dq-&gt;dq_label = label;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    dq-&gt;dq_priority = dqa-&gt;dqa_qos_and_relpri;</span><br><span class="line">    <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">        dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _dispatch_retain(tq);</span><br><span class="line">    <span class="keyword">if</span> (qos == QOS_CLASS_UNSPECIFIED) &#123;</span><br><span class="line">        _dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dqa-&gt;dqa_inactive) &#123;</span><br><span class="line">        _dispatch_queue_inherit_wlh_from_target(dq, tq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义的queue的目标队列是root队列</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    _dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个函数里面还是有几个重要的地方拆出来看下，首先是创建一个root队列_dispatch_get_root_queue函数。取root队列，一般是从一个装有12个root队列数组里面取。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_t</span></span><br><span class="line">_dispatch_get_root_queue(<span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(qos == DISPATCH_QOS_UNSPECIFIED || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(qos, <span class="string">"Corrupted priority"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span> * (qos - <span class="number">1</span>) + overcommit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;看下这个_dispatch_root_queues数组。我们可以看到，每一个优先级都有对应的root队列，每一个优先级又分为是不是可以过载的队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_root_queues</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_IDX(n, flags) \</span></span><br><span class="line">    ((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \</span><br><span class="line">        DISPATCH_ROOT_QUEUE_IDX_##n##_QOS_OVERCOMMIT : \</span><br><span class="line">        DISPATCH_ROOT_QUEUE_IDX_##n##_QOS)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \</span></span><br><span class="line">    [_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_root), \</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \</span><br><span class="line">        .do_ctxt = &amp;_dispatch_root_queue_contexts[ \</span><br><span class="line">                _DISPATCH_ROOT_QUEUE_IDX(n, flags)], \</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_##n, <span class="number">0</span>) | flags | \</span><br><span class="line">                DISPATCH_PRIORITY_FLAG_ROOTQUEUE | \</span><br><span class="line">                ((flags &amp; DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE) ? <span class="number">0</span> : \</span><br><span class="line">                DISPATCH_QOS_##n &lt;&lt; DISPATCH_PRIORITY_OVERRIDE_SHIFT), \</span><br><span class="line">        __VA_ARGS__ \</span><br><span class="line">    &#125;</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.maintenance-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">4</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.maintenance-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">5</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.background-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">6</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.background-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">7</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.utility-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">8</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.utility-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">9</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.default-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">10</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span><br><span class="line">            DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.default-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">11</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.user-initiated-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">12</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.user-initiated-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">13</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.user-interactive-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">14</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.user-interactive-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">15</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其中DISPATCH_GLOBAL_OBJECT_HEADER(queue_root)，解析到最后是OS<em>dispatch</em>##name##_class这样的这样的，对应的实例对象是如下代码，指定了root队列各个操作对应的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_root, <span class="built_in">queue</span>,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_GLOBAL_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">"global-queue"</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose,</span><br><span class="line">    .do_push = _dispatch_root_queue_push,</span><br><span class="line">    .do_invoke = <span class="literal">NULL</span>,</span><br><span class="line">    .do_wakeup = _dispatch_root_queue_wakeup,</span><br><span class="line">    .do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其次看下DISPATCH_VTABLE这个宏，这个宏很重要。最后解封也是&amp;OS<em>dispatch</em>##name##_class这样的。其实就是取dispatch_object_t对象。<br>&emsp;&emsp;如下代码，这里再举个VTABLE的串行对象，里面有各个状态该执行的函数：销毁函、挂起、恢复、push等函数都是在这里指定的。所以这里的do_push我们需要特别留意，后面push block任务到队列，就是通过调用do_push。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_serial, <span class="built_in">queue</span>,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">    .do_kind = <span class="string">"serial-queue"</span>,</span><br><span class="line">    .do_dispose = _dispatch_queue_dispose,</span><br><span class="line">    .do_suspend = _dispatch_queue_suspend,</span><br><span class="line">    .do_resume = _dispatch_queue_resume,</span><br><span class="line">    .do_finalize_activation = _dispatch_queue_finalize_activation,</span><br><span class="line">    .do_push = _dispatch_queue_push,</span><br><span class="line">    .do_invoke = _dispatch_queue_invoke,</span><br><span class="line">    .do_wakeup = _dispatch_queue_wakeup,</span><br><span class="line">    .do_debug = dispatch_queue_debug,</span><br><span class="line">    .do_set_targetq = _dispatch_queue_set_target_queue,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;继续看下_dispatch_object_alloc和_dispatch_queue_init两个函数，首先看下_dispatch_object_alloc函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * _dispatch_object_alloc(<span class="keyword">const</span> <span class="keyword">void</span> *vtable, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// OS_OBJECT_HAVE_OBJC1为1的满足式是：</span></span><br><span class="line"><span class="comment">// #if TARGET_OS_MAC &amp;&amp; !TARGET_OS_SIMULATOR &amp;&amp; defined(__i386__)</span></span><br><span class="line"><span class="comment">// 所以对于iOS并不满足</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_OBJECT_HAVE_OBJC1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_vtable_s</span> *_<span class="title">vtable</span> = <span class="title">vtable</span>;</span></span><br><span class="line">    <span class="keyword">dispatch_object_t</span> dou;</span><br><span class="line">    dou._os_obj = _os_object_alloc_realized(_vtable-&gt;_os_obj_objc_isa, size);</span><br><span class="line">    dou._do-&gt;do_vtable = vtable;</span><br><span class="line">    <span class="keyword">return</span> dou._do;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> _os_object_alloc_realized(vtable, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">_os_object_t</span> _os_object_alloc_realized(<span class="keyword">const</span> <span class="keyword">void</span> *cls, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">_os_object_t</span> obj;</span><br><span class="line">    dispatch_assert(size &gt;= <span class="keyword">sizeof</span>(struct _os_object_s));</span><br><span class="line">    <span class="keyword">while</span> (!fastpath(obj = <span class="built_in">calloc</span>(<span class="number">1u</span>, size))) &#123;</span><br><span class="line">        _dispatch_temporary_resource_shortage();</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;os_obj_isa = cls;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_temporary_resource_shortage(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);  <span class="comment">// prevent tailcall</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再看下_dispatch_queue_init函数，这里也就是做些初始化工作了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_init(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">        <span class="keyword">uint16_t</span> width, <span class="keyword">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br><span class="line"></span><br><span class="line">    dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">            DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">        dq_state |= DISPATCH_QUEUE_INACTIVE + DISPATCH_QUEUE_NEEDS_ACTIVATION;</span><br><span class="line">        dq_state |= DLOCK_OWNER_MASK;</span><br><span class="line">        dq-&gt;do_ref_cnt += <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dq_state |= (initial_state_bits &amp; DISPATCH_QUEUE_ROLE_MASK);</span><br><span class="line">    <span class="comment">// 指向DISPATCH_OBJECT_LISTLESS是优化编译器的作用。只是为了生成更好的指令让CPU更好的编码</span></span><br><span class="line">    dq-&gt;do_next = (struct dispatch_queue_s *)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dqf |= DQF_WIDTH(width);</span><br><span class="line">    <span class="comment">// dqf 保存进 dq-&gt;dq_atomic_flags</span></span><br><span class="line">    os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">    dq-&gt;dq_state = dq_state;</span><br><span class="line">    dq-&gt;dq_serialnum =</span><br><span class="line">            os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后是_dispatch_introspection_queue_create函数，一个内省函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> _dispatch_introspection_queue_create(<span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    TAILQ_INIT(&amp;dq-&gt;diq_order_top_head);</span><br><span class="line">    TAILQ_INIT(&amp;dq-&gt;diq_order_bottom_head);</span><br><span class="line">    _dispatch_unfair_lock_lock(&amp;_dispatch_introspection.queues_lock);</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;_dispatch_introspection.queues, dq, diq_list);</span><br><span class="line">    _dispatch_unfair_lock_unlock(&amp;_dispatch_introspection.queues_lock);</span><br><span class="line"></span><br><span class="line">    DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(queue_create, dq);</span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_INTROSPECTION_HOOK_ENABLED(queue_create)) &#123;</span><br><span class="line">        _dispatch_introspection_queue_create_hook(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，一个队列的创建过程我们大致了解了。大致可以分为这么几点</p>
<ul>
<li>设置队列优先级</li>
<li>默认创建的是一个串行队列</li>
<li>设置队列挂载的根队列。优先级不同根队列也不同</li>
<li>实例化vtable对象，这个对象给不同队列指定了push、wakeup等函数。</li>
</ul>
<h1 id="0x04-dispatch-sync"><a href="#0x04-dispatch-sync" class="headerlink" title="0x04 dispatch_sync"></a>0x04 dispatch_sync</h1><p>&emsp;&emsp;dispatch_sync直接调用的是dispatch_sync_f<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 很大可能不会走if分支，看做if(_dispatch_block_has_private_data(work))</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_block_with_private_data(dq, work, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_sync_f(dq, work, _dispatch_Block_invoke(work));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 串行队列会走到这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局获取的并行队列或者绑定的是非调度线程的队列会走进这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dq))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_introspection_sync_begin(dq);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义并行队列会来到这个函数</span></span><br><span class="line">    _dispatch_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;先说第一种情况，串行队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列绑定的是非调度线程就会走这里</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dq, tid))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_introspection_sync_begin(dq);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般会走到这里</span></span><br><span class="line">    _dispatch_queue_barrier_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_queue_barrier_sync_invoke_and_complete(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先会执行这个函数</span></span><br><span class="line">    _dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">    <span class="comment">// 如果后面还有别的任务</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dq-&gt;dq_items_tail || dq-&gt;dq_width &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 内部其实就是唤醒队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_barrier_complete(dq, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> fail_unlock_mask = DISPATCH_QUEUE_SUSPEND_BITS_MASK |</span><br><span class="line">            DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_DIRTY |</span><br><span class="line">            DISPATCH_QUEUE_RECEIVED_OVERRIDE | DISPATCH_QUEUE_SYNC_TRANSFER |</span><br><span class="line">            DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;</span><br><span class="line">    <span class="keyword">uint64_t</span> old_state, new_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子锁。检查dq-&gt;dq_state与old_state是否相等，如果相等把new_state赋值给dq-&gt;dq_state，如果不相等，把dq_state赋值给old_state。</span></span><br><span class="line">    <span class="comment">// 串行队列走到这里，dq-&gt;dq_state与old_state是相等的，会把new_state也就是闭包里的赋值的值给dq-&gt;dq_state</span></span><br><span class="line">    os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">        new_state  = old_state - DISPATCH_QUEUE_SERIAL_DRAIN_OWNED;</span><br><span class="line">        new_state &amp;= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;</span><br><span class="line">        new_state &amp;= ~DISPATCH_QUEUE_MAX_QOS_MASK;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(old_state &amp; fail_unlock_mask)) &#123;</span><br><span class="line">            os_atomic_rmw_loop_give_up(&#123;</span><br><span class="line">                <span class="keyword">return</span> _dispatch_queue_barrier_complete(dq, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (_dq_state_is_base_wlh(old_state)) &#123;</span><br><span class="line">        _dispatch_event_loop_assert_not_owned((<span class="keyword">dispatch_wlh_t</span>)dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保护现场 -&gt; 调用函数 -&gt; 恢复现场</span></span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后另一种情况，自定义并行队列会走_dispatch_sync_invoke_and_complete函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_sync_invoke_and_complete(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">    <span class="comment">// 将自定义队列加入到root队列里去</span></span><br><span class="line">    <span class="comment">// dispatch_async也会调用此方法，之前我们初始化的时候会绑定一个root队列，这里就将我们新建的队列交给root队列进行管理</span></span><br><span class="line">    _dispatch_queue_non_barrier_complete(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x05-dispatch-async"><a href="#0x05-dispatch-async" class="headerlink" title="0x05 dispatch_async"></a>0x05 dispatch_async</h1><p>&emsp;&emsp;内部就是两个函数_dispatch_continuation_init和_dispatch_continuation_async<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="comment">// 设置标识位</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> dc_flags = DISPATCH_OBJ_CONSUME_BIT;</span><br><span class="line"></span><br><span class="line">    _dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">    _dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;_dispatch_continuation_init函数只是一个初始化，主要就是保存Block上下文，指定block的执行函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_init(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_block_t</span> work,</span><br><span class="line">        <span class="keyword">pthread_priority_t</span> pp, <span class="keyword">dispatch_block_flags_t</span> flags, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    dc-&gt;dc_flags = dc_flags | DISPATCH_OBJ_BLOCK_BIT;</span><br><span class="line">    <span class="comment">// block对象赋值到dc_ctxt</span></span><br><span class="line">    dc-&gt;dc_ctxt = _dispatch_Block_copy(work);</span><br><span class="line">    <span class="comment">// 设置默认任务优先级</span></span><br><span class="line">    _dispatch_continuation_priority_set(dc, pp, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大多数情况不会走这个分支</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_init_slow(dc, dqu, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个标识位多眼熟，就是前面入口赋值的，没的跑了，指定执行函数就是_dispatch_call_block_and_release了</span></span><br><span class="line">    <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">        dc-&gt;dc_func = _dispatch_call_block_and_release;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc-&gt;dc_func = _dispatch_Block_invoke(work);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_continuation_voucher_set(dc, dqu, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;_dispatch_call_block_and_release这个函数就是直接执行block了，所以dc-&gt;dc_func被调用的话就block会被直接执行了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_call_block_and_release(<span class="keyword">void</span> *block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (^b)(<span class="keyword">void</span>) = block;</span><br><span class="line">    b();</span><br><span class="line">    Block_release(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的初始化过程就是这样，接着看下_dispatch_continuation_async函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_continuation_async(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 看看是不是barrier类型的block</span></span><br><span class="line">    _dispatch_continuation_async2(dq, dc,</span><br><span class="line">            dc-&gt;dc_flags &amp; DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果是用barrier插进来的任务或者是串行队列，直接将任务加入到队列</span></span><br><span class="line">    <span class="comment">// #define DISPATCH_QUEUE_USES_REDIRECTION(width) \</span></span><br><span class="line">    <span class="comment">//    (&#123; uint16_t _width = (width); \</span></span><br><span class="line">    <span class="comment">//    _width &gt; 1 &amp;&amp; _width &lt; DISPATCH_QUEUE_WIDTH_POOL; &#125;) </span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以先看下如果是barrier任务，直接调用_dispatch_continuation_push函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_continuation_push(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    dx_push(dq, dc, _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _dispatch_continuation_async2函数里面调用_dispatch_async_f2函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_async_f2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果还有任务，slowpath表示很大可能队尾是没有任务的。</span></span><br><span class="line">    <span class="comment">// 实际开发中也的确如此，一般情况下我们不会dispatch_async之后又马上跟着一个dispatch_async</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(dq-&gt;dq_items_tail)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!_dispatch_queue_try_acquire_async(dq))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般会直接来到这里，_dispatch_continuation_override_qos函数里面主要做的是判断dq有没有设置的优先级，如果没有就用block对象的优先级，如果有就用自己的</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_async_f_redirect(dq, dc,</span><br><span class="line">            _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_async_f_redirect(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里会走进if的语句，因为_dispatch_object_is_redirection内部的dx_type(dou._do) == type条件为否</span></span><br><span class="line">    <span class="keyword">if</span> (!slowpath(_dispatch_object_is_redirection(dou))) &#123;</span><br><span class="line">        dou._dc = _dispatch_async_redirect_wrap(dq, dou);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dq换成所绑定的root队列</span></span><br><span class="line">    dq = dq-&gt;do_targetq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本不会走里面的循环，主要做的就是找到根root队列</span></span><br><span class="line">    <span class="keyword">while</span> (slowpath(DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fastpath(_dispatch_queue_try_acquire_async(dq))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dou._dc-&gt;dc_ctxt) &#123;</span><br><span class="line">            dou._dc-&gt;dc_ctxt = (<span class="keyword">void</span> *)</span><br><span class="line">                    (<span class="keyword">uintptr_t</span>)_dispatch_queue_autorelease_frequency(dq);</span><br><span class="line">        &#125;</span><br><span class="line">        dq = dq-&gt;do_targetq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把装有block信息的结构体装进所在队列对应的root_queue里面</span></span><br><span class="line">    dx_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dx_push是个宏定义，这里做的就是将任务push到任务队列，我们看到这里，就知道dx_push就是调用对象的do_push。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_push(x, y, z) dx_vtable(x)-&gt;do_push(x, y, z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_vtable(x) (&amp;(x)-&gt;do_vtable-&gt;_os_obj_vtable)</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;_dispatch_async_f_redirect函数里先看这句dou._dc = _dispatch_async_redirect_wrap(dq, dou);<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_continuation_t</span> _dispatch_async_redirect_wrap(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> dou)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line"></span><br><span class="line">    dou._do-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 所以dispatch_async推进的任务的do_vtable成员变量是有值的</span></span><br><span class="line">    dc-&gt;do_vtable = DC_VTABLE(ASYNC_REDIRECT);</span><br><span class="line">    dc-&gt;dc_func = <span class="literal">NULL</span>;</span><br><span class="line">    dc-&gt;dc_ctxt = (<span class="keyword">void</span> *)(<span class="keyword">uintptr_t</span>)_dispatch_queue_autorelease_frequency(dq);</span><br><span class="line">    <span class="comment">// 所属队列被装进dou._dc-&gt;dc_data里面了</span></span><br><span class="line">    dc-&gt;dc_data = dq;</span><br><span class="line">    dc-&gt;dc_other = dou._do;</span><br><span class="line">    dc-&gt;dc_voucher = DISPATCH_NO_VOUCHER;</span><br><span class="line">    dc-&gt;dc_priority = DISPATCH_NO_PRIORITY;</span><br><span class="line">    _dispatch_retain(dq); <span class="comment">// released in _dispatch_async_redirect_invoke</span></span><br><span class="line">    <span class="keyword">return</span> dc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dc-&gt;do_vtable = DC_VTABLE(ASYNC_REDIRECT); 就是下面指定redirect的invoke函数是_dispatch_async_redirect_invoke，后面任务被执行就是通过这个函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_vtable_s</span> _<span class="title">dispatch_continuation_vtables</span>[] = &#123;</span></span><br><span class="line">    DC_VTABLE_ENTRY(ASYNC_REDIRECT,</span><br><span class="line">        .do_kind = <span class="string">"dc-redirect"</span>,</span><br><span class="line">        .do_invoke = _dispatch_async_redirect_invoke),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_MACH</span></span><br><span class="line">    DC_VTABLE_ENTRY(MACH_SEND_BARRRIER_DRAIN,</span><br><span class="line">        .do_kind = <span class="string">"dc-mach-send-drain"</span>,</span><br><span class="line">        .do_invoke = _dispatch_mach_send_barrier_drain_invoke),</span><br><span class="line">    DC_VTABLE_ENTRY(MACH_SEND_BARRIER,</span><br><span class="line">        .do_kind = <span class="string">"dc-mach-send-barrier"</span>,</span><br><span class="line">        .do_invoke = _dispatch_mach_barrier_invoke),</span><br><span class="line">    DC_VTABLE_ENTRY(MACH_RECV_BARRIER,</span><br><span class="line">        .do_kind = <span class="string">"dc-mach-recv-barrier"</span>,</span><br><span class="line">        .do_invoke = _dispatch_mach_barrier_invoke),</span><br><span class="line">    DC_VTABLE_ENTRY(MACH_ASYNC_REPLY,</span><br><span class="line">        .do_kind = <span class="string">"dc-mach-async-reply"</span>,</span><br><span class="line">        .do_invoke = _dispatch_mach_msg_async_reply_invoke),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    DC_VTABLE_ENTRY(OVERRIDE_STEALING,</span><br><span class="line">        .do_kind = <span class="string">"dc-override-stealing"</span>,</span><br><span class="line">        .do_invoke = _dispatch_queue_override_invoke),</span><br><span class="line">    <span class="comment">// 留意这个，后面也会被用到</span></span><br><span class="line">    DC_VTABLE_ENTRY(OVERRIDE_OWNING,</span><br><span class="line">        .do_kind = <span class="string">"dc-override-owning"</span>,</span><br><span class="line">        .do_invoke = _dispatch_queue_override_invoke),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再看dx_push(dq, dou, qos);这句，其实就是调用_dispatch_root_queue_push函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_root_queue_push(<span class="keyword">dispatch_queue_t</span> rq, <span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一般情况下，无论自定义还是非自定义都会走进这个条件式(比如：dispatch_get_global_queue)</span></span><br><span class="line">    <span class="comment">// 里面主要对比的是qos与root队列的qos是否一致。基本上都不一致的，如果不一致走进这个if语句</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_root_queue_push_needs_override(rq, qos)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_root_queue_push_override(rq, dou, qos);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dou, dou, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_push_override(<span class="keyword">dispatch_queue_t</span> orig_rq,</span><br><span class="line">        <span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> overcommit = orig_rq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> rq = _dispatch_get_root_queue(qos, overcommit);</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc;</span><br><span class="line">    <span class="comment">// 这个_dispatch_object_is_redirection函数其实就是return _dispatch_object_has_type(dou,DISPATCH_CONTINUATION_TYPE(ASYNC_REDIRECT));</span></span><br><span class="line">    <span class="comment">// 所以自定义队列会走这个if语句，如果是dispatch_get_global_queue不会走if语句</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_is_redirection(dc)) &#123;</span><br><span class="line">        dc-&gt;dc_func = (<span class="keyword">void</span> *)orig_rq;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dispatch_get_global_queue来到这里</span></span><br><span class="line">        dc = _dispatch_continuation_alloc();</span><br><span class="line">        <span class="comment">// 相当于是下面的，也就是指定了执行函数为_dispatch_queue_override_invoke，所以有别于自定义队列的invoke函数。</span></span><br><span class="line">        <span class="comment">// DC_VTABLE_ENTRY(OVERRIDE_OWNING,</span></span><br><span class="line">        <span class="comment">// .do_kind = "dc-override-owning",</span></span><br><span class="line">        <span class="comment">// .do_invoke = _dispatch_queue_override_invoke),</span></span><br><span class="line">        dc-&gt;do_vtable = DC_VTABLE(OVERRIDE_OWNING);</span><br><span class="line">        _dispatch_trace_continuation_push(orig_rq, dou);</span><br><span class="line">        dc-&gt;dc_ctxt = dc;</span><br><span class="line">        dc-&gt;dc_other = orig_rq;</span><br><span class="line">        dc-&gt;dc_data = dou._do;</span><br><span class="line">        dc-&gt;dc_priority = DISPATCH_NO_PRIORITY;</span><br><span class="line">        dc-&gt;dc_voucher = DISPATCH_NO_VOUCHER;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dc, dc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_root_queue_push_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _head,</span><br><span class="line">        <span class="keyword">dispatch_object_t</span> _tail, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">head</span> = _<span class="title">head</span>._<span class="title">do</span>, *<span class="title">tail</span> = _<span class="title">tail</span>._<span class="title">do</span>;</span></span><br><span class="line">    <span class="comment">// 把任务装进队列，大多数不走进if语句。但是第一个任务进来之前还是满足这个条件式的，会进入这个条件语句去激活队列来执行里面的任务，后面再加入的任务因为队列被激活了，所以也就不太需要再进入这个队列了，所以相对来说激活队列只要一次，所以作者认为大多数情况下不需要走进这个条件语句</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_queue_push_update_tail_list(dq, head, tail))) &#123;</span><br><span class="line">        <span class="comment">// 保存队列头</span></span><br><span class="line">        _dispatch_queue_push_update_head(dq, head);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_global_queue_poke(dq, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，我们可以看到，我们装入到自定义的任务都被扔到其挂靠的root队列里去了，所以我们我们自己创建的队列只是一个代理人身份，真正的管理人是其对应的root队列，但同时这个队列也是被管理的。<br>&emsp;&emsp;继续看_dispatch_global_queue_poke函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_global_queue_poke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_global_queue_poke_slow(dq, n, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;继续看_dispatch_global_queue_poke函数调用了_dispatch_global_queue_poke_slow函数，这里也很关键了，里面执行_pthread_workqueue_addthreads函数，把任务交给内核分发处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_global_queue_poke_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_root_queue_context_t</span> qc = dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">int</span> remaining = n;</span><br><span class="line">    <span class="keyword">int</span> r = ENOSYS;</span><br><span class="line"></span><br><span class="line">    _dispatch_root_queues_init();</span><br><span class="line">    _dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">    <span class="keyword">if</span> (qc-&gt;dgq_kworkqueue != (<span class="keyword">void</span>*)(~<span class="number">0u</span>l))</span><br><span class="line">    &#123;</span><br><span class="line">        r = _pthread_workqueue_addthreads(remaining,</span><br><span class="line">                _dispatch_priority_to_pp(dq-&gt;dq_priority));</span><br><span class="line">        (<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_pthread_workqueue_addthreads(<span class="keyword">int</span> numthreads, <span class="keyword">pthread_priority_t</span> priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__libdispatch_workerfunction == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EPERM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((__pthread_supported_features &amp; PTHREAD_FEATURE_FINEPRIO) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ENOTSUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = __workq_kernreturn(WQOPS_QUEUE_REQTHREADS, <span class="literal">NULL</span>, numthreads, (<span class="keyword">int</span>)priority);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        res = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么，加入到根队列的任务是怎么被运行起来的？在此之前，我们先模拟一下在GCD内部把程序搞挂掉，这样我们就可以追溯下调用栈关系。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    <span class="number">0</span>   CoreFoundation                      <span class="number">0x00000001093fe12b</span> __exceptionPreprocess + <span class="number">171</span></span><br><span class="line">    <span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x0000000108a92f41</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line">    <span class="number">2</span>   CoreFoundation                      <span class="number">0x000000010943e0cc</span> _CFThrowFormattedException + <span class="number">194</span></span><br><span class="line">    <span class="number">3</span>   CoreFoundation                      <span class="number">0x000000010930c23d</span> -[__NSPlaceholderArray initWithObjects:count:] + <span class="number">237</span></span><br><span class="line">    <span class="number">4</span>   CoreFoundation                      <span class="number">0x0000000109312e34</span> +[<span class="built_in">NSArray</span> arrayWithObjects:count:] + <span class="number">52</span></span><br><span class="line">    <span class="number">5</span>   HotPatch                            <span class="number">0x000000010769df77</span> __29-[ViewController viewDidLoad]_block_invoke + <span class="number">87</span></span><br><span class="line">    <span class="number">6</span>   libdispatch.dylib                   <span class="number">0x000000010c0a62f7</span> _dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line">    <span class="number">7</span>   libdispatch.dylib                   <span class="number">0x000000010c0a733d</span> _dispatch_client_callout + <span class="number">8</span></span><br><span class="line">    <span class="number">8</span>   libdispatch.dylib                   <span class="number">0x000000010c0ad754</span> _dispatch_continuation_pop + <span class="number">967</span></span><br><span class="line">    <span class="number">9</span>   libdispatch.dylib                   <span class="number">0x000000010c0abb85</span> _dispatch_async_redirect_invoke + <span class="number">780</span></span><br><span class="line">    <span class="number">10</span>  libdispatch.dylib                   <span class="number">0x000000010c0b3102</span> _dispatch_root_queue_drain + <span class="number">772</span></span><br><span class="line">    <span class="number">11</span>  libdispatch.dylib                   <span class="number">0x000000010c0b2da0</span> _dispatch_worker_thread3 + <span class="number">132</span></span><br><span class="line">    <span class="number">12</span>  libsystem_pthread.dylib             <span class="number">0x000000010c5f95a2</span> _pthread_wqthread + <span class="number">1299</span></span><br><span class="line">    <span class="number">13</span>  libsystem_pthread.dylib             <span class="number">0x000000010c5f907d</span> </span><br><span class="line">    start_wqthread + <span class="number">13</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;很明显，我们已经看到加入到队列的任务的调用关系是：<br>start_wqthread -&gt; _pthread_wqthread -&gt; _dispatch_worker_thread3 -&gt; _dispatch_root_queue_drain -&gt; _dispatch_async_redirect_invoke -&gt; _dispatch_continuation_pop -&gt; _dispatch_client_callout -&gt; _dispatch_call_block_and_release<br>&emsp;&emsp;只看调用关系也不知道里面做了什么，所以还是上代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据优先级取出相应的root队列，再调用_dispatch_worker_thread4函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_worker_thread3(<span class="keyword">pthread_priority_t</span> pp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> overcommit = pp &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq;</span><br><span class="line">    pp &amp;= _PTHREAD_PRIORITY_OVERCOMMIT_FLAG | ~_PTHREAD_PRIORITY_FLAGS_MASK;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_priority_key, (<span class="keyword">void</span> *)(<span class="keyword">uintptr_t</span>)pp);</span><br><span class="line">    dq = _dispatch_get_root_queue(_dispatch_qos_from_pp(pp), overcommit);</span><br><span class="line">    <span class="keyword">return</span> _dispatch_worker_thread4(dq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始调用_dispatch_root_queue_drain函数，取出任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_worker_thread4(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = context;</span><br><span class="line">    <span class="keyword">dispatch_root_queue_context_t</span> qc = dq-&gt;do_ctxt;</span><br><span class="line"></span><br><span class="line">    _dispatch_introspection_thread_add();</span><br><span class="line">    <span class="keyword">int</span> pending = os_atomic_dec2o(qc, dgq_pending, relaxed);</span><br><span class="line">    dispatch_assert(pending &gt;= <span class="number">0</span>);</span><br><span class="line">    _dispatch_root_queue_drain(dq, _dispatch_get_priority());</span><br><span class="line">    _dispatch_voucher_debug(<span class="string">"root queue clear"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    _dispatch_reset_voucher(<span class="literal">NULL</span>, DISPATCH_THREAD_PARK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环取出任务</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">pthread_priority_t</span> pp)</span><br><span class="line">&#123;</span><br><span class="line">        _dispatch_queue_set_current(dq);</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> pri = dq-&gt;dq_priority;</span><br><span class="line">    <span class="keyword">if</span> (!pri) pri = _dispatch_priority_from_pp(pp);</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dbp = _dispatch_set_basepri(pri);</span><br><span class="line">    _dispatch_adopt_wlh_anon();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> reset = <span class="literal">false</span>;</span><br><span class="line">    dispatch_invoke_context_s dic = &#123; &#125;;</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags = DISPATCH_INVOKE_WORKER_DRAIN |</span><br><span class="line">            DISPATCH_INVOKE_REDIRECTING_DRAIN;</span><br><span class="line">    _dispatch_queue_drain_init_narrowing_check_deadline(&amp;dic, pri);</span><br><span class="line">    _dispatch_perfmon_start();</span><br><span class="line">    <span class="keyword">while</span> ((item = fastpath(_dispatch_root_queue_drain_one(dq)))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reset) _dispatch_wqthread_override_reset();</span><br><span class="line">        _dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line">        reset = _dispatch_reset_basepri_override();</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(&amp;dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overcommit or not. worker thread</span></span><br><span class="line">    <span class="keyword">if</span> (pri &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG) &#123;</span><br><span class="line">        _dispatch_perfmon_end(perfmon_thread_worker_oc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_perfmon_end(perfmon_thread_worker_non_oc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_reset_wlh();</span><br><span class="line">    _dispatch_reset_basepri(old_dbp);</span><br><span class="line">    _dispatch_reset_basepri_override();</span><br><span class="line">    _dispatch_queue_set_current(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的作用就是调度出任务的执行函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">    _dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前说过dispatch_async是有do_vtable成员变量的，所以会走进这个if分支，又invoke方法指定为_dispatch_async_redirect_invoke，所以执行该函数</span></span><br><span class="line">    <span class="comment">// 相同的，如果是dispatch_get_global_queue也会走这个分支，执行_dispatch_queue_override_invoke方法，这个之前也说过了</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        dx_invoke(dou._do, dic, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续按自定义队列的步骤走</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_async_redirect_invoke(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">other_dc</span> = <span class="title">dc</span>-&gt;<span class="title">dc_other</span>;</span></span><br><span class="line">    <span class="keyword">dispatch_invoke_flags_t</span> ctxt_flags = (<span class="keyword">dispatch_invoke_flags_t</span>)dc-&gt;dc_ctxt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> assumed_rq = (<span class="keyword">dispatch_queue_t</span>)dc-&gt;dc_func;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = dc-&gt;dc_data, rq, old_dq;</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dbp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctxt_flags) &#123;</span><br><span class="line">        flags &amp;= ~_DISPATCH_INVOKE_AUTORELEASE_MASK;</span><br><span class="line">        flags |= ctxt_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    old_dq = _dispatch_get_current_queue();</span><br><span class="line">    <span class="keyword">if</span> (assumed_rq) &#123;</span><br><span class="line">        old_dbp = _dispatch_root_queue_identity_assume(assumed_rq);</span><br><span class="line">        _dispatch_set_basepri(dq-&gt;dq_priority);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        old_dbp = _dispatch_set_basepri(dq-&gt;dq_priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    <span class="comment">// _dispatch_continuation_pop_forwarded里面就是执行_dispatch_continuation_pop函数</span></span><br><span class="line">    _dispatch_continuation_pop_forwarded(dc, DISPATCH_NO_VOUCHER,</span><br><span class="line">            DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">        _dispatch_continuation_pop(other_dc, dic, flags, dq);</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">if</span> (assumed_rq) _dispatch_queue_set_current(old_dq);</span><br><span class="line">    _dispatch_reset_basepri(old_dbp);</span><br><span class="line"></span><br><span class="line">    rq = dq-&gt;do_targetq;</span><br><span class="line">    <span class="keyword">while</span> (slowpath(rq-&gt;do_targetq) &amp;&amp; rq != old_dq) &#123;</span><br><span class="line">        _dispatch_queue_non_barrier_complete(rq);</span><br><span class="line">        rq = rq-&gt;do_targetq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_queue_non_barrier_complete(dq);</span><br><span class="line">    _dispatch_release_tailcall(dq); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便说下，如果按照的是dispatch_get_global_queue会执行_dispatch_queue_override_invoke函数</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_override_invoke(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_rq = _dispatch_queue_get_current();</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> assumed_rq = dc-&gt;dc_other;</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dp;</span><br><span class="line">    <span class="keyword">voucher_t</span> ov = DISPATCH_NO_VOUCHER;</span><br><span class="line">    <span class="keyword">dispatch_object_t</span> dou;</span><br><span class="line"></span><br><span class="line">    dou._do = dc-&gt;dc_data;</span><br><span class="line">    old_dp = _dispatch_root_queue_identity_assume(assumed_rq);</span><br><span class="line">    <span class="keyword">if</span> (dc_type(dc) == DISPATCH_CONTINUATION_TYPE(OVERRIDE_STEALING)) &#123;</span><br><span class="line">        flags |= DISPATCH_INVOKE_STEALING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// balance the fake continuation push in</span></span><br><span class="line">        <span class="comment">// _dispatch_root_queue_push_override</span></span><br><span class="line">        _dispatch_trace_continuation_pop(assumed_rq, dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同样调用_dispatch_continuation_pop函数</span></span><br><span class="line">    _dispatch_continuation_pop_forwarded(dc, ov, DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">        <span class="keyword">if</span> (_dispatch_object_has_vtable(dou._do)) &#123;</span><br><span class="line">            dx_invoke(dou._do, dic, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _dispatch_continuation_invoke_inline(dou, ov, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_reset_basepri(old_dp);</span><br><span class="line">    _dispatch_queue_set_current(old_rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回归正题，无论是自定义的队列还是获取系统的，最终都会调用这个函数</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_invoke_context_t</span> dic,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags, <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_continuation_pop_inline(dou, dic, flags, dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">    _dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        dx_invoke(dou._do, dic, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_invoke_inline(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">voucher_t</span> ov,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    dispatch_invoke_with_autoreleasepool(flags, &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line"></span><br><span class="line">        _dispatch_continuation_voucher_adopt(dc, ov, dc_flags);</span><br><span class="line">        <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">            dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dc1 = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后面分析dispatch_group_async的时候会走if这个分支，但这次走的是else分支</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc_flags &amp; DISPATCH_OBJ_GROUP_BIT)) &#123;</span><br><span class="line">            _dispatch_continuation_with_group_invoke(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这次走这里，直接执行block函数</span></span><br><span class="line">            _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">            _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc1)) &#123;</span><br><span class="line">            _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，任务怎么被调度执行的已经看明白了。start_wqthread是汇编写的，直接和内核交互。虽然我们明确了使用了异步的任务被执行的调用顺序，但是想必还是有这样的疑问_dispatch_worker_thread3是怎么跟内核扯上关系的。为什么调用的是_dispatch_worker_thread3，而不是_dispatch_worker_thread或者_dispatch_worker_thread4呢？<br>&emsp;&emsp;在此之前需要说的是，在GCD中一共有2个线程池管理着任务，一个是主线程池，另一个就是除了主线程任务的线程池。主线程池由序号1的队列管理，其他有序号2的队列进行管理。加上runloop运行的runloop队列，一共就有16个队列。  </p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:left">标签</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">com.apple.main-thread</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">com.apple.libdispatch-manager</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">com.apple.root.libdispatch-manager</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">com.apple.root.maintenance-qos</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">com.apple.root.maintenance-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">com.apple.root.background-qos</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">com.apple.root.background-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:left">com.apple.root.utility-qos</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:left">com.apple.root.utility-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:left">com.apple.root.default-qos</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:left">com.apple.root.default-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:left">com.apple.root.user-initiated-qos</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:left">com.apple.root.user-initiated-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:left">com.apple.root.user-interactive-qos</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:left">com.apple.root.user-interactive-qos.overcommit</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;看图的话，就如下图<img src="gcd_opensource.png" alt="线程池图"><br>&emsp;&emsp;有那么多root队列，所以application启动的时候就会初始化这些root队列的_dispatch_root_queues_init函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_root_queues_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> _dispatch_root_queues_pred;</span><br><span class="line">    dispatch_once_f(&amp;_dispatch_root_queues_pred, <span class="literal">NULL</span>,</span><br><span class="line">            _dispatch_root_queues_init_once);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_root_queues_init_once(<span class="keyword">void</span> *context DISPATCH_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> wq_supported;</span><br><span class="line">    _dispatch_fork_becomes_unsafe();</span><br><span class="line">    <span class="keyword">if</span> (!_dispatch_root_queues_init_workq(&amp;wq_supported)) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DISPATCH_ROOT_QUEUE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> overcommit = <span class="literal">true</span>;</span><br><span class="line">            _dispatch_root_queue_init_pthread_pool(</span><br><span class="line">                    &amp;_dispatch_root_queue_contexts[i], <span class="number">0</span>, overcommit);</span><br><span class="line">        &#125;</span><br><span class="line">        DISPATCH_INTERNAL_CRASH((errno &lt;&lt; <span class="number">16</span>) | wq_supported,</span><br><span class="line">                <span class="string">"Root queue initialization failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_root_queues_init_workq(<span class="keyword">int</span> *wq_supported)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r; (<span class="keyword">void</span>)r;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    *wq_supported = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> disable_wq = <span class="literal">false</span>; (<span class="keyword">void</span>)disable_wq;</span><br><span class="line">    <span class="keyword">bool</span> disable_qos = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> disable_kevent_wq = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disable_wq &amp;&amp; !disable_qos) &#123;</span><br><span class="line">        *wq_supported = _pthread_workqueue_supported();</span><br><span class="line">        <span class="keyword">if</span> (!disable_kevent_wq &amp;&amp; (*wq_supported &amp; WORKQ_FEATURE_KEVENT)) &#123;</span><br><span class="line">            r = _pthread_workqueue_init_with_kevent(_dispatch_worker_thread3,</span><br><span class="line">                    (<span class="keyword">pthread_workqueue_function_kevent_t</span>)</span><br><span class="line">                    _dispatch_kevent_worker_thread,</span><br><span class="line">                    offsetof(struct dispatch_queue_s, dq_serialnum), <span class="number">0</span>);</span><br><span class="line">            result = !r;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;来到这里，已经看到_pthread_workqueue_init_with_kevent函数就是绑定了_dispatch_worker_thread3函数去做一些GCD的线程任务，看到源代码_pthread_workqueue_init_with_kevent做了些什么。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_pthread_workqueue_init_with_kevent(<span class="keyword">pthread_workqueue_function2_t</span> queue_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_kevent_t</span> kevent_func,</span><br><span class="line">        <span class="keyword">int</span> offset, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _pthread_workqueue_init_with_workloop(queue_func, kevent_func, <span class="literal">NULL</span>, offset, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_pthread_workqueue_init_with_workloop(<span class="keyword">pthread_workqueue_function2_t</span> queue_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_kevent_t</span> kevent_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_workloop_t</span> workloop_func,</span><br><span class="line">        <span class="keyword">int</span> offset, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ENOTSUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __workq_newapi = <span class="literal">true</span>;</span><br><span class="line">    __libdispatch_offset = offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rv = pthread_workqueue_setdispatch_with_workloop_np(queue_func, kevent_func, workloop_func);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">pthread_workqueue_setdispatch_with_workloop_np(<span class="keyword">pthread_workqueue_function2_t</span> queue_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_kevent_t</span> kevent_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_workloop_t</span> workloop_func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> res = EBUSY;</span><br><span class="line">    <span class="keyword">if</span> (__libdispatch_workerfunction == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Check whether the kernel supports new SPIs</span></span><br><span class="line">        res = __workq_kernreturn(WQOPS_QUEUE_NEWSPISUPP, <span class="literal">NULL</span>, __libdispatch_offset, kevent_func != <span class="literal">NULL</span> ? <span class="number">0x01</span> : <span class="number">0x00</span>);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>)&#123;</span><br><span class="line">            res = ENOTSUP;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __libdispatch_workerfunction = queue_func;</span><br><span class="line">            __libdispatch_keventfunction = kevent_func;</span><br><span class="line">            __libdispatch_workloopfunction = workloop_func;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the kernel for workq action</span></span><br><span class="line">            (<span class="keyword">void</span>)__workq_open();</span><br><span class="line">            <span class="keyword">if</span> (__is_threaded == <span class="number">0</span>) &#123;</span><br><span class="line">                __is_threaded = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们看到了__libdispatch_workerfunction = queue_func;指定了队列工作函数。然后我们往回看之前说的我们制造了一个人为crash，追溯栈里看到_pthread_wqthread这个函数。看下这个函数怎么启用_dispatch_worker_thread3的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际代码很多，这里我精简了下，拿到了__libdispatch_workerfunction对应的_dispatch_worker_thread3，然后直接执行。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_pthread_wqthread(<span class="keyword">pthread_t</span> self, <span class="keyword">mach_port_t</span> kport, <span class="keyword">void</span> *stacklowaddr, <span class="keyword">void</span> *keventlist, <span class="keyword">int</span> flags, <span class="keyword">int</span> nkevents)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_workqueue_function_t</span> func = (<span class="keyword">pthread_workqueue_function_t</span>)__libdispatch_workerfunction;</span><br><span class="line">    <span class="keyword">int</span> options = overcommit ? WORKQ_ADDTHREADS_OPTION_OVERCOMMIT : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    (*func)(thread_class, options, <span class="literal">NULL</span>);</span><br><span class="line">    __workq_kernreturn(WQOPS_THREAD_RETURN, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    _pthread_exit(self, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x05-dispatch-group-async"><a href="#0x05-dispatch-group-async" class="headerlink" title="0x05 dispatch_group_async"></a>0x05 dispatch_group_async</h1><p>&emsp;&emsp;同样从入口看起<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="keyword">uintptr_t</span> dc_flags = DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_GROUP_BIT;</span><br><span class="line"></span><br><span class="line">    _dispatch_continuation_init(dc, dq, db, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">    _dispatch_continuation_group_async(dg, dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;同样是_dispatch_continuation_init函数，这里跟dispatch_async那里一毛一样，忘记了的话，往回看。我们接着往下看，_dispatch_continuation_group_async函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    _dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们发现，其实dispatch_group_async内部也是加了dispatch_group_enter函数。dispatch_group_async怎么初始化我们至此已经说明完毕。<br>&emsp;&emsp;后面取出执行block逻辑跟dispatch_async略微不同，前面部分不做多说，调用顺序跟dispatch_async是一样的，唯一不同在于_dispatch_continuation_invoke_inline这个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_invoke_inline(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">voucher_t</span> ov,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    dispatch_invoke_with_autoreleasepool(flags, &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line"></span><br><span class="line">        _dispatch_continuation_voucher_adopt(dc, ov, dc_flags);</span><br><span class="line">        <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">            dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dc1 = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这次走if语句</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc_flags &amp; DISPATCH_OBJ_GROUP_BIT)) &#123;</span><br><span class="line">            _dispatch_continuation_with_group_invoke(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">            _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc1)) &#123;</span><br><span class="line">            _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_with_group_invoke(<span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dou</span> = <span class="title">dc</span>-&gt;<span class="title">dc_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> type = dx_type(dou);</span><br><span class="line">    <span class="keyword">if</span> (type == DISPATCH_GROUP_TYPE) &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">        _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">        <span class="comment">// 调用dispatch_group_leave</span></span><br><span class="line">        dispatch_group_leave((<span class="keyword">dispatch_group_t</span>)dou);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(dx_type(dou), <span class="string">"Unexpected object type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们有必要看下dispatch_group_enter和dispatch_group_leave函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dispatch_group_enter里面没啥说的，也就dg-&gt;dg_value值加1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_enter</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = os_atomic_inc_orig2o(dg, dg_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (slowpath((<span class="keyword">unsigned</span> <span class="keyword">long</span>)value &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)LONG_MAX)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">                <span class="string">"Too many nested calls to dispatch_group_enter()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        _dispatch_retain(dg); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_leave</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = os_atomic_dec2o(dg, dg_value, release);</span><br><span class="line">    <span class="comment">// 如果没有等待者，则调用_dispatch_group_wake函数</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>)_dispatch_group_wake(dg, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小于0就会crash，所以dispatch_group_enter和dispatch_group_leave必须匹配，不然就crash了。</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">                <span class="string">"Unbalanced call to dispatch_group_leave()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wake(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">bool</span> needs_release)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> next, head, tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> rval;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    head = os_atomic_xchg2o(dg, dg_notify_head, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        tail = os_atomic_xchg2o(dg, dg_notify_tail, <span class="literal">NULL</span>, release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dg-&gt;dg_waiters赋值为0，并返回dg-&gt;dg_waiters之前的值</span></span><br><span class="line">    rval = (<span class="keyword">long</span>)os_atomic_xchg2o(dg, dg_waiters, <span class="number">0</span>, relaxed);</span><br><span class="line">    <span class="comment">// 如果之前还有等待者</span></span><br><span class="line">    <span class="keyword">if</span> (rval) &#123;</span><br><span class="line">        <span class="comment">// 创建信号量</span></span><br><span class="line">        _dispatch_sema4_create(&amp;dg-&gt;dg_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">        <span class="comment">// 发出信号</span></span><br><span class="line">        _dispatch_sema4_signal(&amp;dg-&gt;dg_sema, rval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint16_t</span> refs = needs_release ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// dispatch_group里是否有任务等待执行，有的话加入。</span></span><br><span class="line">    <span class="comment">// 比如dispatch_group_notify的任务就在此时被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            next = os_mpsc_pop_snapshot_head(head, tail, do_next);</span><br><span class="line">            <span class="keyword">dispatch_queue_t</span> dsn_queue = (<span class="keyword">dispatch_queue_t</span>)head-&gt;dc_data;</span><br><span class="line">            _dispatch_continuation_async(dsn_queue, head);</span><br><span class="line">            _dispatch_release(dsn_queue);</span><br><span class="line">        &#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">        refs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (refs) _dispatch_release_n(dg, refs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x06-dispatch-once"><a href="#0x06-dispatch-once" class="headerlink" title="0x06 dispatch_once"></a>0x06 dispatch_once</h1><p>&emsp;&emsp;还是从入口函数开始看<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们调用dispatch_once的入口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 内部又调用了dispatch_once_f函数</span></span><br><span class="line">    dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once_f</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_once_f_slow(val, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ONCE_SLOW_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dispatch_once_f_slow(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _dispatch_once_waiter_t格式：</span></span><br><span class="line">    <span class="comment">// typedef struct _dispatch_once_waiter_s &#123;</span></span><br><span class="line">    <span class="comment">//      volatile struct _dispatch_once_waiter_s *volatile dow_next;</span></span><br><span class="line">    <span class="comment">//      dispatch_thread_event_s dow_event;</span></span><br><span class="line">    <span class="comment">//      mach_port_t dow_thread;</span></span><br><span class="line">    <span class="comment">// &#125; *_dispatch_once_waiter_t;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile：告诉编译器不要对此指针进行代码优化，因为这个指针指向的值可能会被其他线程改变</span></span><br><span class="line">    <span class="keyword">_dispatch_once_waiter_t</span> <span class="keyword">volatile</span> *vval = (<span class="keyword">_dispatch_once_waiter_t</span>*)val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> <span class="title">dow</span> = &#123;</span> &#125;;</span><br><span class="line">    <span class="keyword">_dispatch_once_waiter_t</span> tail = &amp;dow, next, tmp;</span><br><span class="line">    <span class="keyword">dispatch_thread_event_t</span> event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次执行时，*vval为0，此时第一个参数vval和第二个参数NULL比较是相等的，返回true，然后把tail赋值给第一个参数的值。如果这时候同时有别的线程也进来，此时vval的值不是0了，所以会来到else分支。</span></span><br><span class="line">    <span class="keyword">if</span> (os_atomic_cmpxchg(vval, <span class="literal">NULL</span>, tail, acquire)) &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        dow.dow_thread = _dispatch_tid_self();</span><br><span class="line">        <span class="comment">// 调用block函数，一般就是我们在外面做的初始化工作</span></span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部将DLOCK_ONCE_DONE赋值给val，将当前标记为已完成，返回之前的引用值。前面说过了，把tail赋值给val了，但这只是没有别的线程进来走到下面else分支，如果有别的线程进来next就是别的值了，如果没有别的信号量在等待，工作就到此结束了。</span></span><br><span class="line">        next = (<span class="keyword">_dispatch_once_waiter_t</span>)_dispatch_once_xchg_done(val);</span><br><span class="line">        <span class="comment">// 如果没有别的线程进来过处于等待，这里就会结束。如果有，则遍历每一个等待的信号量，然后一个个唤醒它们</span></span><br><span class="line">        <span class="keyword">while</span> (next != tail) &#123;</span><br><span class="line">            <span class="comment">// 内部用到了thread_switch，避免优先级反转。把next-&gt;dow_next返回</span></span><br><span class="line">            tmp = (<span class="keyword">_dispatch_once_waiter_t</span>)_dispatch_wait_until(next-&gt;dow_next);</span><br><span class="line">            event = &amp;next-&gt;dow_event;</span><br><span class="line">            next = tmp;</span><br><span class="line">            <span class="comment">// 唤醒信号量</span></span><br><span class="line">            _dispatch_thread_event_signal(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 内部就是_dispatch_sema4_init函数，也就是初始化一个信号链表</span></span><br><span class="line">        _dispatch_thread_event_init(&amp;dow.dow_event);</span><br><span class="line">        <span class="comment">// next指向新的原子</span></span><br><span class="line">        next = *vval;</span><br><span class="line">        <span class="comment">// 不断循环等待</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 前面说过第一次进来后进入if分支，后面再次进来，会来到这里，但是之前if里面被标志为DISPATCH_ONCE_DONE了，所以结束。</span></span><br><span class="line">            <span class="keyword">if</span> (next == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当第一次初始化的时候，同时有别的线程也进来，这是第一个线程已经占据了if分支，但其他线程也是第一进来，所以状态并不是DISPATCH_ONCE_DONE，所以就来到了这里</span></span><br><span class="line">            <span class="comment">// 比较vval和next是否一样，其他线程第一次来这里肯定是相等的</span></span><br><span class="line">            <span class="keyword">if</span> (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release)) &#123;</span><br><span class="line">                dow.dow_thread = next-&gt;dow_thread;</span><br><span class="line">                dow.dow_next = next;</span><br><span class="line">                <span class="keyword">if</span> (dow.dow_thread) &#123;</span><br><span class="line">                    <span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">                    _dispatch_thread_override_start(dow.dow_thread, pp, val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待唤醒，唤醒后就做收尾操作</span></span><br><span class="line">                _dispatch_thread_event_wait(&amp;dow.dow_event);</span><br><span class="line">                <span class="keyword">if</span> (dow.dow_thread) &#123;</span><br><span class="line"></span><br><span class="line">                    _dispatch_thread_override_end(dow.dow_thread, val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        _dispatch_thread_event_destroy(&amp;dow.dow_event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么，回到上篇提到使用dispatch_once死锁的问题，如果使用不当会造成什么后果？回顾下上篇的实验代码<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> once];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)once &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> otherOnce];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"遇到第一只熊猫宝宝..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherOnce &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> once];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"遇到第二只熊猫宝宝..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;示例中我们可以看到once方法需要等待otherOnce方法的完成，而otherOnce又调用了once，根据前面的源码，otherOnce调用once方法会走到else分支，在这个分支等待之前一个信号量发出唤醒指令，但是once方法里面又依赖otherOnce方法的完成，由于处于一个线程，所以就卡住了。</p>
<h1 id="0x06-dispatch-group-create-amp-dispatch-semaphore-create"><a href="#0x06-dispatch-group-create-amp-dispatch-semaphore-create" class="headerlink" title="0x06 dispatch_group_create &amp; dispatch_semaphore_create"></a>0x06 dispatch_group_create &amp; dispatch_semaphore_create</h1><p>&emsp;&emsp;为什么两个一起看，其实dispatch_group也是通过dispatch_semaphore控制的，看下dispatch_group_create源代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span></span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_group_create_with_count(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_group_t</span></span><br><span class="line">_dispatch_group_create_with_count(<span class="keyword">long</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg = (<span class="keyword">dispatch_group_t</span>)_dispatch_object_alloc(</span><br><span class="line">        DISPATCH_VTABLE(group), <span class="keyword">sizeof</span>(struct dispatch_group_s));</span><br><span class="line"> _dispatch_semaphore_class_init(count, dg); <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="keyword">if</span> (count) &#123;</span><br><span class="line">        os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;同样的，看下dispatch_semaphore_create源代码，是不是一股熟悉的配方：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">dispatch_semaphore_t</span></span><br><span class="line">    dispatch_semaphore_create(<span class="keyword">long</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">dispatch_semaphore_t</span> dsema;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dsema = (<span class="keyword">dispatch_semaphore_t</span>)_dispatch_object_alloc(</span><br><span class="line">            DISPATCH_VTABLE(semaphore), <span class="keyword">sizeof</span>(struct dispatch_semaphore_s));</span><br><span class="line">        _dispatch_semaphore_class_init(value, dsema); <span class="comment">// 同样的初始化信号量</span></span><br><span class="line">        dsema-&gt;dsema_orig = value;</span><br><span class="line">        <span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x07-dispatch-group-wait-amp-dispatch-semaphore-wait"><a href="#0x07-dispatch-group-wait-amp-dispatch-semaphore-wait" class="headerlink" title="0x07 dispatch_group_wait &amp; dispatch_semaphore_wait"></a>0x07 dispatch_group_wait &amp; dispatch_semaphore_wait</h1><p>&emsp;&emsp;<br>再看下dispatch_group_wait的代码，其内部是调用的_dispatch_group_wait_slow函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wait_slow(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">int</span> orig_waiters;</span><br><span class="line"></span><br><span class="line">    value = os_atomic_load2o(dg, dg_value, ordered); </span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>)os_atomic_inc2o(dg, dg_waiters, relaxed);</span><br><span class="line"></span><br><span class="line">    value = os_atomic_load2o(dg, dg_value, ordered);</span><br><span class="line">    <span class="comment">// 如果group里没有任务</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        _dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">        timeout = DISPATCH_TIME_FOREVER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_sema4_create(&amp;dg-&gt;dg_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dg-&gt;dg_sema, timeout)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig_waiters = dg-&gt;dg_waiters;</span><br><span class="line">        <span class="keyword">while</span> (orig_waiters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (os_atomic_cmpxchgvw2o(dg, dg_waiters, orig_waiters,</span><br><span class="line">                    orig_waiters - <span class="number">1</span>, &amp;orig_waiters, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        _dispatch_sema4_wait(&amp;dg-&gt;dg_sema);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对比着看dispatch_semaphore_wait源码，其内部也调用_dispatch_semaphore_wait_slow函数，可以看到逻辑基本一致：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">        <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line"></span><br><span class="line">    _dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_value;</span><br><span class="line">        <span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (os_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">                    &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        _dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x08-dispatch-group-notify"><a href="#0x08-dispatch-group-notify" class="headerlink" title="0x08 dispatch_group_notify"></a>0x08 dispatch_group_notify</h1><p>&emsp;&emsp;再把dispatch_group_notify看下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_block_t</span> db)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dsn = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="comment">// 之前说过了</span></span><br><span class="line">    _dispatch_continuation_init(dsn, dq, db, <span class="number">0</span>, <span class="number">0</span>, DISPATCH_OBJ_CONSUME_BIT);</span><br><span class="line">    _dispatch_group_notify(dg, dq, dsn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_continuation_t</span> dsn)</span><br><span class="line">&#123;</span><br><span class="line">    dsn-&gt;dc_data = dq;</span><br><span class="line">    dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    _dispatch_retain(dq);</span><br><span class="line">    <span class="keyword">if</span> (os_mpsc_push_update_tail(dg, dg_notify, dsn, do_next)) &#123;</span><br><span class="line">        _dispatch_retain(dg);</span><br><span class="line">        os_atomic_store2o(dg, dg_notify_head, dsn, ordered);</span><br><span class="line">        <span class="comment">// 如果此时group里面的任务都完成了，那么就立刻唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (os_atomic_load2o(dg, dg_value, ordered) == <span class="number">0</span>) &#123;</span><br><span class="line">            _dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在dispatch_group_async里面我们知道dispatch_group的任务在执行后会调用dispatch_group_leave。这个函数里面如果等待者没有了，就会唤醒dispatch_group。里面的任务，比如dispatch_group_notify的任务就会这时候被执行。<br>&emsp;&emsp;这里执行的调用顺序就不贴了，基本跟dispatch_async一致。</p>
<h1 id="0x09-dispatch-barrier-async"><a href="#0x09-dispatch-barrier-async" class="headerlink" title="0x09 dispatch_barrier_async"></a>0x09 dispatch_barrier_async</h1><p>&emsp;&emsp;可以看到，大多数实现都是大同小异，通过不同的标志位来控制。这里跟dispatch_async的不同就在于，dispatch_async直接把任务扔到root队列，而dispatch_barrier_async是把任务在到自定义的队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_barrier_async(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="keyword">uintptr_t</span> dc_flags = DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_BARRIER_BIT;</span><br><span class="line"></span><br><span class="line">    _dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">    _dispatch_continuation_push(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_push(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_queue_push_inline(dq, dou, qos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_push_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _tail,</span><br><span class="line">        <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">tail</span> = _<span class="title">tail</span>._<span class="title">do</span>;</span></span><br><span class="line">    <span class="keyword">dispatch_wakeup_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> overriding = _dispatch_queue_need_override_retain(dq, qos);</span><br><span class="line">    <span class="comment">// 加入到自己的队列</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_queue_push_update_tail(dq, tail))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!overriding) _dispatch_retain_2(dq-&gt;_as_os_obj);</span><br><span class="line">        _dispatch_queue_push_update_head(dq, tail);</span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overriding) &#123;</span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒队列</span></span><br><span class="line">    <span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_wakeup(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="keyword">dispatch_wakeup_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_wakeup_target_t</span> target = DISPATCH_QUEUE_WAKEUP_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_WAKEUP_BARRIER_COMPLETE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_barrier_complete(dq, qos, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部就是 tail != NULL，所以满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_queue_class_probe(dq)) &#123;</span><br><span class="line">        <span class="comment">// #define DISPATCH_QUEUE_WAKEUP_TARGET  ((dispatch_queue_wakeup_target_t)1)</span></span><br><span class="line">        target = DISPATCH_QUEUE_WAKEUP_TARGET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_class_wakeup(dq, qos, flags, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_class_wakeup(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="keyword">dispatch_wakeup_flags_t</span> flags, <span class="keyword">dispatch_queue_wakeup_target_t</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会走进去</span></span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> old_state, new_state, enqueue = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_MGR) &#123;</span><br><span class="line">            enqueue = DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">        &#125;</span><br><span class="line">        qos = _dispatch_queue_override_qos(dq, qos);</span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">            new_state = _dq_state_merge_qos(old_state, qos);</span><br><span class="line">            <span class="keyword">if</span> (likely(!_dq_state_is_suspended(old_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_enqueued(old_state) &amp;&amp;</span><br><span class="line">                    (!_dq_state_drain_locked(old_state) ||</span><br><span class="line">                    (enqueue != DISPATCH_QUEUE_ENQUEUED_ON_MGR &amp;&amp;</span><br><span class="line">                    _dq_state_is_base_wlh(old_state))))) &#123;</span><br><span class="line">                new_state |= enqueue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_WAKEUP_MAKE_DIRTY) &#123;</span><br><span class="line">                new_state |= DISPATCH_QUEUE_DIRTY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_state == old_state) &#123;</span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">goto</span> done);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">            <span class="keyword">dispatch_queue_t</span> tq;</span><br><span class="line">            <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_TARGET) &#123;</span><br><span class="line">                os_atomic_thread_fence(dependency);</span><br><span class="line">                tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,</span><br><span class="line">                        (<span class="keyword">long</span>)new_state);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tq = target;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">            <span class="comment">// 把队列装入到root队列中,内部调用的_dispatch_root_queue_push函数</span></span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _dispatch_root_queue_push函数在dispatch_async已经贴过代码，直接看_dispatch_root_queue_push_override函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_push_override(<span class="keyword">dispatch_queue_t</span> orig_rq,</span><br><span class="line">        <span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> overcommit = orig_rq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> rq = _dispatch_get_root_queue(qos, overcommit);</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc;</span><br><span class="line">    <span class="comment">// 因为barrier是直接推进自己的队列，所以这里不会走if语句，具体注释可以看dispatch_async那里</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_is_redirection(dc)) &#123;</span><br><span class="line">        dc-&gt;dc_func = (<span class="keyword">void</span> *)orig_rq;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc = _dispatch_continuation_alloc();</span><br><span class="line">        <span class="comment">// 指定do_vtable，所以取出来执行的时候调用的是_dispatch_queue_override_invoke函数</span></span><br><span class="line">        dc-&gt;do_vtable = DC_VTABLE(OVERRIDE_OWNING);</span><br><span class="line">        _dispatch_trace_continuation_push(orig_rq, dou);</span><br><span class="line">        dc-&gt;dc_ctxt = dc;</span><br><span class="line">        dc-&gt;dc_other = orig_rq;</span><br><span class="line">        dc-&gt;dc_data = dou._do;</span><br><span class="line">        dc-&gt;dc_priority = DISPATCH_NO_PRIORITY;</span><br><span class="line">        dc-&gt;dc_voucher = DISPATCH_NO_VOUCHER;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dc, dc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面也省略</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;同样我们人为制造一个闪退，看下被调用顺序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>   libdispatch.dylib                   <span class="number">0x0000000105b952f7</span> _dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line"><span class="number">7</span>   libdispatch.dylib                   <span class="number">0x0000000105b9633d</span> _dispatch_client_callout + <span class="number">8</span></span><br><span class="line"><span class="number">8</span>   libdispatch.dylib                   <span class="number">0x0000000105ba40a5</span> _dispatch_queue_concurrent_drain + <span class="number">1492</span></span><br><span class="line"><span class="number">9</span>   libdispatch.dylib                   <span class="number">0x0000000105b9f1fb</span> _dispatch_queue_invoke + <span class="number">353</span></span><br><span class="line"><span class="number">10</span>  libdispatch.dylib                   <span class="number">0x0000000105b9af7c</span> _dispatch_queue_override_invoke + <span class="number">733</span></span><br><span class="line"><span class="number">11</span>  libdispatch.dylib                   <span class="number">0x0000000105ba2102</span> _dispatch_root_queue_drain + <span class="number">772</span></span><br><span class="line"><span class="number">12</span>  libdispatch.dylib                   <span class="number">0x0000000105ba1da0</span> _dispatch_worker_thread3 + <span class="number">132</span></span><br><span class="line"><span class="number">13</span>  libsystem_pthread.dylib             <span class="number">0x000000010605d5a2</span> _pthread_wqthread + <span class="number">1299</span></span><br><span class="line"><span class="number">14</span>  libsystem_pthread.dylib             <span class="number">0x000000010605d07d</span> start_wqthread + <span class="number">13</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;一样从_dispatch_root_queue_drain开始看<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">pthread_priority_t</span> pp)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_queue_set_current(dq);</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> pri = dq-&gt;dq_priority;</span><br><span class="line">    <span class="keyword">if</span> (!pri) pri = _dispatch_priority_from_pp(pp);</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dbp = _dispatch_set_basepri(pri);</span><br><span class="line">    _dispatch_adopt_wlh_anon();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> reset = <span class="literal">false</span>;</span><br><span class="line">    dispatch_invoke_context_s dic = &#123; &#125;;</span><br><span class="line">    <span class="keyword">dispatch_invoke_flags_t</span> flags = DISPATCH_INVOKE_WORKER_DRAIN |</span><br><span class="line">            DISPATCH_INVOKE_REDIRECTING_DRAIN;</span><br><span class="line">    _dispatch_queue_drain_init_narrowing_check_deadline(&amp;dic, pri);</span><br><span class="line">    _dispatch_perfmon_start();</span><br><span class="line">    <span class="comment">// rootqueue可以跟一个dispatch_queue_t也可以跟一个dispatch_continuation_t</span></span><br><span class="line">    <span class="comment">// 所以这里item取出来的是dispatch_queue_t</span></span><br><span class="line">    <span class="keyword">while</span> ((item = fastpath(_dispatch_root_queue_drain_one(dq)))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reset) _dispatch_wqthread_override_reset();</span><br><span class="line">        _dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line">        <span class="comment">// 重置当前线程的优先级，会跟内核交互</span></span><br><span class="line">        reset = _dispatch_reset_basepri_override();</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(&amp;dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overcommit or not. worker thread</span></span><br><span class="line">    <span class="keyword">if</span> (pri &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG) &#123;</span><br><span class="line">        _dispatch_perfmon_end(perfmon_thread_worker_oc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_perfmon_end(perfmon_thread_worker_non_oc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_reset_wlh();</span><br><span class="line">    _dispatch_reset_basepri(old_dbp);</span><br><span class="line">    _dispatch_reset_basepri_override();</span><br><span class="line">    _dispatch_queue_set_current(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">    _dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">    <span class="comment">// 调用_dispatch_queue_override_invoke函数</span></span><br><span class="line">    <span class="comment">// 这里其实很好理解，从root队列拿出来的有可能是一个队列，也可能就是一个任务，所以如果是队列，就调用队列的执行函数</span></span><br><span class="line">    <span class="comment">// 所以为什么官方文档说，不是自定义队列使用barrier无效，因为不是自定义队列，这里就直接走_dispatch_continuation_invoke_inline函数，调用函数实现了，也就是dispatch_barrier_async类似于dispatch_async了。</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        dx_invoke(dou._do, dic, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_override_invoke(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_rq = _dispatch_queue_get_current();</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> assumed_rq = dc-&gt;dc_other;</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dp;</span><br><span class="line">    <span class="keyword">voucher_t</span> ov = DISPATCH_NO_VOUCHER;</span><br><span class="line">    <span class="keyword">dispatch_object_t</span> dou;</span><br><span class="line"></span><br><span class="line">    dou._do = dc-&gt;dc_data;</span><br><span class="line">    <span class="comment">// 将自定义queue激活，其root队列挂起。将rootqueue保存到old_dq变量</span></span><br><span class="line">    <span class="comment">// 所以这也就是为什么，barrier的任务可以提前执行，后面的任务会被阻塞</span></span><br><span class="line">    <span class="comment">//  static inline dispatch_priority_t</span></span><br><span class="line">    <span class="comment">//_dispatch_root_queue_identity_assume(dispatch_queue_t assumed_rq)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//      dispatch_priority_t old_dbp = _dispatch_get_basepri();</span></span><br><span class="line">    <span class="comment">//      dispatch_assert(dx_hastypeflag(assumed_rq, QUEUE_ROOT));</span></span><br><span class="line">    <span class="comment">//      _dispatch_reset_basepri(assumed_rq-&gt;dq_priority);</span></span><br><span class="line">    <span class="comment">//      _dispatch_queue_set_current(assumed_rq);</span></span><br><span class="line">    <span class="comment">//      return old_dbp;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    old_dp = _dispatch_root_queue_identity_assume(assumed_rq);</span><br><span class="line">    <span class="keyword">if</span> (dc_type(dc) == DISPATCH_CONTINUATION_TYPE(OVERRIDE_STEALING)) &#123;</span><br><span class="line">        flags |= DISPATCH_INVOKE_STEALING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_trace_continuation_pop(assumed_rq, dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_continuation_pop_forwarded(dc, ov, DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">        <span class="comment">// 来到if分支，调用_dispatch_queue_invoke函数</span></span><br><span class="line">        <span class="keyword">if</span> (_dispatch_object_has_vtable(dou._do)) &#123;</span><br><span class="line">            dx_invoke(dou._do, dic, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _dispatch_continuation_invoke_inline(dou, ov, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 重新激活root队列</span></span><br><span class="line">    _dispatch_reset_basepri(old_dp);</span><br><span class="line">    _dispatch_queue_set_current(old_rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_invoke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_invoke_context_t</span> dic,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_queue_class_invoke(dq, dic, flags, <span class="number">0</span>, dispatch_queue_invoke2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_class_invoke(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> const_restrict_flags,</span><br><span class="line">        <span class="keyword">_dispatch_queue_class_invoke_handler_t</span> invoke)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = dou._dq;</span><br><span class="line">    <span class="keyword">dispatch_queue_wakeup_target_t</span> tq = DISPATCH_QUEUE_WAKEUP_NONE;</span><br><span class="line">    <span class="keyword">bool</span> owning = !(flags &amp; DISPATCH_INVOKE_STEALING);</span><br><span class="line">    <span class="keyword">uint64_t</span> owned = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; (DISPATCH_INVOKE_STEALING | DISPATCH_INVOKE_WLH))) &#123;</span><br><span class="line">        dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= const_restrict_flags;</span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_INVOKE_WLH)) &#123;</span><br><span class="line">        owned = DISPATCH_QUEUE_SERIAL_DRAIN_OWNED | DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owned = _dispatch_queue_drain_try_lock(dq, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (likely(owned)) &#123;</span><br><span class="line">        <span class="keyword">dispatch_priority_t</span> old_dbp;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; DISPATCH_INVOKE_MANAGER_DRAIN)) &#123;</span><br><span class="line">            old_dbp = _dispatch_set_basepri(dq-&gt;dq_priority);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            old_dbp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flags = _dispatch_queue_merge_autorelease_frequency(dq, flags);</span><br><span class="line"></span><br><span class="line">attempt_running_slow_head:</span><br><span class="line">        <span class="comment">// 执行dispatch_queue_invoke2函数</span></span><br><span class="line">        <span class="comment">// 也就是执行自定义队列里面的任务</span></span><br><span class="line">        tq = invoke(dq, dic, flags, &amp;owned);</span><br><span class="line">        dispatch_assert(tq != DISPATCH_QUEUE_WAKEUP_TARGET);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(tq != DISPATCH_QUEUE_WAKEUP_NONE &amp;&amp;</span><br><span class="line">                tq != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT)) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_drain_try_unlock(dq, owned,</span><br><span class="line">                tq == DISPATCH_QUEUE_WAKEUP_NONE)) &#123;</span><br><span class="line">            tq = _dispatch_queue_get_current();</span><br><span class="line">            <span class="keyword">if</span> (dx_hastypeflag(tq, QUEUE_ROOT) || !owning) &#123;</span><br><span class="line">                <span class="keyword">goto</span> attempt_running_slow_head;</span><br><span class="line">            &#125;</span><br><span class="line">            DISPATCH_COMPILER_CAN_ASSUME(tq != DISPATCH_QUEUE_WAKEUP_NONE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            owned = <span class="number">0</span>;</span><br><span class="line">            tq = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; DISPATCH_INVOKE_MANAGER_DRAIN)) &#123;</span><br><span class="line">            _dispatch_reset_basepri(old_dbp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (likely(owning)) &#123;</span><br><span class="line">        _dispatch_introspection_queue_item_complete(dq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tq) &#123;</span><br><span class="line">        <span class="keyword">if</span> (const_restrict_flags &amp; DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS) &#123;</span><br><span class="line">            dispatch_assert(dic-&gt;dic_deferred == <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dic-&gt;dic_deferred) &#123;</span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_drain_sync_waiter(dq, dic,</span><br><span class="line">                    flags, owned);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint64_t</span> old_state, new_state, enqueued = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        <span class="keyword">if</span> (tq == DISPATCH_QUEUE_WAKEUP_MGR) &#123;</span><br><span class="line">            enqueued = DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">        &#125;</span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">            new_state  = old_state - owned;</span><br><span class="line">            new_state &amp;= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;</span><br><span class="line">            new_state |= DISPATCH_QUEUE_DIRTY;</span><br><span class="line">            <span class="keyword">if</span> (_dq_state_is_suspended(new_state)) &#123;</span><br><span class="line">                new_state |= DLOCK_OWNER_MASK;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dq_state_is_runnable(new_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_enqueued(new_state)) &#123;</span><br><span class="line">                <span class="comment">// drain was not interupted for suspension</span></span><br><span class="line">                <span class="comment">// we will reenqueue right away, just put ENQUEUED back</span></span><br><span class="line">                new_state |= enqueued;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        old_state -= owned;</span><br><span class="line">        <span class="keyword">if</span> (_dq_state_received_override(old_state)) &#123;</span><br><span class="line">            <span class="comment">// Ensure that the root queue sees that this thread was overridden.</span></span><br><span class="line">            _dispatch_set_basepri_override_qos(_dq_state_max_qos(new_state));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((old_state ^ new_state) &amp; enqueued) &#123;</span><br><span class="line">            dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_release_2_tailcall(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_queue_wakeup_target_t <span class="title">dispatch_queue_invoke2</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_invoke_context_t</span> dic,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_invoke_flags_t</span> flags, <span class="keyword">uint64_t</span> *owned)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> otq = dq-&gt;do_targetq;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> cq = _dispatch_queue_get_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(cq != otq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> otq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_serial_drain(dq, dic, flags, owned);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_concurrent_drain(dq, dic, flags, owned);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_wakeup_target_t</span> _dispatch_queue_concurrent_drain(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">uint64_t</span> *owned)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_drain(dq, dic, flags, owned, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_queue_drain(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_invoke_context_t</span> dic,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags, <span class="keyword">uint64_t</span> *owned_ptr, <span class="keyword">bool</span> serial_drain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> orig_tq = dq-&gt;do_targetq;</span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dc</span> = <span class="title">NULL</span>, *<span class="title">next_dc</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> dq_state, owned = *owned_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dq-&gt;dq_items_tail)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    <span class="keyword">if</span> (serial_drain || _dq_state_is_in_barrier(owned)) &#123;</span><br><span class="line">        <span class="comment">// we really own `IN_BARRIER + dq-&gt;dq_width * WIDTH_INTERVAL`</span></span><br><span class="line">        <span class="comment">// but width can change while draining barrier work items, so we only</span></span><br><span class="line">        <span class="comment">// convert to `dq-&gt;dq_width * WIDTH_INTERVAL` when we drop `IN_BARRIER`</span></span><br><span class="line">        owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owned &amp;= DISPATCH_QUEUE_WIDTH_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dc = _dispatch_queue_head(dq);</span><br><span class="line">    <span class="keyword">goto</span> first_iteration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行自定义里面的任务，一个接一个执行，不能并行执行。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        dc = next_dc;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dic-&gt;dic_deferred)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out_with_deferred_compute_owned;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_needs_to_return_to_kernel())) &#123;</span><br><span class="line">            _dispatch_return_to_kernel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dc)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dq-&gt;dq_items_tail) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dc = _dispatch_queue_head(dq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(serial_drain != (dq-&gt;dq_width == <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">first_iteration:</span><br><span class="line">        dq_state = os_atomic_load(&amp;dq-&gt;dq_state, relaxed);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dq_state_is_suspended(dq_state))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(orig_tq != dq-&gt;do_targetq)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serial_drain || _dispatch_object_is_barrier(dc)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!serial_drain &amp;&amp; owned != DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_dispatch_queue_try_upgrade_full_width(dq, owned)) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">            &#125;</span><br><span class="line">            next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">                owned = <span class="number">0</span>;</span><br><span class="line">                dic-&gt;dic_deferred = dc;</span><br><span class="line">                <span class="keyword">goto</span> out_with_deferred;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                os_atomic_xor2o(dq, dq_state, owned, release);</span><br><span class="line">                owned = dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(owned == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">                    <span class="comment">// sync "readers" don't observe the limit</span></span><br><span class="line">                    _dispatch_queue_reserve_sync_width(dq);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_try_acquire_async(dq)) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_sync_waiter_redirect_or_wake(dq,</span><br><span class="line">                        DISPATCH_SYNC_WAITER_NO_UNLOCK, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_INVOKE_REDIRECTING_DRAIN) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_continuation_redirect(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行这个函数</span></span><br><span class="line">        _dispatch_continuation_pop_inline(dc, dic, flags, dq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">        <span class="comment">// if we're IN_BARRIER we really own the full width too</span></span><br><span class="line">        owned += dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dc) &#123;</span><br><span class="line">        owned = _dispatch_queue_adjust_owned(dq, owned, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    *owned_ptr |= owned;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> dc ? dq-&gt;do_targetq : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_with_no_width:</span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;</span><br><span class="line"></span><br><span class="line">out_with_deferred_compute_owned:</span><br><span class="line">    <span class="keyword">if</span> (serial_drain) &#123;</span><br><span class="line">        owned = DISPATCH_QUEUE_IN_BARRIER + DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">            <span class="comment">// if we're IN_BARRIER we really own the full width too</span></span><br><span class="line">            owned += dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dc) &#123;</span><br><span class="line">            owned = _dispatch_queue_adjust_owned(dq, owned, dc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out_with_deferred:</span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    *owned_ptr |= owned;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS)) &#123;</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(dc,</span><br><span class="line">                <span class="string">"Deferred continuation on source, mach channel or mgr"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> dq-&gt;do_targetq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">    _dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        dx_invoke(dou._do, dic, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_invoke_inline(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">voucher_t</span> ov,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    dispatch_invoke_with_autoreleasepool(flags, &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line">        _dispatch_continuation_voucher_adopt(dc, ov, dc_flags);</span><br><span class="line">        <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">            dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dc1 = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc_flags &amp; DISPATCH_OBJ_GROUP_BIT)) &#123;</span><br><span class="line">            _dispatch_continuation_with_group_invoke(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用_dispatch_client_callout执行block</span></span><br><span class="line">            _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">            _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc1)) &#123;</span><br><span class="line">            _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x10-dispatch-get-global-queue"><a href="#0x10-dispatch-get-global-queue" class="headerlink" title="0x10 dispatch_get_global_queue"></a>0x10 dispatch_get_global_queue</h1><p>&emsp;&emsp;可以发现，dispatch_get_global_queue其实就是取对应优先级的root队列拿来用。所以上面也提过，为啥在global_queue里面不能用barrier。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(<span class="keyword">long</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(<span class="keyword">unsigned</span> <span class="keyword">long</span>)DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dispatch_qos_t</span> qos = _dispatch_qos_from_queue_priority(priority);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">        <span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_get_root_queue(qos, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(qos == DISPATCH_QOS_UNSPECIFIED || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(qos, <span class="string">"Corrupted priority"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span> * (qos - <span class="number">1</span>) + overcommit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x11-结束语"><a href="#0x11-结束语" class="headerlink" title="0x11 结束语"></a>0x11 结束语</h1><p>&emsp;&emsp;常用的GCD几个函数到此就说明完了，每个函数的执行顺序我也用符号断点确认过，基本应该不会有问题。但万一还是有纰漏，请联系本人。</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener">GCD官方源码</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/16/浅谈iOS多线程-使用篇/" rel="next" title="浅谈iOS多线程_使用篇">
                <i class="fa fa-chevron-left"></i> 浅谈iOS多线程_使用篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/06/多线程中锁的应用/" rel="prev" title="多线程中锁的应用">
                多线程中锁的应用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">朝暮</p>
              <p class="site-description motion-element" itemprop="description">联系方式：leylfl@foxmail.com</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-开篇"><span class="nav-number">1.</span> <span class="nav-text">0x00 开篇</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-Mach"><span class="nav-number">2.</span> <span class="nav-text">0x01 Mach</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-源码中常见的宏"><span class="nav-number">3.</span> <span class="nav-text">0x02 源码中常见的宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-builtin-expect"><span class="nav-number">3.0.1.</span> <span class="nav-text">1. __builtin_expect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-likely和unlikely"><span class="nav-number">3.0.2.</span> <span class="nav-text">2. likely和unlikely</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-fastpath和slowpath"><span class="nav-number">3.0.3.</span> <span class="nav-text">3. fastpath和slowpath</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-os-atomic-cmpxchg"><span class="nav-number">3.0.4.</span> <span class="nav-text">4. os_atomic_cmpxchg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-os-atomic-store2o"><span class="nav-number">3.0.5.</span> <span class="nav-text">5. os_atomic_store2o</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-os-atomic-inc-orig"><span class="nav-number">3.0.6.</span> <span class="nav-text">6. os_atomic_inc_orig</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-数据结构体"><span class="nav-number">4.</span> <span class="nav-text">0x03 数据结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-dispatch-queue-t"><span class="nav-number">4.0.1.</span> <span class="nav-text">1. dispatch_queue_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-dispatch-continuation-t"><span class="nav-number">4.0.2.</span> <span class="nav-text">2. dispatch_continuation_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-dispatch-object-t"><span class="nav-number">4.0.3.</span> <span class="nav-text">3. dispatch_object_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-dispatch-function-t"><span class="nav-number">4.0.4.</span> <span class="nav-text">4. dispatch_function_t</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-创建队列"><span class="nav-number">5.</span> <span class="nav-text">0x03 创建队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x04-dispatch-sync"><span class="nav-number">6.</span> <span class="nav-text">0x04 dispatch_sync</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x05-dispatch-async"><span class="nav-number">7.</span> <span class="nav-text">0x05 dispatch_async</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x05-dispatch-group-async"><span class="nav-number">8.</span> <span class="nav-text">0x05 dispatch_group_async</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x06-dispatch-once"><span class="nav-number">9.</span> <span class="nav-text">0x06 dispatch_once</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x06-dispatch-group-create-amp-dispatch-semaphore-create"><span class="nav-number">10.</span> <span class="nav-text">0x06 dispatch_group_create &amp; dispatch_semaphore_create</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x07-dispatch-group-wait-amp-dispatch-semaphore-wait"><span class="nav-number">11.</span> <span class="nav-text">0x07 dispatch_group_wait &amp; dispatch_semaphore_wait</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x08-dispatch-group-notify"><span class="nav-number">12.</span> <span class="nav-text">0x08 dispatch_group_notify</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x09-dispatch-barrier-async"><span class="nav-number">13.</span> <span class="nav-text">0x09 dispatch_barrier_async</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x10-dispatch-get-global-queue"><span class="nav-number">14.</span> <span class="nav-text">0x10 dispatch_get_global_queue</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x11-结束语"><span class="nav-number">15.</span> <span class="nav-text">0x11 结束语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展阅读"><span class="nav-number">15.0.1.</span> <span class="nav-text">扩展阅读</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朝暮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
