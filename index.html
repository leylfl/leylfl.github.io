<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="联系方式：leylfl@foxmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="朝暮的闲暇时刻">
<meta property="og:url" content="https://leylfl.github.io/index.html">
<meta property="og:site_name" content="朝暮的闲暇时刻">
<meta property="og:description" content="联系方式：leylfl@foxmail.com">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="朝暮的闲暇时刻">
<meta name="twitter:description" content="联系方式：leylfl@foxmail.com">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://leylfl.github.io/"/>





  <title>朝暮的闲暇时刻</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">朝暮的闲暇时刻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/浅谈iOS多线程-源码/" itemprop="url">浅谈iOS多线程(源码)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T14:57:43+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-开篇"><a href="#0x01-开篇" class="headerlink" title="0x01 开篇"></a>0x01 开篇</h1><p>&emsp;&emsp;上一篇文章，我们对于常用的GCD使用方法大致理了一遍，那么在使用过程中，我们肯定有这样的疑问？队列是怎么被创建的？任务是怎么放进队列的？为什么会造成死锁？等等等问题，所以在这一篇文章里，我们会从源码的阅读过程中解答这些疑问。虽然网上也有很多讲解源码的文章，但文章对应的源码都不是最新的，这篇文章是根据最新源码来进行阅读的。<br>&emsp;&emsp;进入正题之前，我们需要做些准备工作。了解下常用的宏和常用的数据结构体。</p>
<h1 id="0x02-源码中常见的宏"><a href="#0x02-源码中常见的宏" class="headerlink" title="0x02 源码中常见的宏"></a>0x02 源码中常见的宏</h1><h3 id="1-builtin-expect"><a href="#1-builtin-expect" class="headerlink" title="1. __builtin_expect"></a>1. __builtin_expect</h3><p>&emsp;&emsp;这个其实是个函数，针对编译器优化的一个函数，后面几个宏是对这个函数的封装，所以提前拎出来说一下。写代码中我们经常会遇到条件判断语句<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(今天是工作日) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"好好上班"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"好好睡觉"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;CPU读取指令的时候并非一条一条的来读，而是多条一起加载进来，比如已经加载了if(今天是工作日) printf(“好好上班”);的指令，这时候条件式如果为非，也就是非工作日，那么CPU继续把printf(“好好睡觉”);这条指令加载进来，这样就造成了性能浪费的现象。<br>&emsp;&emsp;__builtin_expect的第一个参数是实际值，第二个参数是预测值。使用这个目的是告诉编译器if条件式是不是有更大的可能被满足。</p>
<h3 id="2-likely和unlikely"><a href="#2-likely和unlikely" class="headerlink" title="2. likely和unlikely"></a>2. likely和unlikely</h3><p>&emsp;&emsp;解开这个宏后其实是对__builtin_expect封装，likely表示更大可能成立，unlikely表示更大可能不成立。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x) __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-fastpath和slowpath"><a href="#3-fastpath和slowpath" class="headerlink" title="3. fastpath和slowpath"></a>3. fastpath和slowpath</h3><p>&emsp;&emsp;跟上面也是差不多的，fastpath表示更大可能成立，slowpath表示更大可能不成立<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) ((typeof(x))__builtin_expect(_safe_cast_to_long(x), ~0l))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) ((typeof(x))__builtin_expect(_safe_cast_to_long(x), 0l))</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-os-atomic-cmpxchg"><a href="#4-os-atomic-cmpxchg" class="headerlink" title="4. os_atomic_cmpxchg"></a>4. os_atomic_cmpxchg</h3><p>&emsp;&emsp;其内部就是atomic_compare_exchange_strong_explicit函数，这个函数的作用是：第二个参数与第一个参数值比较，如果相等，第三个参数的值替换第一个参数的值。如果不相等，把第一个参数的值赋值到第二个参数上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_cmpxchg(p, e, v, m) \</span></span><br><span class="line">        (&#123; _os_atomic_basetypeof(p) _r = (e); \</span><br><span class="line">        atomic_compare_exchange_strong_explicit(_os_atomic_c11_atomic(p), \</span><br><span class="line">        &amp;_r, v, memory_order_##m, memory_order_relaxed); &#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="5-os-atomic-store2o"><a href="#5-os-atomic-store2o" class="headerlink" title="5. os_atomic_store2o"></a>5. os_atomic_store2o</h3><p>&emsp;&emsp;将第二个参数，保存到第一个参数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_store2o(p, f, v, m)  os_atomic_store(&amp;(p)-&gt;f, (v), m)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_store(p, v, m) \</span></span><br><span class="line">        atomic_store_explicit(_os_atomic_c11_atomic(p), v, memory_order_##m)</span><br></pre></td></tr></table></figure></p>
<h3 id="6-os-atomic-inc-orig"><a href="#6-os-atomic-inc-orig" class="headerlink" title="6. os_atomic_inc_orig"></a>6. os_atomic_inc_orig</h3><p>&emsp;&emsp;将1保存到第一个参数中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_inc_orig(p, m)  os_atomic_add_orig((p), 1, m)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_add_orig(p, v, m) _os_atomic_c11_op_orig((p), (v), m, add, +)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _os_atomic_c11_op_orig(p, v, m, o, op) \</span></span><br><span class="line">        atomic_fetch_#<span class="meta">#o##_explicit(_os_atomic_c11_atomic(p), v, \</span></span><br><span class="line">        memory_order_#<span class="meta">#m)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="0x03-数据结构体"><a href="#0x03-数据结构体" class="headerlink" title="0x03 数据结构体"></a>0x03 数据结构体</h1><p>&emsp;&emsp;接着，了解一些常用数据结构体。</p>
<h3 id="1-dispatch-queue-t"><a href="#1-dispatch-queue-t" class="headerlink" title="1. dispatch_queue_t"></a>1. dispatch_queue_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们看下dispatch_queue_s怎么定义的。发现其内部有个_DISPATCH_QUEUE_HEADER宏定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    _DISPATCH_QUEUE_HEADER(<span class="built_in">queue</span>);</span><br><span class="line">    DISPATCH_QUEUE_CACHELINE_PADDING; </span><br><span class="line">&#125; DISPATCH_ATOMIC64_ALIGN;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;解开_DISPATCH_QUEUE_HEADER后发现又一个DISPATCH_OBJECT_HEADER宏定义，继续拆解<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_QUEUE_HEADER(x) \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">os_mpsc_queue_s</span> _<span class="title">as_oq</span>[0];</span> \</span><br><span class="line">    DISPATCH_OBJECT_HEADER(x); \</span><br><span class="line">    _OS_MPSC_QUEUE_FIELDS(dq, dq_state); \</span><br><span class="line">    <span class="keyword">uint32_t</span> dq_side_suspend_cnt; \</span><br><span class="line">    dispatch_unfair_lock_s dq_sidelock; \</span><br><span class="line">    <span class="keyword">union</span> &#123; \</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq_specific_q; \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_refs_s</span> *<span class="title">ds_refs</span>;</span> \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_source_refs_s</span> *<span class="title">ds_timer_refs</span>;</span> \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_recv_refs_s</span> *<span class="title">dm_recv_refs</span>;</span> \</span><br><span class="line">    &#125;; \</span><br><span class="line">    DISPATCH_UNION_LE(<span class="keyword">uint32_t</span> <span class="keyword">volatile</span> dq_atomic_flags, \</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint16_t</span> dq_width, \</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint16_t</span> __dq_opaque \</span><br><span class="line">    ); \</span><br><span class="line">    DISPATCH_INTROSPECTION_QUEUE_HEADER</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;还有一层宏_DISPATCH_OBJECT_HEADER<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_HEADER(x) \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> _<span class="title">as_do</span>[0];</span> \</span><br><span class="line">    _DISPATCH_OBJECT_HEADER(x)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;不熟悉##的作用的同学，这里先说明下这个作用就拼接成字符串，比如x为group的话，下面就会拼接为dispatch_group这样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_OBJECT_HEADER(x) \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> _<span class="title">as_os_obj</span>[0];</span> \</span><br><span class="line">    OS_OBJECT_STRUCT_HEADER(dispatch_##x); \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \</span><br><span class="line">    <span class="keyword">void</span> *do_ctxt; \</span><br><span class="line">    <span class="keyword">void</span> *do_finalizer</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;来到OS_OBJECT_STRUCT_HEADER之后，我们需要注意一个成员变量，记住这个成员变量名字叫做<strong>do_vtable</strong>。再继续拆解_OS_OBJECT_HEADER发现里面起就是一个isa指针和引用计数一些信息。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS_OBJECT_STRUCT_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER(\</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *_objc_isa, \</span><br><span class="line">    do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \</span><br><span class="line">    <span class="comment">// 注意这个成员变量，后面将任务Push到队列就是通过这个变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">x</span>##_<span class="title">vtable_s</span> *<span class="title">do_vtable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> _<span class="title">OS_OBJECT_HEADER</span>(<span class="title">isa</span>, <span class="title">ref_cnt</span>, <span class="title">xref_cnt</span>) \</span></span><br><span class="line"><span class="class">        <span class="title">isa</span>;</span> <span class="comment">/* must be pointer-sized */</span> \</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> ref_cnt; \</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> xref_cnt</span><br></pre></td></tr></table></figure></p>
<h3 id="2-dispatch-continuation-t"><a href="#2-dispatch-continuation-t" class="headerlink" title="2. dispatch_continuation_t"></a>2. dispatch_continuation_t</h3><p>&emsp;&emsp;说到这个结构体，如果没看过源码的话，肯定对这个结构体很陌生，因为对外的api里面没有跟continuation有关的。所以这里先说下这个结构体就是用来封装block对象的，保存block的上下文环境和block执行函数等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> _<span class="title">as_do</span>[0];</span></span><br><span class="line">    DISPATCH_CONTINUATION_HEADER(continuation);</span><br><span class="line">&#125; *<span class="keyword">dispatch_continuation_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;看下里面的宏DISPATCH_CONTINUATION_HEADER<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_CONTINUATION_HEADER(x) \</span></span><br><span class="line">    <span class="keyword">union</span> &#123; \</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *do_vtable; \</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_flags; \</span><br><span class="line">    &#125;; \</span><br><span class="line">    <span class="keyword">union</span> &#123; \</span><br><span class="line">        <span class="keyword">pthread_priority_t</span> dc_priority; \</span><br><span class="line">        <span class="keyword">int</span> dc_cache_cnt; \</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_pad; \</span><br><span class="line">    &#125;; \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">voucher_s</span> *<span class="title">dc_voucher</span>;</span> \</span><br><span class="line">    <span class="keyword">dispatch_function_t</span> dc_func; \</span><br><span class="line">    <span class="keyword">void</span> *dc_ctxt; \</span><br><span class="line">    <span class="keyword">void</span> *dc_data; \</span><br><span class="line">    <span class="keyword">void</span> *dc_other</span><br></pre></td></tr></table></figure></p>
<h3 id="3-dispatch-object-t"><a href="#3-dispatch-object-t" class="headerlink" title="3. dispatch_object_t"></a>3. dispatch_object_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *_<span class="title">dc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_attr_s</span> *_<span class="title">dsa</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_operation_s</span> *_<span class="title">doperation</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_disk_s</span> *_<span class="title">ddisk</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> DISPATCH_TRANSPARENT_UNION;</span><br></pre></td></tr></table></figure>
<h3 id="4-dispatch-function-t"><a href="#4-dispatch-function-t" class="headerlink" title="4. dispatch_function_t"></a>4. dispatch_function_t</h3><p>&emsp;&emsp;dispatch_function_t 只是一个函数指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">dispatch_function_t</span>)</span><span class="params">(<span class="keyword">void</span> *_Nullable)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，一些常用的宏和数据结构体介绍完毕，接下来，我们真正的要一起阅读GCD相关的源码了。</p>
<h1 id="0x03-创建队列"><a href="#0x03-创建队列" class="headerlink" title="0x03 创建队列"></a>0x03 创建队列</h1><p>&emsp;&emsp;首先我们先从创建队列讲起。我们已经很熟悉，创建队列的方法是调用dispatch_queue_create函数。</p>
<ul>
<li>其内部又调用了_dispatch_queue_create_with_target函数  </li>
<li>DISPATCH_TARGET_QUEUE_DEFAULT这个宏其实就是null<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span><br><span class="line">&#123;   <span class="comment">// attr一般我们都是传DISPATCH_QUEUE_SERIAL、DISPATCH_QUEUE_CONCURRENT或者nil</span></span><br><span class="line">    <span class="comment">// 而DISPATCH_QUEUE_SERIAL其实就是null</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_create_with_target(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;_dispatch_queue_create_with_target函数，这里会创建一个root队列,并将自己新建的队列绑定到所对应的root队列上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> _dispatch_queue_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;   <span class="comment">// 根据上文代码注释里提到的，作者认为调用者传入DISPATCH_QUEUE_SERIAL和nil的几率要大于传DISPATCH_QUEUE_CONCURRENT。所以这里设置个默认值。</span></span><br><span class="line">    <span class="comment">// 这里怎么理解呢？只要看做if(!dqa)即可</span></span><br><span class="line">    <span class="keyword">if</span> (!slowpath(dqa)) &#123;</span><br><span class="line">        <span class="comment">// _dispatch_get_default_queue_attr里面会将dqa的dqa_autorelease_frequency指定为DISPATCH_AUTORELEASE_FREQUENCY_INHERIT的，inactive也指定为false。这里就不展开了，只需要知道赋了哪些值。因为后面会用到。</span></span><br><span class="line">        dqa = _dispatch_get_default_queue_attr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;do_vtable != DISPATCH_VTABLE(queue_attr)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出优先级</span></span><br><span class="line">    <span class="keyword">dispatch_qos_t</span> qos = _dispatch_priority_qos(dqa-&gt;dqa_qos_and_relpri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overcommit单纯从英文理解表示过量使用的意思，那这里这个overcommit就是一个标识符，表示是不是就算负荷很高了，但还是得给我新开一个线程出来给我执行任务。</span></span><br><span class="line">    <span class="keyword">_dispatch_queue_attr_overcommit_t</span> overcommit = dqa-&gt;dqa_overcommit;</span><br><span class="line">    <span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(tq, <span class="string">"Cannot specify both overcommit and "</span></span><br><span class="line">                    <span class="string">"a non-global target queue"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果overcommit没有被指定</span></span><br><span class="line">    <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">         <span class="comment">// 所以对于overcommit，如果是串行的话默认是开启的，而并行是关闭的</span></span><br><span class="line">        overcommit = dqa-&gt;dqa_concurrent ?</span><br><span class="line">                _dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">                _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前说过初始化队列默认传了DISPATCH_TARGET_QUEUE_DEFAULT，也就是null，所以进入if语句。</span></span><br><span class="line">    <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">        <span class="comment">// 获取一个管理自己队列的root队列。</span></span><br><span class="line">        tq = _dispatch_get_root_queue(</span><br><span class="line">                qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos,</span><br><span class="line">                overcommit == _dispatch_queue_attr_overcommit_enabled);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!tq)) &#123;</span><br><span class="line">            DISPATCH_CLIENT_CRASH(qos, <span class="string">"Invalid queue attribute"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// legacy默认是true的</span></span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        <span class="comment">// 之前说过，默认是会给dqa_autorelease_frequency指定为DISPATCH_AUTORELEASE_FREQUENCY_INHERIT，所以这个判断式是成立的</span></span><br><span class="line">        <span class="keyword">if</span> (dqa-&gt;dqa_inactive || dqa-&gt;dqa_autorelease_frequency) &#123;</span><br><span class="line">            legacy = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vtable变量很重要，之后会被赋值到之前说的dispatch_queue_t结构体里的do_vtable变量上</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">    <span class="keyword">dispatch_queue_flags_t</span> dqf = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// legacy变为false了</span></span><br><span class="line">    <span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">        vtable = DISPATCH_VTABLE(<span class="built_in">queue</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dqa-&gt;dqa_concurrent) &#123;</span><br><span class="line">        <span class="comment">// 如果创建队列的时候传了DISPATCH_QUEUE_CONCURRENT，就是走这里</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果创建线程没有指定为并行队列，无论你传DISPATCH_QUEUE_SERIAL还是nil，都会创建一个串行队列。</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (label) &#123;</span><br><span class="line">        <span class="comment">// 判断传进来的字符串是否可变的，如果可变的copy成一份不可变的</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">        <span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">            dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">            label = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _dispatch_object_alloc里面就将vtable赋值给do_vtable变量上了。</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">    <span class="comment">// 第三个参数根据是否并行队列，如果不是则最多开一个线程，如果是则最多开0x1000 - 2个线程，这个数量很惊人了已经,换成十进制就是（4096 - 2）个。</span></span><br><span class="line">    <span class="comment">// dqa_inactive之前说串行是false的</span></span><br><span class="line">    <span class="comment">// DISPATCH_QUEUE_ROLE_INNER 也是0，所以这里串行队列的话dqa-&gt;dqa_state是0</span></span><br><span class="line">    _dispatch_queue_init(dq, dqf, dqa-&gt;dqa_concurrent ?</span><br><span class="line">            DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">            (dqa-&gt;dqa_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    dq-&gt;dq_label = label;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    dq-&gt;dq_priority = dqa-&gt;dqa_qos_and_relpri;</span><br><span class="line">    <span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">        dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    _dispatch_retain(tq);</span><br><span class="line">    <span class="keyword">if</span> (qos == QOS_CLASS_UNSPECIFIED) &#123;</span><br><span class="line">        _dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dqa-&gt;dqa_inactive) &#123;</span><br><span class="line">        _dispatch_queue_inherit_wlh_from_target(dq, tq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义的queue的目标队列是root队列</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    _dispatch_object_debug(dq, <span class="string">"%s"</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个函数里面还是有几个重要的地方拆出来看下，首先是创建一个root队列_dispatch_get_root_queue函数。取root队列，一般是从一个装有12个root队列数组里面取。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_t</span></span><br><span class="line">_dispatch_get_root_queue(<span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(qos == DISPATCH_QOS_UNSPECIFIED || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(qos, <span class="string">"Corrupted priority"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span> * (qos - <span class="number">1</span>) + overcommit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;看下这个_dispatch_root_queues数组。我们可以看到，每一个优先级都有对应的root队列，每一个优先级又分为是不是可以过载的队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_root_queues</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_IDX(n, flags) \</span></span><br><span class="line">    ((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \</span><br><span class="line">        DISPATCH_ROOT_QUEUE_IDX_##n##_QOS_OVERCOMMIT : \</span><br><span class="line">        DISPATCH_ROOT_QUEUE_IDX_##n##_QOS)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \</span></span><br><span class="line">    [_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \</span><br><span class="line">        DISPATCH_GLOBAL_OBJECT_HEADER(queue_root), \</span><br><span class="line">        .dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \</span><br><span class="line">        .do_ctxt = &amp;_dispatch_root_queue_contexts[ \</span><br><span class="line">                _DISPATCH_ROOT_QUEUE_IDX(n, flags)], \</span><br><span class="line">        .dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \</span><br><span class="line">        .dq_priority = _dispatch_priority_make(DISPATCH_QOS_##n, <span class="number">0</span>) | flags | \</span><br><span class="line">                DISPATCH_PRIORITY_FLAG_ROOTQUEUE | \</span><br><span class="line">                ((flags &amp; DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE) ? <span class="number">0</span> : \</span><br><span class="line">                DISPATCH_QOS_##n &lt;&lt; DISPATCH_PRIORITY_OVERRIDE_SHIFT), \</span><br><span class="line">        __VA_ARGS__ \</span><br><span class="line">    &#125;</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.maintenance-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">4</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.maintenance-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">5</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.background-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">6</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.background-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">7</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.utility-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">8</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.utility-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">9</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.default-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">10</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span><br><span class="line">            DISPATCH_PRIORITY_FLAG_DEFAULTQUEUE | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.default-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">11</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.user-initiated-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">12</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.user-initiated-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">13</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, <span class="number">0</span>,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.user-interactive-qos"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">14</span>,</span><br><span class="line">    ),</span><br><span class="line">    _DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">        .dq_label = <span class="string">"com.apple.root.user-interactive-qos.overcommit"</span>,</span><br><span class="line">        .dq_serialnum = <span class="number">15</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其中DISPATCH_GLOBAL_OBJECT_HEADER(queue_root)，解析到最后是OS<em>dispatch</em>##name##_class这样的这样的，对应的实例对象是如下代码，指定了root队列各个操作对应的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_root, <span class="built_in">queue</span>,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_GLOBAL_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">"global-queue"</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose,</span><br><span class="line">    .do_push = _dispatch_root_queue_push,</span><br><span class="line">    .do_invoke = <span class="literal">NULL</span>,</span><br><span class="line">    .do_wakeup = _dispatch_root_queue_wakeup,</span><br><span class="line">    .do_debug = dispatch_queue_debug,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其次看下DISPATCH_VTABLE这个宏，这个宏很重要。最后解封也是&amp;OS<em>dispatch</em>##name##_class这样的。其实就是取dispatch_object_t对象。<br>&emsp;&emsp;如下代码，这里再举个VTABLE的串行对象，里面有各个状态该执行的函数：销毁函、挂起、恢复、push等函数都是在这里指定的。所以这里的do_push我们需要特别留意，后面push block任务到队列，就是通过调用do_push。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_VTABLE_SUBCLASS_INSTANCE(queue_serial, <span class="built_in">queue</span>,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_SERIAL_TYPE,</span><br><span class="line">    .do_kind = <span class="string">"serial-queue"</span>,</span><br><span class="line">    .do_dispose = _dispatch_queue_dispose,</span><br><span class="line">    .do_suspend = _dispatch_queue_suspend,</span><br><span class="line">    .do_resume = _dispatch_queue_resume,</span><br><span class="line">    .do_finalize_activation = _dispatch_queue_finalize_activation,</span><br><span class="line">    .do_push = _dispatch_queue_push,</span><br><span class="line">    .do_invoke = _dispatch_queue_invoke,</span><br><span class="line">    .do_wakeup = _dispatch_queue_wakeup,</span><br><span class="line">    .do_debug = dispatch_queue_debug,</span><br><span class="line">    .do_set_targetq = _dispatch_queue_set_target_queue,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;继续看下_dispatch_object_alloc和_dispatch_queue_init两个函数，首先看下_dispatch_object_alloc函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * _dispatch_object_alloc(<span class="keyword">const</span> <span class="keyword">void</span> *vtable, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// OS_OBJECT_HAVE_OBJC1为1的满足式是：</span></span><br><span class="line"><span class="comment">// #if TARGET_OS_MAC &amp;&amp; !TARGET_OS_SIMULATOR &amp;&amp; defined(__i386__)</span></span><br><span class="line"><span class="comment">// 所以对于iOS并不满足</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_OBJECT_HAVE_OBJC1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_vtable_s</span> *_<span class="title">vtable</span> = <span class="title">vtable</span>;</span></span><br><span class="line">    <span class="keyword">dispatch_object_t</span> dou;</span><br><span class="line">    dou._os_obj = _os_object_alloc_realized(_vtable-&gt;_os_obj_objc_isa, size);</span><br><span class="line">    dou._do-&gt;do_vtable = vtable;</span><br><span class="line">    <span class="keyword">return</span> dou._do;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> _os_object_alloc_realized(vtable, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">_os_object_t</span> _os_object_alloc_realized(<span class="keyword">const</span> <span class="keyword">void</span> *cls, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">_os_object_t</span> obj;</span><br><span class="line">    dispatch_assert(size &gt;= <span class="keyword">sizeof</span>(struct _os_object_s));</span><br><span class="line">    <span class="keyword">while</span> (!fastpath(obj = <span class="built_in">calloc</span>(<span class="number">1u</span>, size))) &#123;</span><br><span class="line">        _dispatch_temporary_resource_shortage();</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;os_obj_isa = cls;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_temporary_resource_shortage(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);  <span class="comment">// prevent tailcall</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再看下_dispatch_queue_init函数，这里也就是做些初始化工作了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_init(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">        <span class="keyword">uint16_t</span> width, <span class="keyword">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br><span class="line"></span><br><span class="line">    dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">            DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">        dq_state |= DISPATCH_QUEUE_INACTIVE + DISPATCH_QUEUE_NEEDS_ACTIVATION;</span><br><span class="line">        dq_state |= DLOCK_OWNER_MASK;</span><br><span class="line">        dq-&gt;do_ref_cnt += <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dq_state |= (initial_state_bits &amp; DISPATCH_QUEUE_ROLE_MASK);</span><br><span class="line">    <span class="comment">// 指向DISPATCH_OBJECT_LISTLESS是优化编译器的作用。只是为了生成更好的指令让CPU更好的编码</span></span><br><span class="line">    dq-&gt;do_next = (struct dispatch_queue_s *)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dqf |= DQF_WIDTH(width);</span><br><span class="line">    <span class="comment">// dqf 保存进 dq-&gt;dq_atomic_flags</span></span><br><span class="line">    os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">    dq-&gt;dq_state = dq_state;</span><br><span class="line">    dq-&gt;dq_serialnum =</span><br><span class="line">            os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后是_dispatch_introspection_queue_create函数，一个内省函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> _dispatch_introspection_queue_create(<span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    TAILQ_INIT(&amp;dq-&gt;diq_order_top_head);</span><br><span class="line">    TAILQ_INIT(&amp;dq-&gt;diq_order_bottom_head);</span><br><span class="line">    _dispatch_unfair_lock_lock(&amp;_dispatch_introspection.queues_lock);</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;_dispatch_introspection.queues, dq, diq_list);</span><br><span class="line">    _dispatch_unfair_lock_unlock(&amp;_dispatch_introspection.queues_lock);</span><br><span class="line"></span><br><span class="line">    DISPATCH_INTROSPECTION_INTERPOSABLE_HOOK_CALLOUT(queue_create, dq);</span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_INTROSPECTION_HOOK_ENABLED(queue_create)) &#123;</span><br><span class="line">        _dispatch_introspection_queue_create_hook(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，一个队列的创建过程我们大致了解了。大致可以分为这么几点</p>
<ul>
<li>设置队列优先级</li>
<li>默认创建的是一个串行队列</li>
<li>设置队列挂载的根队列。优先级不同根队列也不同</li>
<li>实例化vtable对象，这个对象给不同队列指定了push、wakeup等函数。</li>
</ul>
<h1 id="0x04-dispatch-sync"><a href="#0x04-dispatch-sync" class="headerlink" title="0x04 dispatch_sync"></a>0x04 dispatch_sync</h1><p>&emsp;&emsp;dispatch_sync直接调用的是dispatch_sync_f<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 很大可能不会走if分支，看做if(_dispatch_block_has_private_data(work))</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_block_with_private_data(dq, work, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_sync_f(dq, work, _dispatch_Block_invoke(work));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 串行队列会走到这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch_barrier_sync_f(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局获取的并行队列或者绑定的是非调度线程的队列会走进这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dq))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_introspection_sync_begin(dq);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义并行队列会来到这个函数</span></span><br><span class="line">    _dispatch_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;先说第一种情况，串行队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列绑定的是非调度线程就会走这里</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dq, tid))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_introspection_sync_begin(dq);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_recurse(dq, ctxt, func, DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般会走到这里</span></span><br><span class="line">    _dispatch_queue_barrier_sync_invoke_and_complete(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_queue_barrier_sync_invoke_and_complete(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先会执行这个函数</span></span><br><span class="line">    _dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">    <span class="comment">// 如果后面还有别的任务</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dq-&gt;dq_items_tail || dq-&gt;dq_width &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 内部其实就是唤醒队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_barrier_complete(dq, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> fail_unlock_mask = DISPATCH_QUEUE_SUSPEND_BITS_MASK |</span><br><span class="line">            DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_DIRTY |</span><br><span class="line">            DISPATCH_QUEUE_RECEIVED_OVERRIDE | DISPATCH_QUEUE_SYNC_TRANSFER |</span><br><span class="line">            DISPATCH_QUEUE_RECEIVED_SYNC_WAIT;</span><br><span class="line">    <span class="keyword">uint64_t</span> old_state, new_state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子锁。检查dq-&gt;dq_state与old_state是否相等，如果相等把new_state赋值给dq-&gt;dq_state，如果不相等，把dq_state赋值给old_state。</span></span><br><span class="line">    <span class="comment">// 串行队列走到这里，dq-&gt;dq_state与old_state是相等的，会把new_state也就是闭包里的赋值的值给dq-&gt;dq_state</span></span><br><span class="line">    os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">        new_state  = old_state - DISPATCH_QUEUE_SERIAL_DRAIN_OWNED;</span><br><span class="line">        new_state &amp;= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;</span><br><span class="line">        new_state &amp;= ~DISPATCH_QUEUE_MAX_QOS_MASK;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(old_state &amp; fail_unlock_mask)) &#123;</span><br><span class="line">            os_atomic_rmw_loop_give_up(&#123;</span><br><span class="line">                <span class="keyword">return</span> _dispatch_queue_barrier_complete(dq, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (_dq_state_is_base_wlh(old_state)) &#123;</span><br><span class="line">        _dispatch_event_loop_assert_not_owned((<span class="keyword">dispatch_wlh_t</span>)dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保护现场 -&gt; 调用函数 -&gt; 恢复现场</span></span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;然后另一种情况，自定义并行队列会走_dispatch_sync_invoke_and_complete函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_sync_invoke_and_complete(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">    <span class="comment">// 将自定义队列加入到root队列里去</span></span><br><span class="line">    <span class="comment">// dispatch_async也会调用此方法，之前我们初始化的时候会绑定一个root队列，这里就将我们新建的队列交给root队列进行管理</span></span><br><span class="line">    _dispatch_queue_non_barrier_complete(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x05-dispatch-async"><a href="#0x05-dispatch-async" class="headerlink" title="0x05 dispatch_async"></a>0x05 dispatch_async</h1><p>&emsp;&emsp;内部就是两个函数_dispatch_continuation_init和_dispatch_continuation_async<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="comment">// 设置标识位</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> dc_flags = DISPATCH_OBJ_CONSUME_BIT;</span><br><span class="line"></span><br><span class="line">    _dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">    _dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;_dispatch_continuation_init函数只是一个初始化，主要就是保存Block上下文，指定block的执行函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_init(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_block_t</span> work,</span><br><span class="line">        <span class="keyword">pthread_priority_t</span> pp, <span class="keyword">dispatch_block_flags_t</span> flags, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    dc-&gt;dc_flags = dc_flags | DISPATCH_OBJ_BLOCK_BIT;</span><br><span class="line">    <span class="comment">// block对象赋值到dc_ctxt</span></span><br><span class="line">    dc-&gt;dc_ctxt = _dispatch_Block_copy(work);</span><br><span class="line">    <span class="comment">// 设置默认任务优先级</span></span><br><span class="line">    _dispatch_continuation_priority_set(dc, pp, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大多数情况不会走这个分支</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_init_slow(dc, dqu, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个标识位多眼熟，就是前面入口赋值的，没的跑了，指定执行函数就是_dispatch_call_block_and_release了</span></span><br><span class="line">    <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">        dc-&gt;dc_func = _dispatch_call_block_and_release;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc-&gt;dc_func = _dispatch_Block_invoke(work);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_continuation_voucher_set(dc, dqu, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;_dispatch_call_block_and_release这个函数就是直接执行block了，所以dc-&gt;dc_func被调用的话就block会被直接执行了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_call_block_and_release(<span class="keyword">void</span> *block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (^b)(<span class="keyword">void</span>) = block;</span><br><span class="line">    b();</span><br><span class="line">    Block_release(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的初始化过程就是这样，接着看下_dispatch_continuation_async函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_continuation_async(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 看看是不是barrier类型的block</span></span><br><span class="line">    _dispatch_continuation_async2(dq, dc,</span><br><span class="line">            dc-&gt;dc_flags &amp; DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果是用barrier插进来的任务或者是串行队列，直接将任务加入到队列</span></span><br><span class="line">    <span class="comment">// #define DISPATCH_QUEUE_USES_REDIRECTION(width) \</span></span><br><span class="line">        (&#123; <span class="keyword">uint16_t</span> _width = (width); \</span><br><span class="line">        _width &gt; <span class="number">1</span> &amp;&amp; _width &lt; DISPATCH_QUEUE_WIDTH_POOL; &#125;) </span><br><span class="line">    <span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以先看下如果是barrier任务，直接调用_dispatch_continuation_push函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_continuation_push(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    dx_push(dq, dc, _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_async_f2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果还有任务，slowpath表示很大可能队尾是没有任务的。</span></span><br><span class="line">    <span class="comment">// 实际开发中也的确如此，一般情况下我们不会dispatch_async之后又马上跟着一个dispatch_async</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(dq-&gt;dq_items_tail)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!_dispatch_queue_try_acquire_async(dq))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般会直接来到这里，_dispatch_continuation_override_qos函数里面主要做的是判断dq有没有设置的优先级，如果没有就用block对象的优先级，如果有就用自己的</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_async_f_redirect(dq, dc,</span><br><span class="line">            _dispatch_continuation_override_qos(dq, dc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_async_f_redirect(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里会走进if的语句，因为_dispatch_object_is_redirection内部的dx_type(dou._do) == type条件为否</span></span><br><span class="line">    <span class="keyword">if</span> (!slowpath(_dispatch_object_is_redirection(dou))) &#123;</span><br><span class="line">        dou._dc = _dispatch_async_redirect_wrap(dq, dou);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dq换成所绑定的root队列</span></span><br><span class="line">    dq = dq-&gt;do_targetq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本不会走里面的循环，主要做的就是找到根root队列</span></span><br><span class="line">    <span class="keyword">while</span> (slowpath(DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fastpath(_dispatch_queue_try_acquire_async(dq))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dou._dc-&gt;dc_ctxt) &#123;</span><br><span class="line">            dou._dc-&gt;dc_ctxt = (<span class="keyword">void</span> *)</span><br><span class="line">                    (<span class="keyword">uintptr_t</span>)_dispatch_queue_autorelease_frequency(dq);</span><br><span class="line">        &#125;</span><br><span class="line">        dq = dq-&gt;do_targetq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把装有block信息的结构体装进所在队列对应的root_queue里面</span></span><br><span class="line">    dx_push(dq, dou, qos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dx_push是个宏定义，这里做的就是将任务push到任务队列，我们看到这里，就知道dx_push就是调用对象的do_push。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_push(x, y, z) dx_vtable(x)-&gt;do_push(x, y, z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_vtable(x) (&amp;(x)-&gt;do_vtable-&gt;_os_obj_vtable)</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;_dispatch_async_f_redirect函数里先看这句dou._dc = _dispatch_async_redirect_wrap(dq, dou);<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_continuation_t</span> _dispatch_async_redirect_wrap(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> dou)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line"></span><br><span class="line">    dou._do-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 所以dispatch_async推进的任务的do_vtable成员变量是有值的</span></span><br><span class="line">    dc-&gt;do_vtable = DC_VTABLE(ASYNC_REDIRECT);</span><br><span class="line">    dc-&gt;dc_func = <span class="literal">NULL</span>;</span><br><span class="line">    dc-&gt;dc_ctxt = (<span class="keyword">void</span> *)(<span class="keyword">uintptr_t</span>)_dispatch_queue_autorelease_frequency(dq);</span><br><span class="line">    <span class="comment">// 所属队列被装进dou._dc-&gt;dc_data里面了</span></span><br><span class="line">    dc-&gt;dc_data = dq;</span><br><span class="line">    dc-&gt;dc_other = dou._do;</span><br><span class="line">    dc-&gt;dc_voucher = DISPATCH_NO_VOUCHER;</span><br><span class="line">    dc-&gt;dc_priority = DISPATCH_NO_PRIORITY;</span><br><span class="line">    _dispatch_retain(dq); <span class="comment">// released in _dispatch_async_redirect_invoke</span></span><br><span class="line">    <span class="keyword">return</span> dc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dc-&gt;do_vtable = DC_VTABLE(ASYNC_REDIRECT); 就是下面指定redirect的invoke函数是_dispatch_async_redirect_invoke，后面任务被执行就是通过这个函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_vtable_s</span> _<span class="title">dispatch_continuation_vtables</span>[] = &#123;</span></span><br><span class="line">    DC_VTABLE_ENTRY(ASYNC_REDIRECT,</span><br><span class="line">        .do_kind = <span class="string">"dc-redirect"</span>,</span><br><span class="line">        .do_invoke = _dispatch_async_redirect_invoke),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_MACH</span></span><br><span class="line">    DC_VTABLE_ENTRY(MACH_SEND_BARRRIER_DRAIN,</span><br><span class="line">        .do_kind = <span class="string">"dc-mach-send-drain"</span>,</span><br><span class="line">        .do_invoke = _dispatch_mach_send_barrier_drain_invoke),</span><br><span class="line">    DC_VTABLE_ENTRY(MACH_SEND_BARRIER,</span><br><span class="line">        .do_kind = <span class="string">"dc-mach-send-barrier"</span>,</span><br><span class="line">        .do_invoke = _dispatch_mach_barrier_invoke),</span><br><span class="line">    DC_VTABLE_ENTRY(MACH_RECV_BARRIER,</span><br><span class="line">        .do_kind = <span class="string">"dc-mach-recv-barrier"</span>,</span><br><span class="line">        .do_invoke = _dispatch_mach_barrier_invoke),</span><br><span class="line">    DC_VTABLE_ENTRY(MACH_ASYNC_REPLY,</span><br><span class="line">        .do_kind = <span class="string">"dc-mach-async-reply"</span>,</span><br><span class="line">        .do_invoke = _dispatch_mach_msg_async_reply_invoke),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    DC_VTABLE_ENTRY(OVERRIDE_STEALING,</span><br><span class="line">        .do_kind = <span class="string">"dc-override-stealing"</span>,</span><br><span class="line">        .do_invoke = _dispatch_queue_override_invoke),</span><br><span class="line">    <span class="comment">// 留意这个，后面也会被用到</span></span><br><span class="line">    DC_VTABLE_ENTRY(OVERRIDE_OWNING,</span><br><span class="line">        .do_kind = <span class="string">"dc-override-owning"</span>,</span><br><span class="line">        .do_invoke = _dispatch_queue_override_invoke),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再看dx_push(dq, dou, qos);这句，其实就是调用_dispatch_root_queue_push函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_root_queue_push(<span class="keyword">dispatch_queue_t</span> rq, <span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一般情况下，无论自定义还是非自定义都会走进这个条件式(比如：dispatch_get_global_queue)</span></span><br><span class="line">    <span class="comment">// 里面主要对比的是qos与root队列的qos是否一致。基本上都不一致的，如果不一致走进这个if语句</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_root_queue_push_needs_override(rq, qos)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_root_queue_push_override(rq, dou, qos);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dou, dou, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_push_override(<span class="keyword">dispatch_queue_t</span> orig_rq,</span><br><span class="line">        <span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> overcommit = orig_rq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> rq = _dispatch_get_root_queue(qos, overcommit);</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc;</span><br><span class="line">    <span class="comment">// 这个_dispatch_object_is_redirection函数其实就是return _dispatch_object_has_type(dou,DISPATCH_CONTINUATION_TYPE(ASYNC_REDIRECT));</span></span><br><span class="line">    <span class="comment">// 所以自定义队列会走这个if语句，如果是dispatch_get_global_queue不会走if语句</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_is_redirection(dc)) &#123;</span><br><span class="line">        dc-&gt;dc_func = (<span class="keyword">void</span> *)orig_rq;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dispatch_get_global_queue来到这里</span></span><br><span class="line">        dc = _dispatch_continuation_alloc();</span><br><span class="line">        <span class="comment">// 相当于是下面的，也就是指定了执行函数为_dispatch_queue_override_invoke，所以有别于自定义队列的invoke函数。</span></span><br><span class="line">        <span class="comment">// DC_VTABLE_ENTRY(OVERRIDE_OWNING,</span></span><br><span class="line">        <span class="comment">// .do_kind = "dc-override-owning",</span></span><br><span class="line">        <span class="comment">// .do_invoke = _dispatch_queue_override_invoke),</span></span><br><span class="line">        dc-&gt;do_vtable = DC_VTABLE(OVERRIDE_OWNING);</span><br><span class="line">        _dispatch_trace_continuation_push(orig_rq, dou);</span><br><span class="line">        dc-&gt;dc_ctxt = dc;</span><br><span class="line">        dc-&gt;dc_other = orig_rq;</span><br><span class="line">        dc-&gt;dc_data = dou._do;</span><br><span class="line">        dc-&gt;dc_priority = DISPATCH_NO_PRIORITY;</span><br><span class="line">        dc-&gt;dc_voucher = DISPATCH_NO_VOUCHER;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dc, dc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_root_queue_push_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _head,</span><br><span class="line">        <span class="keyword">dispatch_object_t</span> _tail, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">head</span> = _<span class="title">head</span>._<span class="title">do</span>, *<span class="title">tail</span> = _<span class="title">tail</span>._<span class="title">do</span>;</span></span><br><span class="line">    <span class="comment">// 把任务装进队列，大多数不走进if语句。但是第一个任务进来之前还是满足这个条件式的，会进入这个条件语句去激活队列来执行里面的任务，后面再加入的任务因为队列被激活了，所以也就不太需要再进入这个队列了，所以相对来说激活队列只要一次，所以作者认为大多数情况下不需要走进这个条件语句</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_queue_push_update_tail_list(dq, head, tail))) &#123;</span><br><span class="line">        <span class="comment">// 保存队列头</span></span><br><span class="line">        _dispatch_queue_push_update_head(dq, head);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_global_queue_poke(dq, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，我们可以看到，我们装入到自定义的任务都被扔到其挂靠的root队列里去了，所以我们我们自己创建的队列只是一个代理人身份，真正的管理人是其对应的root队列，但同时这个队列也是被管理的。<br>&emsp;&emsp;继续看_dispatch_global_queue_poke函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_global_queue_poke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_global_queue_poke_slow(dq, n, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;继续看_dispatch_global_queue_poke函数调用了_dispatch_global_queue_poke_slow函数，里面执行_pthread_workqueue_addthreads函数，把任务交给内核分发处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_global_queue_poke_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_root_queue_context_t</span> qc = dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">int</span> remaining = n;</span><br><span class="line">    <span class="keyword">int</span> r = ENOSYS;</span><br><span class="line"></span><br><span class="line">    _dispatch_root_queues_init();</span><br><span class="line">    _dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">    <span class="keyword">if</span> (qc-&gt;dgq_kworkqueue != (<span class="keyword">void</span>*)(~<span class="number">0u</span>l))</span><br><span class="line">    &#123;</span><br><span class="line">        r = _pthread_workqueue_addthreads(remaining,</span><br><span class="line">                _dispatch_priority_to_pp(dq-&gt;dq_priority));</span><br><span class="line">        (<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_pthread_workqueue_addthreads(<span class="keyword">int</span> numthreads, <span class="keyword">pthread_priority_t</span> priority)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__libdispatch_workerfunction == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EPERM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((__pthread_supported_features &amp; PTHREAD_FEATURE_FINEPRIO) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ENOTSUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = __workq_kernreturn(WQOPS_QUEUE_REQTHREADS, <span class="literal">NULL</span>, numthreads, (<span class="keyword">int</span>)priority);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">        res = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么，加入到根队列的任务是怎么被运行起来的？在此之前，我们先模拟一下在GCD内部把程序搞挂掉，这样我们就可以追溯下调用栈关系。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    <span class="number">0</span>   CoreFoundation                      <span class="number">0x00000001093fe12b</span> __exceptionPreprocess + <span class="number">171</span></span><br><span class="line">    <span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x0000000108a92f41</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line">    <span class="number">2</span>   CoreFoundation                      <span class="number">0x000000010943e0cc</span> _CFThrowFormattedException + <span class="number">194</span></span><br><span class="line">    <span class="number">3</span>   CoreFoundation                      <span class="number">0x000000010930c23d</span> -[__NSPlaceholderArray initWithObjects:count:] + <span class="number">237</span></span><br><span class="line">    <span class="number">4</span>   CoreFoundation                      <span class="number">0x0000000109312e34</span> +[<span class="built_in">NSArray</span> arrayWithObjects:count:] + <span class="number">52</span></span><br><span class="line">    <span class="number">5</span>   HotPatch                            <span class="number">0x000000010769df77</span> __29-[ViewController viewDidLoad]_block_invoke + <span class="number">87</span></span><br><span class="line">    <span class="number">6</span>   libdispatch.dylib                   <span class="number">0x000000010c0a62f7</span> _dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line">    <span class="number">7</span>   libdispatch.dylib                   <span class="number">0x000000010c0a733d</span> _dispatch_client_callout + <span class="number">8</span></span><br><span class="line">    <span class="number">8</span>   libdispatch.dylib                   <span class="number">0x000000010c0ad754</span> _dispatch_continuation_pop + <span class="number">967</span></span><br><span class="line">    <span class="number">9</span>   libdispatch.dylib                   <span class="number">0x000000010c0abb85</span> _dispatch_async_redirect_invoke + <span class="number">780</span></span><br><span class="line">    <span class="number">10</span>  libdispatch.dylib                   <span class="number">0x000000010c0b3102</span> _dispatch_root_queue_drain + <span class="number">772</span></span><br><span class="line">    <span class="number">11</span>  libdispatch.dylib                   <span class="number">0x000000010c0b2da0</span> _dispatch_worker_thread3 + <span class="number">132</span></span><br><span class="line">    <span class="number">12</span>  libsystem_pthread.dylib             <span class="number">0x000000010c5f95a2</span> _pthread_wqthread + <span class="number">1299</span></span><br><span class="line">    <span class="number">13</span>  libsystem_pthread.dylib             <span class="number">0x000000010c5f907d</span> </span><br><span class="line">    start_wqthread + <span class="number">13</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;很明显，我们已经看到加入到队列的任务的调用关系是：<br>start_wqthread -&gt; _pthread_wqthread -&gt; _dispatch_worker_thread3 -&gt; _dispatch_root_queue_drain -&gt; _dispatch_async_redirect_invoke -&gt; _dispatch_continuation_pop -&gt; _dispatch_client_callout -&gt; _dispatch_call_block_and_release<br>&emsp;&emsp;只看调用关系也不知道里面做了什么，所以还是上代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据优先级取出相应的root队列，再调用_dispatch_worker_thread4函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_worker_thread3(<span class="keyword">pthread_priority_t</span> pp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> overcommit = pp &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq;</span><br><span class="line">    pp &amp;= _PTHREAD_PRIORITY_OVERCOMMIT_FLAG | ~_PTHREAD_PRIORITY_FLAGS_MASK;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_priority_key, (<span class="keyword">void</span> *)(<span class="keyword">uintptr_t</span>)pp);</span><br><span class="line">    dq = _dispatch_get_root_queue(_dispatch_qos_from_pp(pp), overcommit);</span><br><span class="line">    <span class="keyword">return</span> _dispatch_worker_thread4(dq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始调用_dispatch_root_queue_drain函数，取出任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_worker_thread4(<span class="keyword">void</span> *context)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = context;</span><br><span class="line">    <span class="keyword">dispatch_root_queue_context_t</span> qc = dq-&gt;do_ctxt;</span><br><span class="line"></span><br><span class="line">    _dispatch_introspection_thread_add();</span><br><span class="line">    <span class="keyword">int</span> pending = os_atomic_dec2o(qc, dgq_pending, relaxed);</span><br><span class="line">    dispatch_assert(pending &gt;= <span class="number">0</span>);</span><br><span class="line">    _dispatch_root_queue_drain(dq, _dispatch_get_priority());</span><br><span class="line">    _dispatch_voucher_debug(<span class="string">"root queue clear"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    _dispatch_reset_voucher(<span class="literal">NULL</span>, DISPATCH_THREAD_PARK);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">pthread_priority_t</span> pp)</span><br><span class="line">&#123;</span><br><span class="line">        _dispatch_queue_set_current(dq);</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> pri = dq-&gt;dq_priority;</span><br><span class="line">    <span class="keyword">if</span> (!pri) pri = _dispatch_priority_from_pp(pp);</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dbp = _dispatch_set_basepri(pri);</span><br><span class="line">    _dispatch_adopt_wlh_anon();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> reset = <span class="literal">false</span>;</span><br><span class="line">    dispatch_invoke_context_s dic = &#123; &#125;;</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags = DISPATCH_INVOKE_WORKER_DRAIN |</span><br><span class="line">            DISPATCH_INVOKE_REDIRECTING_DRAIN;</span><br><span class="line">    _dispatch_queue_drain_init_narrowing_check_deadline(&amp;dic, pri);</span><br><span class="line">    _dispatch_perfmon_start();</span><br><span class="line">    <span class="keyword">while</span> ((item = fastpath(_dispatch_root_queue_drain_one(dq)))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reset) _dispatch_wqthread_override_reset();</span><br><span class="line">        _dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line">        reset = _dispatch_reset_basepri_override();</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(&amp;dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overcommit or not. worker thread</span></span><br><span class="line">    <span class="keyword">if</span> (pri &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG) &#123;</span><br><span class="line">        _dispatch_perfmon_end(perfmon_thread_worker_oc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_perfmon_end(perfmon_thread_worker_non_oc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_reset_wlh();</span><br><span class="line">    _dispatch_reset_basepri(old_dbp);</span><br><span class="line">    _dispatch_reset_basepri_override();</span><br><span class="line">    _dispatch_queue_set_current(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">    _dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前说过dispatch_async是有do_vtable成员变量的，所以会走进这个if分支，又invoke方法指定为_dispatch_async_redirect_invoke，所以执行该函数</span></span><br><span class="line">    <span class="comment">// 相同的，如果是dispatch_get_global_queue也会走这个分支，执行_dispatch_queue_override_invoke方法，这个之前也说过了</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        dx_invoke(dou._do, dic, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续按自定义队列的步骤走</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_async_redirect_invoke(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">other_dc</span> = <span class="title">dc</span>-&gt;<span class="title">dc_other</span>;</span></span><br><span class="line">    <span class="keyword">dispatch_invoke_flags_t</span> ctxt_flags = (<span class="keyword">dispatch_invoke_flags_t</span>)dc-&gt;dc_ctxt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> assumed_rq = (<span class="keyword">dispatch_queue_t</span>)dc-&gt;dc_func;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = dc-&gt;dc_data, rq, old_dq;</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dbp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctxt_flags) &#123;</span><br><span class="line">        flags &amp;= ~_DISPATCH_INVOKE_AUTORELEASE_MASK;</span><br><span class="line">        flags |= ctxt_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    old_dq = _dispatch_get_current_queue();</span><br><span class="line">    <span class="keyword">if</span> (assumed_rq) &#123;</span><br><span class="line">        old_dbp = _dispatch_root_queue_identity_assume(assumed_rq);</span><br><span class="line">        _dispatch_set_basepri(dq-&gt;dq_priority);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        old_dbp = _dispatch_set_basepri(dq-&gt;dq_priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    <span class="comment">// 执行_dispatch_continuation_pop函数</span></span><br><span class="line">    _dispatch_continuation_pop_forwarded(dc, DISPATCH_NO_VOUCHER,</span><br><span class="line">            DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">        _dispatch_continuation_pop(other_dc, dic, flags, dq);</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">if</span> (assumed_rq) _dispatch_queue_set_current(old_dq);</span><br><span class="line">    _dispatch_reset_basepri(old_dbp);</span><br><span class="line"></span><br><span class="line">    rq = dq-&gt;do_targetq;</span><br><span class="line">    <span class="keyword">while</span> (slowpath(rq-&gt;do_targetq) &amp;&amp; rq != old_dq) &#123;</span><br><span class="line">        _dispatch_queue_non_barrier_complete(rq);</span><br><span class="line">        rq = rq-&gt;do_targetq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_queue_non_barrier_complete(dq);</span><br><span class="line">    _dispatch_release_tailcall(dq); <span class="comment">// pairs with _dispatch_async_redirect_wrap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果按照的是dispatch_get_global_queue会执行_dispatch_queue_override_invoke函数</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_override_invoke(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_rq = _dispatch_queue_get_current();</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> assumed_rq = dc-&gt;dc_other;</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dp;</span><br><span class="line">    <span class="keyword">voucher_t</span> ov = DISPATCH_NO_VOUCHER;</span><br><span class="line">    <span class="keyword">dispatch_object_t</span> dou;</span><br><span class="line"></span><br><span class="line">    dou._do = dc-&gt;dc_data;</span><br><span class="line">    old_dp = _dispatch_root_queue_identity_assume(assumed_rq);</span><br><span class="line">    <span class="keyword">if</span> (dc_type(dc) == DISPATCH_CONTINUATION_TYPE(OVERRIDE_STEALING)) &#123;</span><br><span class="line">        flags |= DISPATCH_INVOKE_STEALING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// balance the fake continuation push in</span></span><br><span class="line">        <span class="comment">// _dispatch_root_queue_push_override</span></span><br><span class="line">        _dispatch_trace_continuation_pop(assumed_rq, dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同样调用_dispatch_continuation_pop函数</span></span><br><span class="line">    _dispatch_continuation_pop_forwarded(dc, ov, DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">        <span class="keyword">if</span> (_dispatch_object_has_vtable(dou._do)) &#123;</span><br><span class="line">            dx_invoke(dou._do, dic, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _dispatch_continuation_invoke_inline(dou, ov, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_reset_basepri(old_dp);</span><br><span class="line">    _dispatch_queue_set_current(old_rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论是自定义的还是获取系统的，最终都会调用这个函数</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_invoke_context_t</span> dic,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags, <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_continuation_pop_inline(dou, dic, flags, dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">    _dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        dx_invoke(dou._do, dic, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_invoke_inline(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">voucher_t</span> ov,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    dispatch_invoke_with_autoreleasepool(flags, &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line"></span><br><span class="line">        _dispatch_continuation_voucher_adopt(dc, ov, dc_flags);</span><br><span class="line">        <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">            dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dc1 = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc_flags &amp; DISPATCH_OBJ_GROUP_BIT)) &#123;</span><br><span class="line">            _dispatch_continuation_with_group_invoke(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行block函数</span></span><br><span class="line">            _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">            _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc1)) &#123;</span><br><span class="line">            _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;start_wqthread是汇编写的，直接和内核交互。虽然我们明确了使用了异步的任务被执行的调用顺序，但是想必还是有这样的疑问_dispatch_worker_thread3是怎么跟内核扯上关系的。为什么调用的是_dispatch_worker_thread3，而不是_dispatch_worker_thread或者_dispatch_worker_thread4呢？<br>&emsp;&emsp;在此之前需要说的是，在GCD中一共有2个线程池管理着任务，一个是主线程池，另一个就是除了主线程任务的线程池。主线程池由序号1的队列管理，其他有序号2的队列进行管理。加上runloop运行的runloop队列，一共就有16个队列。  </p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:left">标签</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">com.apple.main-thread</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">com.apple.libdispatch-manager</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">com.apple.root.libdispatch-manager</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">com.apple.root.maintenance-qos</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">com.apple.root.maintenance-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">com.apple.root.background-qos</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">com.apple.root.background-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:left">com.apple.root.utility-qos</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:left">com.apple.root.utility-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:left">com.apple.root.default-qos</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:left">com.apple.root.default-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:left">com.apple.root.user-initiated-qos</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:left">com.apple.root.user-initiated-qos.overcommit</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:left">com.apple.root.user-interactive-qos</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:left">com.apple.root.user-interactive-qos.overcommit</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;看图的话，就如下图<img src="gcd_opensource.png" alt="线程池图"><br>&emsp;&emsp;有那么多root队列，所以application启动的时候就会初始化这些root队列的_dispatch_root_queues_init函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_root_queues_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> _dispatch_root_queues_pred;</span><br><span class="line">    dispatch_once_f(&amp;_dispatch_root_queues_pred, <span class="literal">NULL</span>,</span><br><span class="line">            _dispatch_root_queues_init_once);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_root_queues_init_once(<span class="keyword">void</span> *context DISPATCH_UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> wq_supported;</span><br><span class="line">    _dispatch_fork_becomes_unsafe();</span><br><span class="line">    <span class="keyword">if</span> (!_dispatch_root_queues_init_workq(&amp;wq_supported)) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DISPATCH_ROOT_QUEUE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> overcommit = <span class="literal">true</span>;</span><br><span class="line">            _dispatch_root_queue_init_pthread_pool(</span><br><span class="line">                    &amp;_dispatch_root_queue_contexts[i], <span class="number">0</span>, overcommit);</span><br><span class="line">        &#125;</span><br><span class="line">        DISPATCH_INTERNAL_CRASH((errno &lt;&lt; <span class="number">16</span>) | wq_supported,</span><br><span class="line">                <span class="string">"Root queue initialization failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_root_queues_init_workq(<span class="keyword">int</span> *wq_supported)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r; (<span class="keyword">void</span>)r;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    *wq_supported = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> disable_wq = <span class="literal">false</span>; (<span class="keyword">void</span>)disable_wq;</span><br><span class="line">    <span class="keyword">bool</span> disable_qos = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> disable_kevent_wq = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disable_wq &amp;&amp; !disable_qos) &#123;</span><br><span class="line">        *wq_supported = _pthread_workqueue_supported();</span><br><span class="line">        <span class="keyword">if</span> (!disable_kevent_wq &amp;&amp; (*wq_supported &amp; WORKQ_FEATURE_KEVENT)) &#123;</span><br><span class="line">            r = _pthread_workqueue_init_with_kevent(_dispatch_worker_thread3,</span><br><span class="line">                    (<span class="keyword">pthread_workqueue_function_kevent_t</span>)</span><br><span class="line">                    _dispatch_kevent_worker_thread,</span><br><span class="line">                    offsetof(struct dispatch_queue_s, dq_serialnum), <span class="number">0</span>);</span><br><span class="line">            result = !r;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;来到这里，已经看到_pthread_workqueue_init_with_kevent函数就是绑定了_dispatch_worker_thread3函数去做一些GCD的线程任务，看到源代码_pthread_workqueue_init_with_kevent做了些什么。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_pthread_workqueue_init_with_kevent(<span class="keyword">pthread_workqueue_function2_t</span> queue_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_kevent_t</span> kevent_func,</span><br><span class="line">        <span class="keyword">int</span> offset, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _pthread_workqueue_init_with_workloop(queue_func, kevent_func, <span class="literal">NULL</span>, offset, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_pthread_workqueue_init_with_workloop(<span class="keyword">pthread_workqueue_function2_t</span> queue_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_kevent_t</span> kevent_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_workloop_t</span> workloop_func,</span><br><span class="line">        <span class="keyword">int</span> offset, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ENOTSUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __workq_newapi = <span class="literal">true</span>;</span><br><span class="line">    __libdispatch_offset = offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rv = pthread_workqueue_setdispatch_with_workloop_np(queue_func, kevent_func, workloop_func);</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">pthread_workqueue_setdispatch_with_workloop_np(<span class="keyword">pthread_workqueue_function2_t</span> queue_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_kevent_t</span> kevent_func,</span><br><span class="line">        <span class="keyword">pthread_workqueue_function_workloop_t</span> workloop_func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> res = EBUSY;</span><br><span class="line">    <span class="keyword">if</span> (__libdispatch_workerfunction == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Check whether the kernel supports new SPIs</span></span><br><span class="line">        res = __workq_kernreturn(WQOPS_QUEUE_NEWSPISUPP, <span class="literal">NULL</span>, __libdispatch_offset, kevent_func != <span class="literal">NULL</span> ? <span class="number">0x01</span> : <span class="number">0x00</span>);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>)&#123;</span><br><span class="line">            res = ENOTSUP;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __libdispatch_workerfunction = queue_func;</span><br><span class="line">            __libdispatch_keventfunction = kevent_func;</span><br><span class="line">            __libdispatch_workloopfunction = workloop_func;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the kernel for workq action</span></span><br><span class="line">            (<span class="keyword">void</span>)__workq_open();</span><br><span class="line">            <span class="keyword">if</span> (__is_threaded == <span class="number">0</span>) &#123;</span><br><span class="line">                __is_threaded = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们看到了__libdispatch_workerfunction = queue_func;指定了队列工作函数。然后我们往回看之前说的我们制造了一个人为crash，追溯栈里看到_pthread_wqthread这个函数。看下这个函数怎么启用_dispatch_worker_thread3的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际代码很多，这里我精简了下，拿到了__libdispatch_workerfunction对应的_dispatch_worker_thread3，然后直接执行。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_pthread_wqthread(<span class="keyword">pthread_t</span> self, <span class="keyword">mach_port_t</span> kport, <span class="keyword">void</span> *stacklowaddr, <span class="keyword">void</span> *keventlist, <span class="keyword">int</span> flags, <span class="keyword">int</span> nkevents)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_workqueue_function_t</span> func = (<span class="keyword">pthread_workqueue_function_t</span>)__libdispatch_workerfunction;</span><br><span class="line">    <span class="keyword">int</span> options = overcommit ? WORKQ_ADDTHREADS_OPTION_OVERCOMMIT : <span class="number">0</span>;</span><br><span class="line">        (*func)(thread_class, options, <span class="literal">NULL</span>);</span><br><span class="line">    __workq_kernreturn(WQOPS_THREAD_RETURN, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    _pthread_exit(self, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x05-dispatch-group-async"><a href="#0x05-dispatch-group-async" class="headerlink" title="0x05 dispatch_group_async"></a>0x05 dispatch_group_async</h1><p>&emsp;&emsp;同样从入口看起<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="keyword">uintptr_t</span> dc_flags = DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_GROUP_BIT;</span><br><span class="line"></span><br><span class="line">    _dispatch_continuation_init(dc, dq, db, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">    _dispatch_continuation_group_async(dg, dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这里需要注意的是DISPATCH_OBJ_GROUP_BIT定义的是这样的，源码中还有DBF_PERFORM这个宏定义，他们本质是一样的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJ_GROUP_BIT              0x008ul</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBF_PERFORM 8u</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;同样是_dispatch_continuation_init函数，但这里跟dispatch_async那里就会有不同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_init(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_block_t</span> work,</span><br><span class="line">        <span class="keyword">pthread_priority_t</span> pp, <span class="keyword">dispatch_block_flags_t</span> flags, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">    dc-&gt;dc_flags = dc_flags | DISPATCH_OBJ_BLOCK_BIT;</span><br><span class="line">    dc-&gt;dc_ctxt = _dispatch_Block_copy(work);</span><br><span class="line">    _dispatch_continuation_priority_set(dc, pp, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch_group会走进这个条件分支</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_continuation_init_slow(dc, dqu, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">        dc-&gt;dc_func = _dispatch_call_block_and_release;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc-&gt;dc_func = _dispatch_Block_invoke(work);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_continuation_voucher_set(dc, dqu, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_continuation_init_slow(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_block_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_block_private_data_t</span> dbpd = _dispatch_block_get_data(dc-&gt;dc_ctxt); <span class="comment">// 获取block</span></span><br><span class="line">    <span class="keyword">dispatch_block_flags_t</span> block_flags = dbpd-&gt;dbpd_flags;</span><br><span class="line">    <span class="keyword">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line">    <span class="keyword">os_mpsc_queue_t</span> oq = dqu._oq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (os_atomic_cmpxchg2o(dbpd, dbpd_queue, <span class="literal">NULL</span>, oq, relaxed)) &#123;</span><br><span class="line">        _os_object_retain_internal_n_inline(oq-&gt;_as_os_obj, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_MACH_BARRIER) &#123;</span><br><span class="line">        dispatch_assert(dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT);</span><br><span class="line">        dc-&gt;dc_func = _dispatch_block_async_invoke_and_release_mach_barrier;</span><br><span class="line">    <span class="comment">// DISPATCH_OBJ_CONSUME_BIT 还是这个标识符</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">        <span class="comment">// 会走到这里，指定函数</span></span><br><span class="line">        dc-&gt;dc_func = _dispatch_block_async_invoke_and_release;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc-&gt;dc_func = _dispatch_block_async_invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= block_flags;</span><br><span class="line">    <span class="keyword">if</span> (block_flags &amp; DISPATCH_BLOCK_HAS_PRIORITY) &#123;</span><br><span class="line">        _dispatch_continuation_priority_set(dc, dbpd-&gt;dbpd_priority, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_priority_set(dc, dc-&gt;dc_priority, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block_flags &amp; DISPATCH_BLOCK_BARRIER) &#123;</span><br><span class="line">        dc_flags |= DISPATCH_OBJ_BARRIER_BIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (block_flags &amp; DISPATCH_BLOCK_HAS_VOUCHER) &#123;</span><br><span class="line">        <span class="keyword">voucher_t</span> v = dbpd-&gt;dbpd_voucher;</span><br><span class="line">        dc-&gt;dc_voucher = v ? _voucher_retain(v) : <span class="literal">NULL</span>;</span><br><span class="line">        dc_flags |= DISPATCH_OBJ_ENFORCE_VOUCHER;</span><br><span class="line">        _dispatch_voucher_debug(<span class="string">"continuation[%p] set"</span>, dc-&gt;dc_voucher, dc);</span><br><span class="line">        _dispatch_voucher_ktrace_dc_push(dc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_voucher_set(dc, oq, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    dc_flags |= DISPATCH_OBJ_BLOCK_PRIVATE_DATA_BIT;</span><br><span class="line">    dc-&gt;dc_flags = dc_flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_block_async_invoke_and_release(<span class="keyword">void</span> *block)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_block_async_invoke2(block, DISPATCH_BLOCK_ASYNC_INVOKE_RELEASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_block_async_invoke2(<span class="keyword">dispatch_block_t</span> b, <span class="keyword">unsigned</span> <span class="keyword">long</span> invoke_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_block_private_data_t</span> dbpd = _dispatch_block_get_data(b);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> atomic_flags = dbpd-&gt;dbpd_atomic_flags;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(atomic_flags &amp; DBF_WAITED)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(atomic_flags, <span class="string">"A block object may not be both "</span></span><br><span class="line">                <span class="string">"run more than once and waited for"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有被标志取消的话就执行这个任务</span></span><br><span class="line">    <span class="keyword">if</span> (!slowpath(atomic_flags &amp; DBF_CANCELED)) &#123;</span><br><span class="line">        dbpd-&gt;dbpd_block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DBF_PERFORM之前说过跟DISPATCH_OBJ_GROUP_BIT一样，表示是dispatch_group</span></span><br><span class="line">    <span class="comment">// 所以这个这里也就可以看到dispatch_group_enter和dispatch_group_leave就对应起来了。</span></span><br><span class="line">    <span class="keyword">if</span> ((atomic_flags &amp; DBF_PERFORM) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (os_atomic_inc2o(dbpd, dbpd_performed, relaxed) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 与后面_dispatch_continuation_group_async函数里面的dispatch_group_enter匹配</span></span><br><span class="line">            dispatch_group_leave(_dbpd_group(dbpd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">os_mpsc_queue_t</span> oq = os_atomic_xchg2o(dbpd, dbpd_queue, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (oq) &#123;</span><br><span class="line">        _os_object_release_internal_n_inline(oq-&gt;_as_os_obj, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invoke_flags &amp; DISPATCH_BLOCK_ASYNC_INVOKE_RELEASE) &#123;</span><br><span class="line">        Block_release(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;_dispatch_continuation_init在上面已经看过，我们直接看_dispatch_continuation_group_async函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    _dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们发现，其实dispatch_group_async内部也是加了dispatch_group_enter函数。后面取出逻辑跟dispatch_async就差不多了，不做多说。</p>
<h1 id="0x06-dispatch-once"><a href="#0x06-dispatch-once" class="headerlink" title="0x06 dispatch_once"></a>0x06 dispatch_once</h1><p>&emsp;&emsp;还是从入口函数开始看<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们调用dispatch_once的入口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 内部又调用了dispatch_once_f函数</span></span><br><span class="line">    dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once_f</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_once_f_slow(val, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ONCE_SLOW_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">dispatch_once_f_slow(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _dispatch_once_waiter_t格式：</span></span><br><span class="line">    <span class="comment">// typedef struct _dispatch_once_waiter_s &#123;</span></span><br><span class="line">    <span class="comment">//      volatile struct _dispatch_once_waiter_s *volatile dow_next;</span></span><br><span class="line">    <span class="comment">//      dispatch_thread_event_s dow_event;</span></span><br><span class="line">    <span class="comment">//      mach_port_t dow_thread;</span></span><br><span class="line">    <span class="comment">// &#125; *_dispatch_once_waiter_t;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile：告诉编译器不要对此指针进行代码优化，因为这个指针指向的值可能会被其他线程改变</span></span><br><span class="line">    <span class="keyword">_dispatch_once_waiter_t</span> <span class="keyword">volatile</span> *vval = (<span class="keyword">_dispatch_once_waiter_t</span>*)val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> <span class="title">dow</span> = &#123;</span> &#125;;</span><br><span class="line">    <span class="keyword">_dispatch_once_waiter_t</span> tail = &amp;dow, next, tmp;</span><br><span class="line">    <span class="keyword">dispatch_thread_event_t</span> event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次执行时，*vval为0，此时第一个参数vval和第二个参数NULL比较是相等的，返回true，然后把tail赋值给第一个参数的值。如果这时候同时有别的线程也进来，此时vval的值不是0了，所以会来到else分支。</span></span><br><span class="line">    <span class="keyword">if</span> (os_atomic_cmpxchg(vval, <span class="literal">NULL</span>, tail, acquire)) &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        dow.dow_thread = _dispatch_tid_self();</span><br><span class="line">        <span class="comment">// 调用block函数，一般就是我们在外面做的初始化工作</span></span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部将DLOCK_ONCE_DONE赋值给val，将当前标记为已完成，返回之前的引用值。前面说过了，把tail赋值给val了，但这只是没有别的线程进来走到下面else分支，如果有别的线程进来next就是别的值了，如果没有别的信号量在等待，工作就到此结束了。</span></span><br><span class="line">        next = (<span class="keyword">_dispatch_once_waiter_t</span>)_dispatch_once_xchg_done(val);</span><br><span class="line">        <span class="comment">// 如果没有别的线程进来过处于等待，这里就会结束。如果有，则遍历每一个等待的信号量，然后一个个唤醒它们</span></span><br><span class="line">        <span class="keyword">while</span> (next != tail) &#123;</span><br><span class="line">            <span class="comment">// 内部用到了thread_switch，避免优先级反转。把next-&gt;dow_next返回</span></span><br><span class="line">            tmp = (<span class="keyword">_dispatch_once_waiter_t</span>)_dispatch_wait_until(next-&gt;dow_next);</span><br><span class="line">            event = &amp;next-&gt;dow_event;</span><br><span class="line">            next = tmp;</span><br><span class="line">            <span class="comment">// 唤醒信号量</span></span><br><span class="line">            _dispatch_thread_event_signal(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 内部就是_dispatch_sema4_init函数，也就是初始化一个信号链表</span></span><br><span class="line">        _dispatch_thread_event_init(&amp;dow.dow_event);</span><br><span class="line">        <span class="comment">// next指向新的原子</span></span><br><span class="line">        next = *vval;</span><br><span class="line">        <span class="comment">// 不断循环等待</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 前面说过第一次进来后进入if分支，后面再次进来，会来到这里，但是之前if里面被标志为DISPATCH_ONCE_DONE了，所以结束。</span></span><br><span class="line">            <span class="keyword">if</span> (next == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当第一次初始化的时候，同时有别的线程也进来，这是第一个线程已经占据了if分支，但其他线程也是第一进来，所以状态并不是DISPATCH_ONCE_DONE，所以就来到了这里</span></span><br><span class="line">            <span class="comment">// 比较vval和next是否一样，其他线程第一次来这里肯定是相等的</span></span><br><span class="line">            <span class="keyword">if</span> (os_atomic_cmpxchgv(vval, next, tail, &amp;next, release)) &#123;</span><br><span class="line">                dow.dow_thread = next-&gt;dow_thread;</span><br><span class="line">                dow.dow_next = next;</span><br><span class="line">                <span class="keyword">if</span> (dow.dow_thread) &#123;</span><br><span class="line">                    <span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">                    _dispatch_thread_override_start(dow.dow_thread, pp, val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待唤醒，唤醒后就做收尾操作</span></span><br><span class="line">                _dispatch_thread_event_wait(&amp;dow.dow_event);</span><br><span class="line">                <span class="keyword">if</span> (dow.dow_thread) &#123;</span><br><span class="line"></span><br><span class="line">                    _dispatch_thread_override_end(dow.dow_thread, val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁信号量</span></span><br><span class="line">        _dispatch_thread_event_destroy(&amp;dow.dow_event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么，回到上篇提到使用dispatch_once死锁的问题，如果使用不当会造成什么后果？回顾下上篇的实验代码<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> once];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)once &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> otherOnce];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"遇到第一只熊猫宝宝..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherOnce &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> once];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"遇到第二只熊猫宝宝..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;示例中我们可以看到once方法需要等待otherOnce方法的完成，而otherOnce又调用了once，根据前面的源码，otherOnce调用once方法会走到else分支，在这个分支等待之前一个信号量发出唤醒指令，但是once方法里面又依赖otherOnce方法的完成，由于处于一个线程，所以就卡住了。</p>
<h1 id="0x06-dispatch-group-create-amp-dispatch-semaphore-create"><a href="#0x06-dispatch-group-create-amp-dispatch-semaphore-create" class="headerlink" title="0x06 dispatch_group_create &amp; dispatch_semaphore_create"></a>0x06 dispatch_group_create &amp; dispatch_semaphore_create</h1><p>&emsp;&emsp;为什么两个一起看，其实dispatch_group也是通过dispatch_semaphore控制的，看下dispatch_group_create源代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span></span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_group_create_with_count(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_group_t</span></span><br><span class="line">_dispatch_group_create_with_count(<span class="keyword">long</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg = (<span class="keyword">dispatch_group_t</span>)_dispatch_object_alloc(</span><br><span class="line">        DISPATCH_VTABLE(group), <span class="keyword">sizeof</span>(struct dispatch_group_s));</span><br><span class="line"> _dispatch_semaphore_class_init(count, dg); <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="keyword">if</span> (count) &#123;</span><br><span class="line">        os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;同样的，看下dispatch_semaphore_create源代码，是不是一股熟悉的配方：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">dispatch_semaphore_t</span></span><br><span class="line">    dispatch_semaphore_create(<span class="keyword">long</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">dispatch_semaphore_t</span> dsema;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dsema = (<span class="keyword">dispatch_semaphore_t</span>)_dispatch_object_alloc(</span><br><span class="line">            DISPATCH_VTABLE(semaphore), <span class="keyword">sizeof</span>(struct dispatch_semaphore_s));</span><br><span class="line">        _dispatch_semaphore_class_init(value, dsema); <span class="comment">// 同样的初始化信号量</span></span><br><span class="line">        dsema-&gt;dsema_orig = value;</span><br><span class="line">        <span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x07-dispatch-group-wait-amp-dispatch-semaphore-wait"><a href="#0x07-dispatch-group-wait-amp-dispatch-semaphore-wait" class="headerlink" title="0x07 dispatch_group_wait &amp; dispatch_semaphore_wait"></a>0x07 dispatch_group_wait &amp; dispatch_semaphore_wait</h1><p>&emsp;&emsp;<br>再看下dispatch_group_wait的代码，其内部是调用的_dispatch_group_wait_slow函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wait_slow(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">int</span> orig_waiters;</span><br><span class="line"></span><br><span class="line">    value = os_atomic_load2o(dg, dg_value, ordered); </span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>)os_atomic_inc2o(dg, dg_waiters, relaxed);</span><br><span class="line"></span><br><span class="line">    value = os_atomic_load2o(dg, dg_value, ordered);</span><br><span class="line">    <span class="comment">// 如果group里没有任务</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">        _dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">        timeout = DISPATCH_TIME_FOREVER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_sema4_create(&amp;dg-&gt;dg_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dg-&gt;dg_sema, timeout)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig_waiters = dg-&gt;dg_waiters;</span><br><span class="line">        <span class="keyword">while</span> (orig_waiters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (os_atomic_cmpxchgvw2o(dg, dg_waiters, orig_waiters,</span><br><span class="line">                    orig_waiters - <span class="number">1</span>, &amp;orig_waiters, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        _dispatch_sema4_wait(&amp;dg-&gt;dg_sema);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对比着看dispatch_semaphore_wait源码，其内部也调用_dispatch_semaphore_wait_slow函数，可以看到逻辑基本一致：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">        <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line"></span><br><span class="line">    _dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_value;</span><br><span class="line">        <span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (os_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">                    &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        _dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x08-dispatch-group-notify"><a href="#0x08-dispatch-group-notify" class="headerlink" title="0x08 dispatch_group_notify"></a>0x08 dispatch_group_notify</h1><p>&emsp;&emsp;再把dispatch_group_notify看下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_block_t</span> db)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dsn = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="comment">// 之前说过了</span></span><br><span class="line">    _dispatch_continuation_init(dsn, dq, db, <span class="number">0</span>, <span class="number">0</span>, DISPATCH_OBJ_CONSUME_BIT);</span><br><span class="line">    _dispatch_group_notify(dg, dq, dsn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_continuation_t</span> dsn)</span><br><span class="line">&#123;</span><br><span class="line">    dsn-&gt;dc_data = dq;</span><br><span class="line">    dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    _dispatch_retain(dq);</span><br><span class="line">    <span class="keyword">if</span> (os_mpsc_push_update_tail(dg, dg_notify, dsn, do_next)) &#123;</span><br><span class="line">        _dispatch_retain(dg);</span><br><span class="line">        os_atomic_store2o(dg, dg_notify_head, dsn, ordered);</span><br><span class="line">        <span class="comment">// 这里可以理解为有任务需要执行</span></span><br><span class="line">        <span class="keyword">if</span> (os_atomic_load2o(dg, dg_value, ordered) == <span class="number">0</span>) &#123;</span><br><span class="line">            _dispatch_group_wake(dg, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wake(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">bool</span> needs_release)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> next, head, tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">long</span> rval;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    head = os_atomic_xchg2o(dg, dg_notify_head, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        tail = os_atomic_xchg2o(dg, dg_notify_tail, <span class="literal">NULL</span>, release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dg-&gt;dg_waiters是否为0</span></span><br><span class="line">    rval = (<span class="keyword">long</span>)os_atomic_xchg2o(dg, dg_waiters, <span class="number">0</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (rval) &#123;</span><br><span class="line">        <span class="comment">// 创建信号量</span></span><br><span class="line">        _dispatch_sema4_create(&amp;dg-&gt;dg_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">        <span class="comment">// 发出信号</span></span><br><span class="line">        _dispatch_sema4_signal(&amp;dg-&gt;dg_sema, rval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint16_t</span> refs = needs_release ? <span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            next = os_mpsc_pop_snapshot_head(head, tail, do_next);</span><br><span class="line">            <span class="keyword">dispatch_queue_t</span> dsn_queue = (<span class="keyword">dispatch_queue_t</span>)head-&gt;dc_data;</span><br><span class="line">            _dispatch_continuation_async(dsn_queue, head);</span><br><span class="line">            _dispatch_release(dsn_queue);</span><br><span class="line">        &#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">        refs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (refs) _dispatch_release_n(dg, refs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x09-dispatch-barrier-async"><a href="#0x09-dispatch-barrier-async" class="headerlink" title="0x09 dispatch_barrier_async"></a>0x09 dispatch_barrier_async</h1><p>&emsp;&emsp;可以看到，大多数实现都是大同小异，通过不同的标志位来控制。这里跟dispatch_async的不同就在于，dispatch_async直接把任务扔到root队列，而dispatch_barrier_async是把任务在到自定义的队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_barrier_async(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="keyword">uintptr_t</span> dc_flags = DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_BARRIER_BIT;</span><br><span class="line"></span><br><span class="line">    _dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">    _dispatch_continuation_push(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_push(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_queue_push_inline(dq, dou, qos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_push_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _tail,</span><br><span class="line">        <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">tail</span> = _<span class="title">tail</span>._<span class="title">do</span>;</span></span><br><span class="line">    <span class="keyword">dispatch_wakeup_flags_t</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> overriding = _dispatch_queue_need_override_retain(dq, qos);</span><br><span class="line">    <span class="comment">// 加入到自己的队列</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(_dispatch_queue_push_update_tail(dq, tail))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!overriding) _dispatch_retain_2(dq-&gt;_as_os_obj);</span><br><span class="line">        _dispatch_queue_push_update_head(dq, tail);</span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2 | DISPATCH_WAKEUP_MAKE_DIRTY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (overriding) &#123;</span><br><span class="line">        flags = DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒队列</span></span><br><span class="line">    <span class="keyword">return</span> dx_wakeup(dq, qos, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_wakeup(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="keyword">dispatch_wakeup_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_wakeup_target_t</span> target = DISPATCH_QUEUE_WAKEUP_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_WAKEUP_BARRIER_COMPLETE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_barrier_complete(dq, qos, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部就是 tail != NULL，所以满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_queue_class_probe(dq)) &#123;</span><br><span class="line">        <span class="comment">// #define DISPATCH_QUEUE_WAKEUP_TARGET  ((dispatch_queue_wakeup_target_t)1)</span></span><br><span class="line">        target = DISPATCH_QUEUE_WAKEUP_TARGET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_class_wakeup(dq, qos, flags, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_class_wakeup(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_qos_t</span> qos,</span><br><span class="line">        <span class="keyword">dispatch_wakeup_flags_t</span> flags, <span class="keyword">dispatch_queue_wakeup_target_t</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_assert(target != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会走进去</span></span><br><span class="line">    <span class="keyword">if</span> (target &amp;&amp; !(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        _dispatch_retain_2(dq);</span><br><span class="line">        flags |= DISPATCH_WAKEUP_CONSUME_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会走进去</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_WAKEUP_BARRIER_COMPLETE)) &#123;</span><br><span class="line">        dispatch_assert(dx_metatype(dq) != _DISPATCH_QUEUE_TYPE);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_class_barrier_complete(dq, qos, flags, target,</span><br><span class="line">                DISPATCH_QUEUE_SERIAL_DRAIN_OWNED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会走进去</span></span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> old_state, new_state, enqueue = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_MGR) &#123;</span><br><span class="line">            enqueue = DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">        &#125;</span><br><span class="line">        qos = _dispatch_queue_override_qos(dq, qos);</span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">            new_state = _dq_state_merge_qos(old_state, qos);</span><br><span class="line">            <span class="keyword">if</span> (likely(!_dq_state_is_suspended(old_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_enqueued(old_state) &amp;&amp;</span><br><span class="line">                    (!_dq_state_drain_locked(old_state) ||</span><br><span class="line">                    (enqueue != DISPATCH_QUEUE_ENQUEUED_ON_MGR &amp;&amp;</span><br><span class="line">                    _dq_state_is_base_wlh(old_state))))) &#123;</span><br><span class="line">                new_state |= enqueue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_WAKEUP_MAKE_DIRTY) &#123;</span><br><span class="line">                new_state |= DISPATCH_QUEUE_DIRTY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_state == old_state) &#123;</span><br><span class="line">                os_atomic_rmw_loop_give_up(<span class="keyword">goto</span> done);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely((old_state ^ new_state) &amp; enqueue)) &#123;</span><br><span class="line">            <span class="keyword">dispatch_queue_t</span> tq;</span><br><span class="line">            <span class="keyword">if</span> (target == DISPATCH_QUEUE_WAKEUP_TARGET) &#123;</span><br><span class="line">                os_atomic_thread_fence(dependency);</span><br><span class="line">                tq = os_atomic_load_with_dependency_on2o(dq, do_targetq,</span><br><span class="line">                        (<span class="keyword">long</span>)new_state);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tq = target;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">            <span class="comment">// 把队列装入到root队列中,内部调用的_dispatch_root_queue_push函数</span></span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_WAKEUP_CONSUME_2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release_2_tailcall(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _dispatch_root_queue_push函数在dispatch_async已经贴过代码，直接看_dispatch_root_queue_push_override函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_push_override(<span class="keyword">dispatch_queue_t</span> orig_rq,</span><br><span class="line">        <span class="keyword">dispatch_object_t</span> dou, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> overcommit = orig_rq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> rq = _dispatch_get_root_queue(qos, overcommit);</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc;</span><br><span class="line">    <span class="comment">// 因为barrier是直接推进自己的队列，所以这里不会走if语句，具体注释可以看dispatch_async那里</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_is_redirection(dc)) &#123;</span><br><span class="line">        dc-&gt;dc_func = (<span class="keyword">void</span> *)orig_rq;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc = _dispatch_continuation_alloc();</span><br><span class="line">        <span class="comment">// 指定do_vtable，所以取出来执行的时候调用的是_dispatch_queue_override_invoke函数</span></span><br><span class="line">        dc-&gt;do_vtable = DC_VTABLE(OVERRIDE_OWNING);</span><br><span class="line">        _dispatch_trace_continuation_push(orig_rq, dou);</span><br><span class="line">        dc-&gt;dc_ctxt = dc;</span><br><span class="line">        dc-&gt;dc_other = orig_rq;</span><br><span class="line">        dc-&gt;dc_data = dou._do;</span><br><span class="line">        dc-&gt;dc_priority = DISPATCH_NO_PRIORITY;</span><br><span class="line">        dc-&gt;dc_voucher = DISPATCH_NO_VOUCHER;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_root_queue_push_inline(rq, dc, dc, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面也省略</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;同样我们人为制造一个闪退，看下被调用顺序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>   libdispatch.dylib                   <span class="number">0x0000000105b952f7</span> _dispatch_call_block_and_release + <span class="number">12</span></span><br><span class="line"><span class="number">7</span>   libdispatch.dylib                   <span class="number">0x0000000105b9633d</span> _dispatch_client_callout + <span class="number">8</span></span><br><span class="line"><span class="number">8</span>   libdispatch.dylib                   <span class="number">0x0000000105ba40a5</span> _dispatch_queue_concurrent_drain + <span class="number">1492</span></span><br><span class="line"><span class="number">9</span>   libdispatch.dylib                   <span class="number">0x0000000105b9f1fb</span> _dispatch_queue_invoke + <span class="number">353</span></span><br><span class="line"><span class="number">10</span>  libdispatch.dylib                   <span class="number">0x0000000105b9af7c</span> _dispatch_queue_override_invoke + <span class="number">733</span></span><br><span class="line"><span class="number">11</span>  libdispatch.dylib                   <span class="number">0x0000000105ba2102</span> _dispatch_root_queue_drain + <span class="number">772</span></span><br><span class="line"><span class="number">12</span>  libdispatch.dylib                   <span class="number">0x0000000105ba1da0</span> _dispatch_worker_thread3 + <span class="number">132</span></span><br><span class="line"><span class="number">13</span>  libsystem_pthread.dylib             <span class="number">0x000000010605d5a2</span> _pthread_wqthread + <span class="number">1299</span></span><br><span class="line"><span class="number">14</span>  libsystem_pthread.dylib             <span class="number">0x000000010605d07d</span> start_wqthread + <span class="number">13</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;一样从_dispatch_root_queue_drain开始看<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">pthread_priority_t</span> pp)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_queue_set_current(dq);</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> pri = dq-&gt;dq_priority;</span><br><span class="line">    <span class="keyword">if</span> (!pri) pri = _dispatch_priority_from_pp(pp);</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dbp = _dispatch_set_basepri(pri);</span><br><span class="line">    _dispatch_adopt_wlh_anon();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> reset = <span class="literal">false</span>;</span><br><span class="line">    dispatch_invoke_context_s dic = &#123; &#125;;</span><br><span class="line">    <span class="keyword">dispatch_invoke_flags_t</span> flags = DISPATCH_INVOKE_WORKER_DRAIN |</span><br><span class="line">            DISPATCH_INVOKE_REDIRECTING_DRAIN;</span><br><span class="line">    _dispatch_queue_drain_init_narrowing_check_deadline(&amp;dic, pri);</span><br><span class="line">    _dispatch_perfmon_start();</span><br><span class="line">    <span class="comment">// rootqueue可以跟一个dispatch_queue_t也可以跟一个dispatch_continuation_t</span></span><br><span class="line">    <span class="comment">// 所以这里item取出来的是dispatch_queue_t</span></span><br><span class="line">    <span class="keyword">while</span> ((item = fastpath(_dispatch_root_queue_drain_one(dq)))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reset) _dispatch_wqthread_override_reset();</span><br><span class="line">        _dispatch_continuation_pop_inline(item, &amp;dic, flags, dq);</span><br><span class="line">        <span class="comment">// 重置当前线程的优先级，会跟内核jiao'hu</span></span><br><span class="line">        reset = _dispatch_reset_basepri_override();</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(&amp;dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overcommit or not. worker thread</span></span><br><span class="line">    <span class="keyword">if</span> (pri &amp; _PTHREAD_PRIORITY_OVERCOMMIT_FLAG) &#123;</span><br><span class="line">        _dispatch_perfmon_end(perfmon_thread_worker_oc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_perfmon_end(perfmon_thread_worker_non_oc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_reset_wlh();</span><br><span class="line">    _dispatch_reset_basepri(old_dbp);</span><br><span class="line">    _dispatch_reset_basepri_override();</span><br><span class="line">    _dispatch_queue_set_current(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">    _dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">    <span class="comment">// 调用_dispatch_queue_override_invoke函数</span></span><br><span class="line">    <span class="comment">// 这里其实很好理解，从root队列拿出来的有可能是一个队列，也可能就是一个任务，所以如果是队列，就调用队列的执行函数</span></span><br><span class="line">    <span class="comment">// 所以为什么官方文档说，不是自定义队列使用barrier无效，因为不是自定义队列，这里就直接走_dispatch_continuation_invoke_inline函数，调用函数实现了，也就是dispatch_barrier_async类似于dispatch_async了。</span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        dx_invoke(dou._do, dic, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_override_invoke(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_rq = _dispatch_queue_get_current();</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> assumed_rq = dc-&gt;dc_other;</span><br><span class="line">    <span class="keyword">dispatch_priority_t</span> old_dp;</span><br><span class="line">    <span class="keyword">voucher_t</span> ov = DISPATCH_NO_VOUCHER;</span><br><span class="line">    <span class="keyword">dispatch_object_t</span> dou;</span><br><span class="line"></span><br><span class="line">    dou._do = dc-&gt;dc_data;</span><br><span class="line">    <span class="comment">// 将自定义queue激活，其root队列挂起。将rootqueue保存到old_dq变量</span></span><br><span class="line">    <span class="comment">// 所以这也就是为什么，barrier的任务可以提前执行，后面的任务会被阻塞</span></span><br><span class="line">    <span class="comment">//  static inline dispatch_priority_t</span></span><br><span class="line">    <span class="comment">//_dispatch_root_queue_identity_assume(dispatch_queue_t assumed_rq)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//      dispatch_priority_t old_dbp = _dispatch_get_basepri();</span></span><br><span class="line">    <span class="comment">//      dispatch_assert(dx_hastypeflag(assumed_rq, QUEUE_ROOT));</span></span><br><span class="line">    <span class="comment">//      _dispatch_reset_basepri(assumed_rq-&gt;dq_priority);</span></span><br><span class="line">    <span class="comment">//      _dispatch_queue_set_current(assumed_rq);</span></span><br><span class="line">    <span class="comment">//      return old_dbp;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    old_dp = _dispatch_root_queue_identity_assume(assumed_rq);</span><br><span class="line">    <span class="keyword">if</span> (dc_type(dc) == DISPATCH_CONTINUATION_TYPE(OVERRIDE_STEALING)) &#123;</span><br><span class="line">        flags |= DISPATCH_INVOKE_STEALING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_trace_continuation_pop(assumed_rq, dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_continuation_pop_forwarded(dc, ov, DISPATCH_OBJ_CONSUME_BIT, &#123;</span><br><span class="line">        <span class="comment">// 来到if分支，调用_dispatch_queue_invoke函数</span></span><br><span class="line">        <span class="keyword">if</span> (_dispatch_object_has_vtable(dou._do)) &#123;</span><br><span class="line">            dx_invoke(dou._do, dic, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _dispatch_continuation_invoke_inline(dou, ov, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 重新激活root队列</span></span><br><span class="line">    _dispatch_reset_basepri(old_dp);</span><br><span class="line">    _dispatch_queue_set_current(old_rq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_invoke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_invoke_context_t</span> dic,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_queue_class_invoke(dq, dic, flags, <span class="number">0</span>, dispatch_queue_invoke2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_class_invoke(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> const_restrict_flags,</span><br><span class="line">        <span class="keyword">_dispatch_queue_class_invoke_handler_t</span> invoke)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = dou._dq;</span><br><span class="line">    <span class="keyword">dispatch_queue_wakeup_target_t</span> tq = DISPATCH_QUEUE_WAKEUP_NONE;</span><br><span class="line">    <span class="keyword">bool</span> owning = !(flags &amp; DISPATCH_INVOKE_STEALING);</span><br><span class="line">    <span class="keyword">uint64_t</span> owned = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; (DISPATCH_INVOKE_STEALING | DISPATCH_INVOKE_WLH))) &#123;</span><br><span class="line">        dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    &#125;</span><br><span class="line">    flags |= const_restrict_flags;</span><br><span class="line">    <span class="keyword">if</span> (likely(flags &amp; DISPATCH_INVOKE_WLH)) &#123;</span><br><span class="line">        owned = DISPATCH_QUEUE_SERIAL_DRAIN_OWNED | DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owned = _dispatch_queue_drain_try_lock(dq, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (likely(owned)) &#123;</span><br><span class="line">        <span class="keyword">dispatch_priority_t</span> old_dbp;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; DISPATCH_INVOKE_MANAGER_DRAIN)) &#123;</span><br><span class="line">            old_dbp = _dispatch_set_basepri(dq-&gt;dq_priority);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            old_dbp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flags = _dispatch_queue_merge_autorelease_frequency(dq, flags);</span><br><span class="line"></span><br><span class="line">attempt_running_slow_head:</span><br><span class="line">        <span class="comment">// 执行dispatch_queue_invoke2函数</span></span><br><span class="line">        <span class="comment">// 也就是执行自定义队列里面的任务</span></span><br><span class="line">        tq = invoke(dq, dic, flags, &amp;owned);</span><br><span class="line">        dispatch_assert(tq != DISPATCH_QUEUE_WAKEUP_TARGET);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(tq != DISPATCH_QUEUE_WAKEUP_NONE &amp;&amp;</span><br><span class="line">                tq != DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT)) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_drain_try_unlock(dq, owned,</span><br><span class="line">                tq == DISPATCH_QUEUE_WAKEUP_NONE)) &#123;</span><br><span class="line">            tq = _dispatch_queue_get_current();</span><br><span class="line">            <span class="keyword">if</span> (dx_hastypeflag(tq, QUEUE_ROOT) || !owning) &#123;</span><br><span class="line">                <span class="keyword">goto</span> attempt_running_slow_head;</span><br><span class="line">            &#125;</span><br><span class="line">            DISPATCH_COMPILER_CAN_ASSUME(tq != DISPATCH_QUEUE_WAKEUP_NONE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            owned = <span class="number">0</span>;</span><br><span class="line">            tq = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; DISPATCH_INVOKE_MANAGER_DRAIN)) &#123;</span><br><span class="line">            _dispatch_reset_basepri(old_dbp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (likely(owning)) &#123;</span><br><span class="line">        _dispatch_introspection_queue_item_complete(dq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tq) &#123;</span><br><span class="line">        <span class="keyword">if</span> (const_restrict_flags &amp; DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS) &#123;</span><br><span class="line">            dispatch_assert(dic-&gt;dic_deferred == <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dic-&gt;dic_deferred) &#123;</span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_drain_sync_waiter(dq, dic,</span><br><span class="line">                    flags, owned);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint64_t</span> old_state, new_state, enqueued = DISPATCH_QUEUE_ENQUEUED;</span><br><span class="line">        <span class="keyword">if</span> (tq == DISPATCH_QUEUE_WAKEUP_MGR) &#123;</span><br><span class="line">            enqueued = DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">        &#125;</span><br><span class="line">        os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, release, &#123;</span><br><span class="line">            new_state  = old_state - owned;</span><br><span class="line">            new_state &amp;= ~DISPATCH_QUEUE_DRAIN_UNLOCK_MASK;</span><br><span class="line">            new_state |= DISPATCH_QUEUE_DIRTY;</span><br><span class="line">            <span class="keyword">if</span> (_dq_state_is_suspended(new_state)) &#123;</span><br><span class="line">                new_state |= DLOCK_OWNER_MASK;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_dq_state_is_runnable(new_state) &amp;&amp;</span><br><span class="line">                    !_dq_state_is_enqueued(new_state)) &#123;</span><br><span class="line">                <span class="comment">// drain was not interupted for suspension</span></span><br><span class="line">                <span class="comment">// we will reenqueue right away, just put ENQUEUED back</span></span><br><span class="line">                new_state |= enqueued;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        old_state -= owned;</span><br><span class="line">        <span class="keyword">if</span> (_dq_state_received_override(old_state)) &#123;</span><br><span class="line">            <span class="comment">// Ensure that the root queue sees that this thread was overridden.</span></span><br><span class="line">            _dispatch_set_basepri_override_qos(_dq_state_max_qos(new_state));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((old_state ^ new_state) &amp; enqueued) &#123;</span><br><span class="line">            dispatch_assert(_dq_state_is_enqueued(new_state));</span><br><span class="line">            <span class="keyword">return</span> _dispatch_queue_push_queue(tq, dq, new_state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_release_2_tailcall(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_queue_wakeup_target_t <span class="title">dispatch_queue_invoke2</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_invoke_context_t</span> dic,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_invoke_flags_t</span> flags, <span class="keyword">uint64_t</span> *owned)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> otq = dq-&gt;do_targetq;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> cq = _dispatch_queue_get_current();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(cq != otq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> otq;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_serial_drain(dq, dic, flags, owned);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_concurrent_drain(dq, dic, flags, owned);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_wakeup_target_t</span> _dispatch_queue_concurrent_drain(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">uint64_t</span> *owned)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_queue_drain(dq, dic, flags, owned, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_wakeup_target_t</span></span><br><span class="line">_dispatch_queue_drain(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_invoke_context_t</span> dic,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags, <span class="keyword">uint64_t</span> *owned_ptr, <span class="keyword">bool</span> serial_drain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> orig_tq = dq-&gt;do_targetq;</span><br><span class="line">    dispatch_thread_frame_s dtf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dc</span> = <span class="title">NULL</span>, *<span class="title">next_dc</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> dq_state, owned = *owned_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dq-&gt;dq_items_tail)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    _dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">    <span class="keyword">if</span> (serial_drain || _dq_state_is_in_barrier(owned)) &#123;</span><br><span class="line">        <span class="comment">// we really own `IN_BARRIER + dq-&gt;dq_width * WIDTH_INTERVAL`</span></span><br><span class="line">        <span class="comment">// but width can change while draining barrier work items, so we only</span></span><br><span class="line">        <span class="comment">// convert to `dq-&gt;dq_width * WIDTH_INTERVAL` when we drop `IN_BARRIER`</span></span><br><span class="line">        owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owned &amp;= DISPATCH_QUEUE_WIDTH_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dc = _dispatch_queue_head(dq);</span><br><span class="line">    <span class="keyword">goto</span> first_iteration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行自定义里面的任务，一个接一个执行，不能并行执行。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        dc = next_dc;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dic-&gt;dic_deferred)) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out_with_deferred_compute_owned;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_needs_to_return_to_kernel())) &#123;</span><br><span class="line">            _dispatch_return_to_kernel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dc)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dq-&gt;dq_items_tail) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dc = _dispatch_queue_head(dq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(serial_drain != (dq-&gt;dq_width == <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dispatch_queue_drain_should_narrow(dic))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">first_iteration:</span><br><span class="line">        dq_state = os_atomic_load(&amp;dq-&gt;dq_state, relaxed);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(_dq_state_is_suspended(dq_state))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(orig_tq != dq-&gt;do_targetq)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serial_drain || _dispatch_object_is_barrier(dc)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!serial_drain &amp;&amp; owned != DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_dispatch_queue_try_upgrade_full_width(dq, owned)) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_IN_BARRIER;</span><br><span class="line">            &#125;</span><br><span class="line">            next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">                owned = <span class="number">0</span>;</span><br><span class="line">                dic-&gt;dic_deferred = dc;</span><br><span class="line">                <span class="keyword">goto</span> out_with_deferred;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">                os_atomic_xor2o(dq, dq_state, owned, release);</span><br><span class="line">                owned = dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(owned == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">                    <span class="comment">// sync "readers" don't observe the limit</span></span><br><span class="line">                    _dispatch_queue_reserve_sync_width(dq);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_dispatch_queue_try_acquire_async(dq)) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> out_with_no_width;</span><br><span class="line">                &#125;</span><br><span class="line">                owned = DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (_dispatch_object_is_sync_waiter(dc)) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_sync_waiter_redirect_or_wake(dq,</span><br><span class="line">                        DISPATCH_SYNC_WAITER_NO_UNLOCK, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; DISPATCH_INVOKE_REDIRECTING_DRAIN) &#123;</span><br><span class="line">                owned -= DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">                _dispatch_continuation_redirect(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _dispatch_continuation_pop_inline(dc, dic, flags, dq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">        <span class="comment">// if we're IN_BARRIER we really own the full width too</span></span><br><span class="line">        owned += dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dc) &#123;</span><br><span class="line">        owned = _dispatch_queue_adjust_owned(dq, owned, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    *owned_ptr |= owned;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> dc ? dq-&gt;do_targetq : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_with_no_width:</span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> DISPATCH_QUEUE_WAKEUP_WAIT_FOR_EVENT;</span><br><span class="line"></span><br><span class="line">out_with_deferred_compute_owned:</span><br><span class="line">    <span class="keyword">if</span> (serial_drain) &#123;</span><br><span class="line">        owned = DISPATCH_QUEUE_IN_BARRIER + DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (owned == DISPATCH_QUEUE_IN_BARRIER) &#123;</span><br><span class="line">            <span class="comment">// if we're IN_BARRIER we really own the full width too</span></span><br><span class="line">            owned += dq-&gt;dq_width * DISPATCH_QUEUE_WIDTH_INTERVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dc) &#123;</span><br><span class="line">            owned = _dispatch_queue_adjust_owned(dq, owned, dc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out_with_deferred:</span><br><span class="line">    *owned_ptr &amp;= DISPATCH_QUEUE_ENQUEUED | DISPATCH_QUEUE_ENQUEUED_ON_MGR;</span><br><span class="line">    *owned_ptr |= owned;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; DISPATCH_INVOKE_DISALLOW_SYNC_WAITERS)) &#123;</span><br><span class="line">        DISPATCH_INTERNAL_CRASH(dc,</span><br><span class="line">                <span class="string">"Deferred continuation on source, mach channel or mgr"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">    <span class="keyword">return</span> dq-&gt;do_targetq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop_inline(<span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">        <span class="keyword">dispatch_invoke_context_t</span> dic, <span class="keyword">dispatch_invoke_flags_t</span> flags,</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_pthread_root_queue_observer_hooks_t</span> observer_hooks =</span><br><span class="line">            _dispatch_get_pthread_root_queue_observer_hooks();</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_will_execute(dq);</span><br><span class="line">    _dispatch_trace_continuation_pop(dq, dou);</span><br><span class="line">    flags &amp;= _DISPATCH_INVOKE_PROPAGATE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (_dispatch_object_has_vtable(dou)) &#123;</span><br><span class="line">        dx_invoke(dou._do, dic, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_continuation_invoke_inline(dou, DISPATCH_NO_VOUCHER, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer_hooks) observer_hooks-&gt;queue_did_execute(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_invoke_inline(<span class="keyword">dispatch_object_t</span> dou, <span class="keyword">voucher_t</span> ov,</span><br><span class="line">        <span class="keyword">dispatch_invoke_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    dispatch_invoke_with_autoreleasepool(flags, &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> dc_flags = dc-&gt;dc_flags;</span><br><span class="line">        _dispatch_continuation_voucher_adopt(dc, ov, dc_flags);</span><br><span class="line">        <span class="keyword">if</span> (dc_flags &amp; DISPATCH_OBJ_CONSUME_BIT) &#123;</span><br><span class="line">            dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dc1 = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc_flags &amp; DISPATCH_OBJ_GROUP_BIT)) &#123;</span><br><span class="line">            _dispatch_continuation_with_group_invoke(dc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用_dispatch_client_callout执行block</span></span><br><span class="line">            _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">            _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dc1)) &#123;</span><br><span class="line">            _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x10-dispatch-get-global-queue"><a href="#0x10-dispatch-get-global-queue" class="headerlink" title="0x10 dispatch_get_global_queue"></a>0x10 dispatch_get_global_queue</h1><p>&emsp;&emsp;可以发现，dispatch_get_global_queue其实就是取对应优先级的root队列拿来用。所以上面也提过，为啥在global_queue里面不能用barrier。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_get_global_queue(<span class="keyword">long</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(<span class="keyword">unsigned</span> <span class="keyword">long</span>)DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dispatch_qos_t</span> qos = _dispatch_qos_from_queue_priority(priority);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">        <span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_get_root_queue(qos, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(qos == DISPATCH_QOS_UNSPECIFIED || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(qos, <span class="string">"Corrupted priority"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span> * (qos - <span class="number">1</span>) + overcommit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener">GCD官方源码</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-使用篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/浅谈iOS多线程-使用篇/" itemprop="url">浅谈iOS多线程_使用篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T14:21:25+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-老生常谈"><a href="#0x01-老生常谈" class="headerlink" title="0x01 老生常谈"></a>0x01 老生常谈</h1><p>&emsp;&emsp;众所周知，多线程的合理使用可以提高CPU利用率，在实际开发中最常见的就是涉及大量计算以及网络请求的时候，都会新开一个线程，避免主线程被阻塞让用户觉得app卡顿。但凡事都不能过犹不及，滥用多线程也会给性能造成影响，毕竟线程之间的切换也是需要花费开销的。</p>
<p>&emsp;&emsp;既然叫多线程，那么线程之间肯定是有优先级区别的，在iOS中，有这么几种权限：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSQualityOfService</span>) &#123;</span><br><span class="line">    <span class="comment">// 用户交互权限，属于最高等级，常被用于处理交互事件或者刷新UI，因为这些需要即时的</span></span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInteractive</span> = <span class="number">0x21</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了可以进一步的后续操作，当用户发起请求结果需要被立即展示，比如当点了列表页某条信息后需要立即加载详情信息</span></span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInitiated</span> = <span class="number">0x19</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不需要马上就能得到结果，比如下载任务。当资源被限制后，此权限的任务将运行在节能模式下以提供更多资源给更高的优先级任务</span></span><br><span class="line">    <span class="built_in">NSQualityOfServiceUtility</span> = <span class="number">0x11</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后台权限，通常用户都不能意识到有任务正在进行，比如数据备份等。大多数处于节能模式下，需要把资源让出来给更高的优先级任务</span></span><br><span class="line">    <span class="built_in">NSQualityOfServiceBackground</span> = <span class="number">0x09</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认权限，具体权限由系统根据实际情况来决定使用哪个等级权限，如果实际情况不太利于决定使用何种权限，则从UserInitiated和Utility之间选一个权限并使用。</span></span><br><span class="line">    <span class="built_in">NSQualityOfServiceDefault</span> = <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="0x02-使用多线程"><a href="#0x02-使用多线程" class="headerlink" title="0x02 使用多线程"></a>0x02 使用多线程</h1><p>&emsp;&emsp;在iOS中，实现多线程常用的有三种方式：NSThread、GCD和NSOperation。</p>
<h3 id="1-NSThread"><a href="#1-NSThread" class="headerlink" title="1. NSThread"></a>1. NSThread</h3><h4 id="1-1-如何使用"><a href="#1-1-如何使用" class="headerlink" title="1.1 如何使用"></a>1.1 如何使用</h4><p>&emsp;&emsp;加上iOS10新增的，现在有5种初始化方法，具体初始化代码这边就不放了，实例方法中非block初始化的需要调用start方法进行线程开启：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)detachNewThreadWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block; <span class="comment">// iOS 10 新增</span></span><br><span class="line">+ (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block; <span class="comment">// iOS 10 新增</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;苹果更是为了程序员更方便的调用，直接在NSObject写了扩展，我们只要[self perform….]这样的调用，就能轻松开启一个线程。</p>
<p>&emsp;&emsp;在iOS 8开始，苹果给NSThread提供了<strong>qualityOfService</strong>属性来设置优先级，比如：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程1开始执行。。。"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(thread2Selector:) toTarget:<span class="keyword">self</span> withObject:<span class="string">@"test"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSThread</span> *thread3 = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程3开始执行。。。"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSThread</span> *thread4 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(thread4Selector:) object:<span class="string">@"test"</span>];</span><br><span class="line">    thread4.qualityOfService = <span class="built_in">NSQualityOfServiceUserInteractive</span>;</span><br><span class="line">    </span><br><span class="line">    [thread3 start];</span><br><span class="line">    [thread4 start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)thread2Selector:(<span class="keyword">id</span>)info &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程2开始执行。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)thread4Selector:(<span class="keyword">id</span>)info &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程4开始执行。。。"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;运行结果很清楚的看到，我设置了最高等级的线程4优先执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-01-02 16:05:09.599964+0800 HotPatch[54134:37810941] 线程4开始执行。。。</span><br><span class="line">2018-01-02 16:05:09.601452+0800 HotPatch[54134:37810939] 线程2开始执行。。。</span><br><span class="line">2018-01-02 16:05:09.602699+0800 HotPatch[54134:37810938] 线程1开始执行。。。</span><br><span class="line">2018-01-02 16:05:09.602698+0800 HotPatch[54134:37810940] 线程3开始执行。。。</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其他属性这里不做着重说明，API都有的，也都很好理解。</p>
<h4 id="1-2-总结"><a href="#1-2-总结" class="headerlink" title="1.2 总结"></a>1.2 总结</h4><p>&emsp;&emsp;我们可以看到，NSThread适用于业务场景不是很复杂的时候，属于比较轻量级的，同时在NSThread进行了相关拓展，所以开发中调用也极其方便。同时缺点也很明显，不能设置线程之间的依赖关系，需要手动管理睡眠唤醒等。</p>
<hr>
<h3 id="2-Grand-Central-Dispatch-GCD"><a href="#2-Grand-Central-Dispatch-GCD" class="headerlink" title="2. Grand Central Dispatch (GCD)"></a>2. Grand Central Dispatch (GCD)</h3><p>&emsp;&emsp;GCD是C实现的，所以效率相对更高，可以更好更方便的让并行代码执行在多核设备上，而且GCD是系统级的，帮助程序可以更合理的利用可用资源。跟NSThread相比，在使用GCD时我们并不需要手动管理任务，我们只需要把任务塞到队列里，系统的线程池会自动帮我们运行和销毁等。在ARC下，GCD的内存管理跟其他对象一样，在非ARC下，需要通过dispatch_retain和dispatch_release进行管理。<br>&emsp;&emsp;详细说GCD之前，我们先说说下面几个概念：并行、串行、同步和异步。  </p>
<ul>
<li>串行：任务是一个一个有顺序的执行，一个执行完以后才执行下一个。(有序的)  </li>
<li>并行：跟串行相反，任务是无序的执行，执行顺序没有顺序关系。（无序的）   </li>
<li>同步：需要等上一个任务执行完成后才能执行下一个任务。（依赖于上个任务是否执行完毕）  </li>
<li>异步：不需要等到上一个任务执行完成才执行下一个任务。（无需依赖于上个任务是否执行完毕）  </li>
</ul>
<p>&emsp;&emsp;在GCD里，我们通过<strong>DISPATCH_QUEUE_SERIAL</strong>和<strong>DISPATCH_QUEUE_CONCURRENT</strong>分别表示串行和并行；通过<strong>dispatch_sync</strong>和<strong>dispatch_async</strong>分别表示同步和异步。它们之间互相结合会碰撞出什么样的火花？我们下面通过代码看下结果：  </p>
<p>① 串行同步<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是串行同步的情况。</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serailQueue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serailQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serailQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serailQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第三只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;根据运行结果，串行同步的任务是<strong>在主线程上</strong>一个一个有顺序的完成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-01-03 09:22:59.451187+0800 HotPatch[84240:38942350] 在主线程上，第一只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:22:59.451341+0800 HotPatch[84240:38942350] 在主线程上，第二只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:22:59.451450+0800 HotPatch[84240:38942350] 在主线程上，第三只熊猫向你走过来...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接着，我们观察下串行异步的结果会是如何？  </p>
<p>② 串行异步<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serailQueue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serailQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(serailQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(serailQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第三只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，熊猫妈妈在找熊猫宝宝..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;根据结果，我们可以看到，串行异步的情况下，新开辟了一条线程，该线程上的执行任务的顺序是有序的，而主线程上的任务是与该线程是并行执行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-01-03 09:24:04.200707+0800 HotPatch[84293:38945063] 在主线程上，熊猫妈妈在找熊猫宝宝...</span><br><span class="line">2018-01-03 09:24:04.200707+0800 HotPatch[84293:38945539] 非主线程上，第一只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:24:04.200874+0800 HotPatch[84293:38945539] 非主线程上，第二只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:24:04.200969+0800 HotPatch[84293:38945539] 非主线程上，第三只熊猫向你走过来...</span><br></pre></td></tr></table></figure></p>
<p>③ 并行同步<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第三只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，熊猫妈妈在找熊猫宝宝..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;根据结果来看，虽然是在并行队列上，但是并没有新开线程，都是在主线程上按顺序来执行任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-01-03 09:30:56.633674+0800 HotPatch[84466:38953980] 在主线程上，第一只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:30:56.633827+0800 HotPatch[84466:38953980] 在主线程上，第二只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:30:56.633913+0800 HotPatch[84466:38953980] 在主线程上，第三只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:30:56.633992+0800 HotPatch[84466:38953980] 在主线程上，熊猫妈妈在找熊猫宝宝...</span><br></pre></td></tr></table></figure></p>
<p>④ 并行异步<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第三只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，熊猫妈妈在找熊猫宝宝..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;根据结果来看，并行异步下，会开启多个线程执行任务，他们之间的顺序包括主线程是无序的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-01-03 09:36:48.246392+0800 HotPatch[84632:38962053] 非主线程上，第二只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:36:48.246392+0800 HotPatch[84632:38962045] 非主线程上，第一只熊猫向你走过来...</span><br><span class="line">2018-01-03 09:36:48.246392+0800 HotPatch[84632:38961995] 在主线程上，熊猫妈妈在找熊猫宝宝...</span><br><span class="line">2018-01-03 09:36:48.246392+0800 HotPatch[84632:38962046] 非主线程上，第三只熊猫向你走过来...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;前面我们已经说过，串行异步，会新开一个线程，该线程里的任务按顺序执行，那么，我新建了多个串行队列，那么他们之间的关系是怎么样的？是不是也是按照顺序排排坐吃果果呢？<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue1, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test2"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue3 = dispatch_queue_create(<span class="string">"com.zhaomu.test3"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue3, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第三只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue3, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第四只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，熊猫妈妈在找熊猫宝宝..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;根据下面的运行结果可以看到开了多个串行队列的情况下，多个串行队列之间可能是并行执行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-01-03 10:09:58.754283+0800 HotPatch[85801:39008283] 在主线程上，熊猫妈妈在找熊猫宝宝...</span><br><span class="line">2018-01-03 10:09:58.754287+0800 HotPatch[85801:39008328] 非主线程上，第二只熊猫向你走过来...</span><br><span class="line">2018-01-03 10:09:58.754287+0800 HotPatch[85801:39008330] 非主线程上，第一只熊猫向你走过来...</span><br><span class="line">2018-01-03 10:09:58.754287+0800 HotPatch[85801:39008329] 非主线程上，第三只熊猫向你走过来...</span><br><span class="line">2018-01-03 10:09:58.754514+0800 HotPatch[85801:39008329] 非主线程上，第四只熊猫向你走过来...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，他们四者之间的关系大致搞清楚了，那么这里遗留一个问题，下面的代码会有什么问题？为什么会导致这样的问题？<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，熊猫妈妈在找熊猫宝宝..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-创建队列"><a href="#2-1-创建队列" class="headerlink" title="2.1 创建队列"></a>2.1 创建队列</h4><p>&emsp;&emsp;之前在了解串行、并行、同步和异步的时候，已经看到可以通过dispatch_queue_create创建一个队列。那么还有其他方法吗？相信大家已经很快想到了:<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对于这两个方法，也没有什么特别要讲的，相信大家在实际开发中也已经用了很多很多了。只是提一点，dispatch_get_global_queue得到的队列， dispatch_suspend，dispatch_resume和dispatch_set_context函数对其是无效的，具体的后面再详细说明。<br>&emsp;&emsp;回到dispatch_queue_create方法，之前只是说了可以设置参数来控制返回的是串行还是并行队列，但是如果我想对这个队列进行优先级设置，我们该怎么做呢？<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_USER_INTERACTIVE, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, attr_t);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;dispatch_queue_attr_make_with_qos_class函数可以设置队列优先级，它的第二个参数设置优先级。这里的优先级有这几个选择，也有其对应的宏定义。具体解释可以对应本文开头的优先级解释：</p>
<ul>
<li><strong>QOS_CLASS_USER_INTERACTIVE</strong> （DISPATCH_QUEUE_PRIORITY_HIGH）</li>
<li><strong>QOS_CLASS_USER_INITIATED</strong> （DISPATCH_QUEUE_PRIORITY_HIGH）</li>
<li><strong>QOS_CLASS_UTILITY</strong> （DISPATCH_QUEUE_PRIORITY_LOW）</li>
<li><strong>QOS_CLASS_DEFAULT</strong> （DISPATCH_QUEUE_PRIORITY_DEFAULT）</li>
<li><strong>QOS_CLASS_BACKGROUND</strong> （DISPATCH_QUEUE_PRIORITY_BACKGROUND）   </li>
</ul>
<p>&emsp;&emsp;dispatch_queue_attr_make_with_qos_class函数的第三个参数，需要填写一个<strong>负数</strong>的偏移值，小于0且大于等于-15(QOS_MIN_RELATIVE_PRIORITY即表示为-15)，必须这么填，不然函数会返回一个null。这个参数主要作用是在你给定的优先级系统不能满足的情况下，如果需要调度的话，给定一个调度偏移值。</p>
<p>&emsp;&emsp;当然，我们还可以通过<strong>dispatch_set_target_queue</strong>给目标队列设置优先级，比如设置权限前，我们的代码是这样的：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_get_global_queue(<span class="built_in">NSQualityOfServiceUserInitiated</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_get_global_queue(<span class="built_in">NSQualityOfServiceUserInteractive</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">55.094364</span>+<span class="number">0800</span> HotPatch[<span class="number">87483</span>:<span class="number">39063303</span>] 非主线程上，第二只熊猫向你走过来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">55.094374</span>+<span class="number">0800</span> HotPatch[<span class="number">87483</span>:<span class="number">39063315</span>] 非主线程上，第一只熊猫向你走过来...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;将第二个队列权限设置为第一个队列一样：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_get_global_queue(<span class="built_in">NSQualityOfServiceUserInitiated</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_get_global_queue(<span class="built_in">NSQualityOfServiceUserInteractive</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_set_target_queue(queue2, queue1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">54.485234</span>+<span class="number">0800</span> HotPatch[<span class="number">87580</span>:<span class="number">39067563</span>] 非主线程上，第一只熊猫向你走过来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">54.485234</span>+<span class="number">0800</span> HotPatch[<span class="number">87580</span>:<span class="number">39067564</span>] 非主线程上，第二只熊猫向你走过来...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>dispatch_set_target_queue</strong>除了可以设置优先级，同样可以设置队列类型，比如如下面的代码，其结果因为可以多开线程，所以其运行顺序是无序的：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第三只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，熊猫妈妈在找熊猫宝宝..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">07.245436</span>+<span class="number">0800</span> HotPatch[<span class="number">87849</span>:<span class="number">39079716</span>] 非主线程上，第二只熊猫向你走过来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">07.245431</span>+<span class="number">0800</span> HotPatch[<span class="number">87849</span>:<span class="number">39079659</span>] 在主线程上，熊猫妈妈在找熊猫宝宝...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">07.245436</span>+<span class="number">0800</span> HotPatch[<span class="number">87849</span>:<span class="number">39079717</span>] 非主线程上，第一只熊猫向你走过来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">07.245436</span>+<span class="number">0800</span> HotPatch[<span class="number">87849</span>:<span class="number">39079714</span>] 非主线程上，第三只熊猫向你走过来...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;现在我的需求是，队列1执行完后，我再去执行队列2，可以修改如下：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_set_target_queue(queue2, queue1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第一只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第二只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，第三只熊猫向你走过来..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@主线程上，熊猫妈妈在找熊猫宝宝..."</span>, [<span class="built_in">NSThread</span> isMainThread] ? <span class="string">@"在"</span> : <span class="string">@"非"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">16.703801</span>+<span class="number">0800</span> HotPatch[<span class="number">88657</span>:<span class="number">39110595</span>] 在主线程上，熊猫妈妈在找熊猫宝宝...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">16.703801</span>+<span class="number">0800</span> HotPatch[<span class="number">88657</span>:<span class="number">39110643</span>] 非主线程上，第一只熊猫向你走过来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">16.703987</span>+<span class="number">0800</span> HotPatch[<span class="number">88657</span>:<span class="number">39110643</span>] 非主线程上，第二只熊猫向你走过来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">16.704185</span>+<span class="number">0800</span> HotPatch[<span class="number">88657</span>:<span class="number">39110643</span>] 非主线程上，第三只熊猫向你走过来...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是，这里dispatch_set_target_queue设置时机是设置block任务之前，同时不能循环设置，比如上面把queue1设置给了queue2，如果在queue2设置给queue1，这样会导致问题。</p>
<h4 id="2-2-设置队列标识"><a href="#2-2-设置队列标识" class="headerlink" title="2.2 设置队列标识"></a>2.2 设置队列标识</h4><p>&emsp;&emsp;通过dispatch_queue_set_specific可以设置队列标识，然后通过dispatch_get_specific来帮助我们判断是否在某个队列中。其中参数key是个标识符，用来绑定所对应队列的上下文环境，举个例子：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *key = <span class="string">"key"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_set_specific(queue1, key, &amp;key, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(testSelector) withObject:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test2"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(testSelector2) withObject:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testSelector &#123;</span><br><span class="line">    <span class="keyword">if</span>(dispatch_get_specific(key)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"这个key所属的队列是queue1队列"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"这个key所属的队列不是queue1队列"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testSelector2 &#123;</span><br><span class="line">    <span class="keyword">if</span>(dispatch_get_specific(key)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"这个key所属的队列是queue2队列"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"这个key所属的队列不是queue2队列"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">14</span>:<span class="number">02</span>:<span class="number">16.396954</span>+<span class="number">0800</span> HotPatch[<span class="number">92482</span>:<span class="number">39270353</span>] 这个key所属的队列不是queue2队列</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-03</span> <span class="number">14</span>:<span class="number">02</span>:<span class="number">16.396960</span>+<span class="number">0800</span> HotPatch[<span class="number">92482</span>:<span class="number">39270355</span>] 这个key所属的队列是queue1队列</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;看了api可能会有疑问，dispatch_queue_get_specific和dispatch_get_specific，有什么区别？<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * dispatch_queue_get_specific(<span class="built_in">dispatch_queue_t</span> queue, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="keyword">void</span> * dispatch_get_specific(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;前者比后者多传了一个队列参数，所以显而易见，前者判断的是所传队列的上下文数据是不是绑定为标识符为key的；而后者则是判断当前所在上下文环境是不是标识符为key的。<br>&emsp;&emsp;细心的朋友可能会问，既然是标识符，那api里还有个dispatch_queue_get_label是干嘛用的？我们之前调用dispatch_queue_create函数的时候，第一个参数就是label。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个label，可以在debug的时候，用于显示当前线程所在队列的名称，如下图：<img src="thread_label.png" alt="线程label示例"><br>&emsp;&emsp;那么label还有什么用处？相信肯定有的人唰唰唰写出如下代码，当然这也不是说不可以:<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(testSelector) withObject:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testSelector &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *labelName = [<span class="built_in">NSString</span> stringWithUTF8String:dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)];</span><br><span class="line">    <span class="keyword">if</span> ([labelName isEqualToString:<span class="string">@"com.zhaomu.test1"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"现在所处queue1队列"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么问题又来了，如何判断当前是否是主线程，相信很快有人会回答[NSThread isMainThread]！！！那么，我们知道一个主线程可以有多个队列，那么如何判断是否在主队列呢？<br>&emsp;&emsp;这里介绍两种方法：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line">    dispatch_queue_set_specific(mainQueue, key, &amp;key, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(testSelector) withObject:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testSelector &#123;</span><br><span class="line">    <span class="keyword">if</span>(dispatch_get_specific(key)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"注意，这里是主线程主队列！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line">    <span class="built_in">NSString</span> *currentLabel = [<span class="built_in">NSString</span> stringWithUTF8String:dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)];</span><br><span class="line">    <span class="built_in">NSString</span> *mainLabel = [<span class="built_in">NSString</span> stringWithUTF8String:dispatch_queue_get_label(dispatch_get_main_queue())];</span><br><span class="line">    <span class="keyword">if</span>([currentLabel isEqualToString:mainLabel]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"注意，这里是主线程主队列！！！"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-dispatch-after"><a href="#2-3-dispatch-after" class="headerlink" title="2.3 dispatch_after"></a>2.3 dispatch_after</h4><p>&emsp;&emsp;这个函数，大家肯定不陌生，用的也肯定滚瓜烂熟。这个函数的作用就是倒计时的时间到了后，将block任务添加到指定的队列里面去，然后执行。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 1秒后去做的事情</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;复习时间到了，那么我给出如下代码，dispatch_after里面的代码会在1秒后执行吗？<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"本次操作需要2秒，操作完成"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"本次操作需要5秒，操作完成"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), queue, ^&#123;</span><br><span class="line">    <span class="comment">// 1秒后去做的事情</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1秒后能来到这吗"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;答案是并不会，我们前面说过，并行同步是排排坐吃果果的，是按顺序执行任务的，dispatch_after一秒后的确把任务提交到队列了，但是因为前面的任务还没有完成，所以它也就只能乖乖等着了。<br>&emsp;&emsp;谈到延时执行，肯定大家还会想到另一个方法：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么这个方法跟dispatch_after又有什么区别呢？观察下面的代码，我的疑问就是熊猫宝宝会向您奔来吗，也就是会不会执行testSelector方法？<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(testSelector) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"一只熊猫宝宝向您奔来...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;答案是否定的，方法并没有执行。这是为什么呢？performSelector:afterDelay方法内部其实有个NSTimer定时器，需要把定时器加到runloop进行执行，所以这个方法需要依赖runloop，那么我们必须知道的是，开启的子线程默认是没有runloop的，所以导致testSelector方法没有被执行。而dispatch_after并没有这个问题。<br>&emsp;&emsp;拓展一下，GCD中除了dispatch_after，还有一种类似于NSTimer的计时器，也就是通过dispatch_source来设置定时器。其实如果看源码dispatch_after内部也是通过dispatch_source进行实现的。这里只是先做介绍，后面到dispatch_source章节再详细说明。</p>
<h4 id="2-4-dispatch-once"><a href="#2-4-dispatch-once" class="headerlink" title="2.4 dispatch_once"></a>2.4 dispatch_once</h4><p>&emsp;&emsp;这个函数常用于构造一份唯一的实例，用于app内存域中达到资源共享。所以有时候我们看到一个项目里会有很多单例。那么，我们是否思考过，真的有必要在app里使用很多的单例，那么如果使用不当会造成什么后果？<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> once];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)once &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> once];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"遇到一只熊猫宝宝..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> once];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)once &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> otherOnce];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"遇到第一只熊猫宝宝..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherOnce &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> once];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"遇到第二只熊猫宝宝..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们看下栈的追踪，可以发现死锁了，具体原因在下篇GCD源码篇具体说明。<img src="dipatch_once.png" alt="dipatch_once示例"><br>&emsp;&emsp;除了单例这种方式，是否还有别的方式能达到资源共享？在Xcode 8开始，支持了类属性：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">class</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;所以，我们可以利用这个新的特性，来完成资源共享。</p>
<h4 id="2-5-dispatch-block"><a href="#2-5-dispatch-block" class="headerlink" title="2.5 dispatch_block"></a>2.5 dispatch_block</h4><p>&emsp;&emsp;dipatch_block，可以理解为一个block对象，拿到这个对象可以让我们独立操作一个任务，我们可以更灵活的操作一个任务，比如等待、执行以及监听任务的完成，以便在这个任务完成后去做些什么。<br>&emsp;&emsp;一般来说，我们可以这样定义一个GCD的block对象。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_block_t block = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"一只熊脑宝宝向你奔来..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block);</span><br></pre></td></tr></table></figure></p>
<h5 id="2-5-1-dispatch-block-create"><a href="#2-5-1-dispatch-block-create" class="headerlink" title="2.5.1 dispatch_block_create"></a>2.5.1 dispatch_block_create</h5><p>&emsp;&emsp;当然，一般开发场景下并不需要这么啰嗦的实现方式，没必要把block单独拿出来。而且需要注意的是，上面的声明方式，这个block是在栈上的。我们还有一种初始化block对象的方式，但是说这个之前，我们先了解下面枚举值的意思：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="keyword">unsigned</span> <span class="keyword">long</span> &#123;</span><br><span class="line">    <span class="comment">// 当提交到DISPATCH_QUEUE_CONCURRENT队列，类似于dispatch_barrier_async（后面会介绍）作用。如果标记为这个的block对象被直接调用，将没有barrier效果。</span></span><br><span class="line">    DISPATCH_BLOCK_BARRIER,</span><br><span class="line">    <span class="comment">// block对象将解除与当前执行上下文属性的关联，如果直接调用，在分配给block属性之前，在调用线程上block对象将在block任务执行期间移出这些属性。如果提交到队列，block对象将使用队列属性或者分配给Block对象的属性。</span></span><br><span class="line">    DISPATCH_BLOCK_DETACHED,</span><br><span class="line">    <span class="comment">// Block对象被创建的同时会为block对象分配执行上下文属性。如果直接调用，block对象将在block任务执行期间将这些属性应用于调用线程。如果block任务被提交到队列，则这个标识将在提交队列的同时会替换其所关联的block对象默认的上下文属性。</span></span><br><span class="line">    DISPATCH_BLOCK_ASSIGN_CURRENT,</span><br><span class="line">    <span class="comment">// 表示不能设置优先级属性给block，如果block被直接调用，将会使用当前线程的优先级。如果被提交到队列，在提交到队列的同时将会取消原来的优先级属性。在dispatch_block_create_with_qos_class函数中，这个属性无效。</span></span><br><span class="line">    DISPATCH_BLOCK_NO_QOS_CLASS,</span><br><span class="line">    <span class="comment">// block和队列同时有优先级属性的情况下，优先使用队列的优先级。当队列没有优先级属性的情况下，block的优先级才会被采用，当block被执行调用，这个属性无效；如果被提交到并行异步队列，这个属性是默认的。</span></span><br><span class="line">    DISPATCH_BLOCK_INHERIT_QOS_CLASS。</span><br><span class="line">    <span class="comment">// block的优先级属性要高于队列的优先级属性。如果block被直接调用或被提交到并行同步队列，这个属性是默认的</span></span><br><span class="line">    DISPATCH_BLOCK_ENFORCE_QOS_CLASS</span><br><span class="line">&#125; dispatch_block_flags_t;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;dispatch_block_create也可以创建一个block对象，并且重点是分配在堆上的，在创建 的时候，可以设置一个标识位，就是上面说的那几个。<br>&emsp;&emsp;创建出来的block提交到队列的时候同时会为block赋值一个默认的优先级属性，但也有例外，这三个标识位就不会默认设置优先级，分别是DISPATCH_BLOCK_ASSIGN_CURRENT、DISPATCH_BLOCK_NO_QOS_CLASS和DISPATCH_BLOCK_DETACHED。<br>&emsp;&emsp;当Block队列放入并行同步队列，DISPATCH_BLOCK_ENFORCE_QOS_CLASS 是默认的。当被放入并行异步队列，DISPATCH_BLOCK_INHERIT_QOS_CLASS是默认的。如果一个被赋值了优先级属性的block对象被放入到一个串行队列，那么系统将会尽可能的让已经在前面的block对象与这个block对象拥有一个优先级或者更高优先级，以让之前的block任务优先执行。<br>&emsp;&emsp;前面说到可以给block设置优先级，所以先介绍下dispatch_block_create_with_qos_class函数，跟之前dispatch_block_create相比，多了一个dispatch_qos_class_t属性，用来设置优先级，以及relative_priority属性，表示偏移值，这个参数主要作用是在你给定的优先级系统不能满足的情况下，如果需要调度的话，给定一个调度偏移值。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, attr_t);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test2"</span>, attr_t);</span><br><span class="line">    dispatch_block_t block1 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_block_t block2 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_USER_INTERACTIVE, <span class="number">-1</span>, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_block_t block3 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, block1);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, block2);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, block3);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从运行结果来看，我们使用了DISPATCH_BLOCK_INHERIT_QOS_CLASS标记位，使得block的优先级高于队列的优先级，所以block2始终优先执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-01-06 21:00:46.583204+0800 HotPatch[4917:43250223] 第二只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-06 21:00:46.583230+0800 HotPatch[4917:43250226] 第一只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-06 21:00:46.583239+0800 HotPatch[4917:43250225] 第三只熊猫宝宝向你奔来...</span><br></pre></td></tr></table></figure></p>
<h5 id="2-5-2-dispatch-block-perform"><a href="#2-5-2-dispatch-block-perform" class="headerlink" title="2.5.2 dispatch_block_perform"></a>2.5.2 dispatch_block_perform</h5><p>&emsp;&emsp;直接执行block，使用这个函数，对block设置优先级是无效的。当然也直接比如block()这样执行block，效果是一样的：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_block_t block1 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_block_t block2 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_DETACHED, QOS_CLASS_USER_INTERACTIVE, <span class="number">-1</span>, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_perform(DISPATCH_BLOCK_DETACHED, block1);</span><br><span class="line">    block2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-06</span> <span class="number">21</span>:<span class="number">15</span>:<span class="number">24.000871</span>+<span class="number">0800</span> HotPatch[<span class="number">5329</span>:<span class="number">43266428</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-06</span> <span class="number">21</span>:<span class="number">15</span>:<span class="number">24.001041</span>+<span class="number">0800</span> HotPatch[<span class="number">5329</span>:<span class="number">43266428</span>] 第二只熊猫宝宝向你奔来...</span><br></pre></td></tr></table></figure></p>
<h5 id="2-5-2-dispatch-block-wait"><a href="#2-5-2-dispatch-block-wait" class="headerlink" title="2.5.2 dispatch_block_wait"></a>2.5.2 dispatch_block_wait</h5><p>&emsp;&emsp;这个函数的作用是等待block任务完成，再继续往下执行代码。需要注意的是，这个函数的使用是要在立即执行命令之后，或者加入到队列之后。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, attr_t);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test2"</span>, attr_t);</span><br><span class="line">dispatch_block_t block1 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_block_t block2 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝已经抱住你大腿..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_t block3 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, block1);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, block2);</span><br><span class="line"></span><br><span class="line">dispatch_block_wait(block2, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, block3);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈在找熊猫宝宝..."</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;看到运行结果，直到block2的任务完成，下面的命令才会被继续执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-01-07 09:30:37.900512+0800 HotPatch[7042:43373020] 第二只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-07 09:30:37.900488+0800 HotPatch[7042:43373010] 第一只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-07 09:30:42.971854+0800 HotPatch[7042:43373020] 第二只熊猫宝宝已经抱住你大腿...</span><br><span class="line">2018-01-07 09:30:42.972097+0800 HotPatch[7042:43372948] 熊猫妈妈在找熊猫宝宝...</span><br><span class="line">2018-01-07 09:30:42.972101+0800 HotPatch[7042:43373010] 第三只熊猫宝宝向你奔来...</span><br></pre></td></tr></table></figure></p>
<h5 id="2-5-3-dispatch-block-notify"><a href="#2-5-3-dispatch-block-notify" class="headerlink" title="2.5.3 dispatch_block_notify"></a>2.5.3 dispatch_block_notify</h5><p>&emsp;&emsp;这个函数起到通知的作用，也就是当这个函数监听的任务完成后，会执行dispatch_block_notify函数自己的任务。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, attr_t);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test2"</span>, attr_t);</span><br><span class="line">dispatch_block_t block1 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_block_t block2 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝已经抱住你大腿..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_t block3 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, block1);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, block2);</span><br><span class="line"></span><br><span class="line">dispatch_block_notify(block2, queue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"捕获一个熊猫宝宝..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, block3);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈在找熊猫宝宝..."</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们可以看到，dispatch_block_notify的block任务会在block2任务完成后被调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2018-01-07 09:35:17.368299+0800 HotPatch[7252:43379370] 熊猫妈妈在找熊猫宝宝...</span><br><span class="line">2018-01-07 09:35:17.368419+0800 HotPatch[7252:43379414] 第一只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-07 09:35:17.368538+0800 HotPatch[7252:43379416] 第二只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-07 09:35:17.368558+0800 HotPatch[7252:43379423] 第三只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-07 09:35:22.369035+0800 HotPatch[7252:43379416] 第二只熊猫宝宝已经抱住你大腿...</span><br><span class="line">2018-01-07 09:35:22.369436+0800 HotPatch[7252:43379416] 捕获一个熊猫宝宝...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么，dispatch_block_notify函数的block任务是不是一定是在监听的任务完成后马上调用呢，事实是并不一定的，如果dispatch_block_notify函数的的block任务所在线程前面还有任务没有被执行完毕，那么这个block任务需要等待前面任务的完成，也就没有及时性了。我们举个例子，在串行队列中，就会很明显感到这个：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, attr_t);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test2"</span>, attr_t);</span><br><span class="line">    dispatch_block_t block1 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_block_t block2 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝已经抱住你大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_block_t block3 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">8</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝已经抱住你大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t block4 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue1, block1);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue2, block2);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue2, block3);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_notify(block2, queue2, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"捕获一个熊猫宝宝..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue2, block4);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈在找熊猫宝宝..."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">09</span>:<span class="number">45</span>:<span class="number">29.295842</span>+<span class="number">0800</span> HotPatch[<span class="number">7413</span>:<span class="number">43393215</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">09</span>:<span class="number">45</span>:<span class="number">29.295967</span>+<span class="number">0800</span> HotPatch[<span class="number">7413</span>:<span class="number">43393215</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">09</span>:<span class="number">45</span>:<span class="number">32.297043</span>+<span class="number">0800</span> HotPatch[<span class="number">7413</span>:<span class="number">43393215</span>] 第二只熊猫宝宝已经抱住你大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">09</span>:<span class="number">45</span>:<span class="number">32.297180</span>+<span class="number">0800</span> HotPatch[<span class="number">7413</span>:<span class="number">43393215</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">09</span>:<span class="number">45</span>:<span class="number">40.298124</span>+<span class="number">0800</span> HotPatch[<span class="number">7413</span>:<span class="number">43393215</span>] 第三只熊猫宝宝已经抱住你大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">09</span>:<span class="number">45</span>:<span class="number">40.298385</span>+<span class="number">0800</span> HotPatch[<span class="number">7413</span>:<span class="number">43393215</span>] 第四只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">09</span>:<span class="number">45</span>:<span class="number">40.298400</span>+<span class="number">0800</span> HotPatch[<span class="number">7413</span>:<span class="number">43393272</span>] 捕获一个熊猫宝宝...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">09</span>:<span class="number">45</span>:<span class="number">40.298521</span>+<span class="number">0800</span> HotPatch[<span class="number">7413</span>:<span class="number">43393215</span>] 熊猫妈妈在找熊猫宝宝...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果一个block任务被多个监听，那么这几个dispatch_block_notify函数的回调并不是有序的，也就是说并不是写在前面，这个回调最先执行，而是看所在队列，如果谁先被轮到执行就是谁优先。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, attr_t);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test2"</span>, attr_t);</span><br><span class="line">    dispatch_block_t block1 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_block_t block2 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝已经抱住你大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t block3 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue1, block1);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue2, block2);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_notify(block2, queue2, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"捕获一个熊猫宝宝1..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_notify(block2, queue1, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"捕获一个熊猫宝宝2..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue2, block3);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈在找熊猫宝宝..."</span>);</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">01</span>:<span class="number">01.608315</span>+<span class="number">0800</span> HotPatch[<span class="number">7755</span>:<span class="number">43410127</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">01</span>:<span class="number">01.608485</span>+<span class="number">0800</span> HotPatch[<span class="number">7755</span>:<span class="number">43410127</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">01</span>:<span class="number">04.608668</span>+<span class="number">0800</span> HotPatch[<span class="number">7755</span>:<span class="number">43410127</span>] 第二只熊猫宝宝已经抱住你大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">01</span>:<span class="number">04.608838</span>+<span class="number">0800</span> HotPatch[<span class="number">7755</span>:<span class="number">43410127</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">01</span>:<span class="number">04.608862</span>+<span class="number">0800</span> HotPatch[<span class="number">7755</span>:<span class="number">43410172</span>] 捕获一个熊猫宝宝<span class="number">2.</span>..</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">01</span>:<span class="number">04.608866</span>+<span class="number">0800</span> HotPatch[<span class="number">7755</span>:<span class="number">43410182</span>] 捕获一个熊猫宝宝<span class="number">1.</span>..</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">01</span>:<span class="number">04.608929</span>+<span class="number">0800</span> HotPatch[<span class="number">7755</span>:<span class="number">43410127</span>] 熊猫妈妈在找熊猫宝宝...</span><br></pre></td></tr></table></figure></p>
<h5 id="2-5-4-dispatch-block-cancel"><a href="#2-5-4-dispatch-block-cancel" class="headerlink" title="2.5.4 dispatch_block_cancel"></a>2.5.4 dispatch_block_cancel</h5><p>&emsp;&emsp;这个函数的作用就是取消block任务，但是前提就是这个block还没有被执行。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.zhaomu.test1"</span>, attr_t);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.zhaomu.test2"</span>, attr_t);</span><br><span class="line">dispatch_block_t block1 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_block_t block2 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝已经抱住你大腿..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_t block3 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, block1);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, block2);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, block3);</span><br><span class="line"></span><br><span class="line">dispatch_block_cancel(block3);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;运行结果可以看到，block3是没有被执行的，已经被取消了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-01-07 18:46:13.991672+0800 HotPatch[8198:43441461] 第一只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-07 18:46:13.991672+0800 HotPatch[8198:43441459] 第二只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-07 18:46:17.063260+0800 HotPatch[8198:43441459] 第二只熊猫宝宝已经抱住你大腿...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是内存问题，如果这个Block是做内存释放的操作，如果block被取消了，会造成内存问题。</p>
<h5 id="2-5-6-dispatch-block-suspend、dispatch-block-resume"><a href="#2-5-6-dispatch-block-suspend、dispatch-block-resume" class="headerlink" title="2.5.6 dispatch_block_suspend、dispatch_block_resume"></a>2.5.6 dispatch_block_suspend、dispatch_block_resume</h5><p>&emsp;&emsp;只适用于自定义的队列，不适用于dispatch_get_global_queue等。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t block1 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t block2 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t block3 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝抱住你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_suspend(queue);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, block1);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, block2);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, block3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈正在找熊猫宝宝...."</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">    dispatch_resume(queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">35.628261</span>+<span class="number">0800</span> HotPatch[<span class="number">95183</span>:<span class="number">56902962</span>] 熊猫妈妈正在找熊猫宝宝....</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">38.629397</span>+<span class="number">0800</span> HotPatch[<span class="number">95183</span>:<span class="number">56903020</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">38.629410</span>+<span class="number">0800</span> HotPatch[<span class="number">95183</span>:<span class="number">56903012</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">38.629412</span>+<span class="number">0800</span> HotPatch[<span class="number">95183</span>:<span class="number">56903019</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">43.629721</span>+<span class="number">0800</span> HotPatch[<span class="number">95183</span>:<span class="number">56903020</span>] 第一只熊猫宝宝抱住你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">43.629721</span>+<span class="number">0800</span> HotPatch[<span class="number">95183</span>:<span class="number">56903019</span>] 第三只熊猫宝宝抱住你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">43.629721</span>+<span class="number">0800</span> HotPatch[<span class="number">95183</span>:<span class="number">56903012</span>] 第二只熊猫宝宝抱住你的大腿...</span><br></pre></td></tr></table></figure></p>
<h4 id="2-6-dispatch-group"><a href="#2-6-dispatch-group" class="headerlink" title="2.6 dispatch_group"></a>2.6 dispatch_group</h4><p>&emsp;&emsp;在实际开发中，我们经常会遇到一种情况，就是需要调用多个接口，然后等接口都请求完毕后，我们再去处理一些事情，比如UI更新等。那么这种情况，可以有多种实现方法，其中之一就是这里要介绍的 – dispatch_group。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, attr_t);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫抱住你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫抱住你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"捕获所有熊猫宝宝..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">22.261748</span>+<span class="number">0800</span> HotPatch[<span class="number">12918</span>:<span class="number">43636778</span>] 第一只熊猫向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">22.261746</span>+<span class="number">0800</span> HotPatch[<span class="number">12918</span>:<span class="number">43636779</span>] 第二只熊猫向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">25.334679</span>+<span class="number">0800</span> HotPatch[<span class="number">12918</span>:<span class="number">43636779</span>] 第二只熊猫抱住你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">25.334679</span>+<span class="number">0800</span> HotPatch[<span class="number">12918</span>:<span class="number">43636778</span>] 第一只熊猫抱住你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">08</span>:<span class="number">55</span>:<span class="number">25.334900</span>+<span class="number">0800</span> HotPatch[<span class="number">12918</span>:<span class="number">43636779</span>] 捕获所有熊猫宝宝...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;dispatch_group_notify并不是阻塞线程的，如果想要任务没有完成不必继续往下执行，我们可以使用到dispatch_group_wait函数，起到阻塞线程的作用，当然建议是如果情非得已，不是很推荐使用这样的方式。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, attr_t);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫抱住你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫抱住你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"捕获所有熊猫宝宝..."</span>);</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">28.990738</span>+<span class="number">0800</span> HotPatch[<span class="number">13852</span>:<span class="number">43662410</span>] 第一只熊猫向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">28.990723</span>+<span class="number">0800</span> HotPatch[<span class="number">13852</span>:<span class="number">43662408</span>] 第二只熊猫向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">32.062137</span>+<span class="number">0800</span> HotPatch[<span class="number">13852</span>:<span class="number">43662410</span>] 第一只熊猫抱住你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">32.062137</span>+<span class="number">0800</span> HotPatch[<span class="number">13852</span>:<span class="number">43662408</span>] 第二只熊猫抱住你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-08</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">32.062398</span>+<span class="number">0800</span> HotPatch[<span class="number">13852</span>:<span class="number">43662317</span>] 捕获所有熊猫宝宝...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;想必，可能很多人有这样的疑问，项目中，大多数后台接口的调用的方式是这样的：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> [[RequestManager shareInstance] getxxxxSuccess:^&#123;</span><br><span class="line">        </span><br><span class="line">&#125; failure:^&#123;</span><br><span class="line">        </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么，如何把这样的任务，也加入到dispatch_group_t中呢？这时候需要用到这么一对函数：dispatch_group_enter和dispatch_group_leave。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, attr_t);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">[[RequestManager shareInstance] getxxxxSuccess:^&#123;</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">&#125; failure:^&#123;</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接口请求完毕..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当然，除了dispatch_group可以达到我们的需求，那有没有其他方法也可以实现这个功能呢？</p>
<h4 id="2-7-dispatch-semaphore"><a href="#2-7-dispatch-semaphore" class="headerlink" title="2.7 dispatch_semaphore"></a>2.7 dispatch_semaphore</h4><p>&emsp;&emsp;dispatch_semaphore的作用除了可以加锁还可以保持线程同步。首先了解两个函数，dispatch_semaphore_signal表示信号量+1,dispatch_semaphore_wait表示如果信号量为0则进行等待，如果不为1，则继续往下执行并-1。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, attr_t);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住你大腿..."</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住你大腿..."</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈在找熊猫宝宝..."</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的代码展示了线程同步的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-01-09 09:05:18.659970+0800 HotPatch[2324:47129676] 第一只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-09 09:05:18.659970+0800 HotPatch[2324:47129675] 第二只熊猫宝宝向你奔来...</span><br><span class="line">2018-01-09 09:05:21.660470+0800 HotPatch[2324:47129676] 第一只熊猫宝宝抱住你大腿...</span><br><span class="line">2018-01-09 09:05:21.660708+0800 HotPatch[2324:47129675] 第二只熊猫宝宝抱住你大腿...</span><br><span class="line">2018-01-09 09:05:21.660749+0800 HotPatch[2324:47129513] 熊猫妈妈在找熊猫宝宝...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但是一般的建议，除非万不得已，最好不要在主线程调用dispatch_semaphore_wait，毕竟阻塞主线程的事能不做还是不要做的。可以放到异步线程里进行等待：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"你等在原地等待被抱大腿..."</span>);</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"你的大腿已经被熊猫宝宝抱住..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;既然扯上锁了，所以也必须注意死锁的问题，如果dispatch_semaphore_wait调用在前，并且跟dispatch_semaphore_signal在一个线程就会造成死锁。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住你大腿..."</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">    dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, attr_t);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        </span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住你大腿..."</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="2-8-dispatch-barrier"><a href="#2-8-dispatch-barrier" class="headerlink" title="2.8 dispatch_barrier"></a>2.8 dispatch_barrier</h4><h4 id="2-8-1-dispatch-barrier-async"><a href="#2-8-1-dispatch-barrier-async" class="headerlink" title="2.8.1 dispatch_barrier_async"></a>2.8.1 dispatch_barrier_async</h4><p>&emsp;&emsp;dispatch_barrier_async会等待前面的任务执行完毕后，阻塞后面的任务，当自己的任务执行完毕后才会继续执行后面的block任务。需要注意的是，使用这个函数的前提是你使用了自己创建的队列，如果使用dispatch_get_global_queue或者自定义的队列是串行队列则等同于dispatch_async。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, attr_t);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">18.239814</span>+<span class="number">0800</span> HotPatch[<span class="number">91915</span>:<span class="number">56702026</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">18.239828</span>+<span class="number">0800</span> HotPatch[<span class="number">91915</span>:<span class="number">56702034</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">23.306770</span>+<span class="number">0800</span> HotPatch[<span class="number">91915</span>:<span class="number">56702026</span>] 第二只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">23.306783</span>+<span class="number">0800</span> HotPatch[<span class="number">91915</span>:<span class="number">56702034</span>] 第一只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">23.307009</span>+<span class="number">0800</span> HotPatch[<span class="number">91915</span>:<span class="number">56702034</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">28.377030</span>+<span class="number">0800</span> HotPatch[<span class="number">91915</span>:<span class="number">56702034</span>] 第三只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">28.377252</span>+<span class="number">0800</span> HotPatch[<span class="number">91915</span>:<span class="number">56702034</span>] 第四只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">33.451332</span>+<span class="number">0800</span> HotPatch[<span class="number">91915</span>:<span class="number">56702034</span>] 第四只熊猫宝宝抱住了你的大腿...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;看下，如果使用的不是自定义队列的效果：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);<span class="comment">//dispatch_queue_create("com.zhaomu.test", attr_t);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈找熊猫宝宝...."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">19.930798</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719799</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">19.930798</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719798</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">19.930798</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719706</span>] 熊猫妈妈找熊猫宝宝....</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">19.930807</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719797</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">19.930819</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719811</span>] 第四只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">24.930909</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719799</span>] 第一只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">24.930910</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719811</span>] 第四只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">24.930910</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719797</span>] 第三只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">14</span>:<span class="number">24.930909</span>+<span class="number">0800</span> HotPatch[<span class="number">92146</span>:<span class="number">56719798</span>] 第二只熊猫宝宝抱住了你的大腿...</span><br></pre></td></tr></table></figure></p>
<h4 id="2-8-2-dispatch-barrier-sync"><a href="#2-8-2-dispatch-barrier-sync" class="headerlink" title="2.8.2 dispatch_barrier_sync"></a>2.8.2 dispatch_barrier_sync</h4><p>&emsp;&emsp;这个函数可以起到阻塞线程的作用，同样的，前提是必须使用自定义的并行队列，串行队列也不可以，不然等同于dispatch_sync。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_attr_t attr_t = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,  QOS_CLASS_UTILITY, QOS_MIN_RELATIVE_PRIORITY);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, attr_t);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈找熊猫宝宝...."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果，可以看到主线程也被阻塞了</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">16</span>:<span class="number">55.716809</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726566</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">16</span>:<span class="number">55.716792</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726568</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">00.784030</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726568</span>] 第二只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">00.784030</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726566</span>] 第一只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">00.784281</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726517</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">05.785264</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726517</span>] 第三只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">05.785450</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726517</span>] 熊猫妈妈找熊猫宝宝....</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">05.785495</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726569</span>] 第四只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">10.850254</span>+<span class="number">0800</span> HotPatch[<span class="number">92335</span>:<span class="number">56726569</span>] 第四只熊猫宝宝抱住了你的大腿...</span><br></pre></td></tr></table></figure></p>
<h4 id="2-9-dispatch-source"><a href="#2-9-dispatch-source" class="headerlink" title="2.9 dispatch_source"></a>2.9 dispatch_source</h4><p>&emsp;&emsp;通过dispatch_source_create创建一个对象。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, <span class="keyword">unsigned</span> <span class="keyword">long</span> mask, <span class="built_in">dispatch_queue_t</span> queue);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;第一个参数是一个dispatch_source类型，提供的类型如下：<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_SOURCE_TYPE_DATA_ADD</span><br><span class="line">DISPATCH_SOURCE_TYPE_DATA_OR</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_RECV</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_SEND</span><br><span class="line">DISPATCH_SOURCE_TYPE_PROC</span><br><span class="line">DISPATCH_SOURCE_TYPE_READ</span><br><span class="line">DISPATCH_SOURCE_TYPE_SIGNAL</span><br><span class="line">DISPATCH_SOURCE_TYPE_TIMER</span><br><span class="line">DISPATCH_SOURCE_TYPE_VNODE</span><br><span class="line">DISPATCH_SOURCE_TYPE_WRITE</span><br><span class="line">DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;例子之前讲过一个定时器，在dispatch_source中，可能算是比较常用的一种。其他具体使用场景，暂未接触到，如果有更好的场景，后面再加进来。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.zhaomu.test"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    dispatch_source_set_timer(<span class="keyword">self</span>.source, dispatch_walltime(<span class="literal">NULL</span>, <span class="number">0</span>), <span class="number">5</span>ull * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> testSelector];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_source_set_cancel_handler(<span class="keyword">self</span>.source, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@""</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(<span class="keyword">self</span>.source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"一只熊猫宝宝向您奔来...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="3-NSOperation"><a href="#3-NSOperation" class="headerlink" title="3. NSOperation"></a>3. NSOperation</h3><p>&emsp;&emsp;创建NSOpertioan对象，一般通过NSInvocationOperation和NSBlockOperation来创建。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    queue.name = <span class="string">@"com.zhaomu.test"</span>;</span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op1 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(test1) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加入到队列自动执行任务</span></span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 手动执行任务</span></span><br><span class="line"><span class="comment">//    [op1 start];</span></span><br><span class="line"><span class="comment">//    [op2 start];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test1 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">55.292137</span>+<span class="number">0800</span> HotPatch[<span class="number">93798</span>:<span class="number">56833792</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">55.292138</span>+<span class="number">0800</span> HotPatch[<span class="number">93798</span>:<span class="number">56833794</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">28</span>:<span class="number">00.297201</span>+<span class="number">0800</span> HotPatch[<span class="number">93798</span>:<span class="number">56833792</span>] 第一只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">28</span>:<span class="number">00.297202</span>+<span class="number">0800</span> HotPatch[<span class="number">93798</span>:<span class="number">56833794</span>] 第二只熊猫宝宝抱住了你的大腿...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要特别说一下的是一个NSBlockOperation对象可以不断添加任务，其任务之间是并行执行的。<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[op2 addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第四只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当然也是可以设置任务优先级。可以通过queuePriority和qualityOfService设置任务优先级。而且队列之间也可以qualityOfService设置队列的优先级。<br>&emsp;&emsp;那么相比于GCD，NSOperation有哪些优点呢？</p>
<ul>
<li><p>设置最大并发数: maxConcurrentOperationCount  </p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    queue.name = <span class="string">@"com.zhaomu.test"</span>;</span><br><span class="line">    queue.maxConcurrentOperationCount = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">10.979448</span>+<span class="number">0800</span> HotPatch[<span class="number">93888</span>:<span class="number">56839976</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">10.979449</span>+<span class="number">0800</span> HotPatch[<span class="number">93888</span>:<span class="number">56839975</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">15.981534</span>+<span class="number">0800</span> HotPatch[<span class="number">93888</span>:<span class="number">56839976</span>] 第一只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">15.981534</span>+<span class="number">0800</span> HotPatch[<span class="number">93888</span>:<span class="number">56839975</span>] 第二只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">15.981721</span>+<span class="number">0800</span> HotPatch[<span class="number">93888</span>:<span class="number">56839983</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">20.985040</span>+<span class="number">0800</span> HotPatch[<span class="number">93888</span>:<span class="number">56839983</span>] 第三只熊猫宝宝抱住了你的大腿...</span><br></pre></td></tr></table></figure>
</li>
<li><p>更方便的设置依赖: addDependency    </p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    queue.name = <span class="string">@"com.zhaomu.test"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op2 addDependency:op1];</span><br><span class="line">    [op3 addDependency:op2];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">33.063585</span>+<span class="number">0800</span> HotPatch[<span class="number">93949</span>:<span class="number">56842708</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">38.066227</span>+<span class="number">0800</span> HotPatch[<span class="number">93949</span>:<span class="number">56842708</span>] 第一只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">38.066432</span>+<span class="number">0800</span> HotPatch[<span class="number">93949</span>:<span class="number">56842705</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">43.066665</span>+<span class="number">0800</span> HotPatch[<span class="number">93949</span>:<span class="number">56842705</span>] 第二只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">43.066902</span>+<span class="number">0800</span> HotPatch[<span class="number">93949</span>:<span class="number">56842705</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">33</span>:<span class="number">48.071874</span>+<span class="number">0800</span> HotPatch[<span class="number">93949</span>:<span class="number">56842705</span>] 第三只熊猫宝宝抱住了你的大腿...</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接取消队列内的所有任务: cancelAllOperations  </p>
</li>
<li>阻塞线程等待队列任务全部完成：waitUntilAllOperationsAreFinished </li>
<li>更直观的看到当前队列有多少任务: operationCount <figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    queue.name = <span class="string">@"com.zhaomu.test"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第一只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝向你奔来..."</span>);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第三只熊猫宝宝抱住了你的大腿..."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">    </span><br><span class="line">    [queue waitUntilAllOperationsAreFinished];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"熊猫妈妈正在找熊猫宝宝..."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">02.731265</span>+<span class="number">0800</span> HotPatch[<span class="number">94363</span>:<span class="number">56860859</span>] 第三只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">02.731265</span>+<span class="number">0800</span> HotPatch[<span class="number">94363</span>:<span class="number">56860858</span>] 第二只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">02.731265</span>+<span class="number">0800</span> HotPatch[<span class="number">94363</span>:<span class="number">56860865</span>] 第一只熊猫宝宝向你奔来...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">07.735805</span>+<span class="number">0800</span> HotPatch[<span class="number">94363</span>:<span class="number">56860859</span>] 第三只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">07.735805</span>+<span class="number">0800</span> HotPatch[<span class="number">94363</span>:<span class="number">56860865</span>] 第一只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">07.735813</span>+<span class="number">0800</span> HotPatch[<span class="number">94363</span>:<span class="number">56860858</span>] 第二只熊猫宝宝抱住了你的大腿...</span><br><span class="line"><span class="number">2018</span><span class="number">-01</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">46</span>:<span class="number">07.736033</span>+<span class="number">0800</span> HotPatch[<span class="number">94363</span>:<span class="number">56860808</span>] 熊猫妈妈正在找熊猫宝宝...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;如何使用多线程，至此结束，下一篇将要看一看GCD的源码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">朝暮</p>
              <p class="site-description motion-element" itemprop="description">联系方式：leylfl@foxmail.com</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朝暮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
