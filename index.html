<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="联系方式：leylfl@foxmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="朝暮的闲暇时刻">
<meta property="og:url" content="https://leylfl.github.io/index.html">
<meta property="og:site_name" content="朝暮的闲暇时刻">
<meta property="og:description" content="联系方式：leylfl@foxmail.com">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="朝暮的闲暇时刻">
<meta name="twitter:description" content="联系方式：leylfl@foxmail.com">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://leylfl.github.io/"/>





  <title>朝暮的闲暇时刻</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">朝暮的闲暇时刻</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/06/07/玩玩Clang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/玩玩Clang/" itemprop="url">玩玩Clang</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T14:23:12+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-配置"><a href="#0x01-配置" class="headerlink" title="0x01 配置"></a>0x01 配置</h1><p>&emsp;&emsp;Clang是LLVM的编译前端，我们的OC、Swift通过Clang经过预处理、词语分析、语法分析，最后生成IR中间码后，交由LLVM进行优化，最后针对不同的平台将IR转换成对应平台的汇编代码。</p>
<p>&emsp;&emsp;本篇需要对Clang进行一些定制化，所以我们需要重新编译llvm，步骤如下：</p>
<ul>
<li><p>下载源码</p>
<blockquote>
<ul>
<li><p>cd 需要下载源码的目录</p>
<p>git clone <a href="http://llvm.org/git/llvm.git" target="_blank" rel="noopener">http://llvm.org/git/llvm.git</a> </p>
</li>
<li><p>cd llvm/tools </p>
<p>git clone <a href="http://llvm.org/git/clang.git" target="_blank" rel="noopener">http://llvm.org/git/clang.git</a> </p>
</li>
<li><p>cd ../projects </p>
<p>git clone <a href="http://llvm.org/git/compiler-rt.git" target="_blank" rel="noopener">http://llvm.org/git/compiler-rt.git</a> </p>
</li>
<li><p>cd ../tools/clang/tools </p>
<p>git clone <a href="http://llvm.org/git/clang-tools-extra.git" target="_blank" rel="noopener">http://llvm.org/git/clang-tools-extra.git</a></p>
</li>
</ul>
</blockquote>
</li>
<li><p>编译</p>
<blockquote>
<ul>
<li><p>安装cmake</p>
<p>brew install cmake</p>
</li>
<li><p>编译</p>
<ul>
<li>mkdir 新建的目录名      (因为不支持源代码目录内编译)</li>
<li>cd 新建的目录名</li>
<li>cmake  llvm源代码目录</li>
<li>cmake –build .</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;参考链接：<a href="http://llvm.org/docs/CMake.html，编译完所有的工具都在编译目录下的bin目录下。" target="_blank" rel="noopener">http://llvm.org/docs/CMake.html，编译完所有的工具都在编译目录下的bin目录下。</a></p>
<h1 id="0x02-试玩"><a href="#0x02-试玩" class="headerlink" title="0x02 试玩"></a>0x02 试玩</h1><p>&emsp;&emsp;我们有代码如下</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define NUM_1  100</span></span><br><span class="line"><span class="meta">#define NUM_2  200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = NUM_1 + NUM_2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>&emsp;&emsp;经过预处理后的代码会是什么样的？使用Clang命令如下</p>
<blockquote>
<p>clang -E main.m</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 1 <span class="meta-string">"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h"</span> 1 3</span></span><br><span class="line"><span class="meta"># 185 <span class="meta-string">"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h"</span> 2 3</span></span><br><span class="line"><span class="meta"># 10 <span class="meta-string">"./Animal.h"</span> 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span> + <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;预处理的过程中，导入了头文件，并把宏替换了。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>&emsp;&emsp;词法分析的命令</p>
<blockquote>
<p>clang -fsyntax-only -Xclang -dump-tokens main.m </p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int 'int'	 [StartOfLine]	Loc=&lt;main.m:17:1&gt;</span><br><span class="line">identifier 'main'	 [LeadingSpace]	Loc=&lt;main.m:17:5&gt;</span><br><span class="line">l_paren <span class="string">'('</span>		Loc=&lt;main.m:<span class="number">17</span>:<span class="number">9</span>&gt;</span><br><span class="line">int 'int'		Loc=&lt;main.m:17:10&gt;</span><br><span class="line">identifier 'argc'	 [LeadingSpace]	Loc=&lt;main.m:17:14&gt;</span><br><span class="line">comma <span class="string">','</span>		Loc=&lt;main.m:<span class="number">17</span>:<span class="number">18</span>&gt;</span><br><span class="line">char 'char'	 [LeadingSpace]	Loc=&lt;main.m:17:20&gt;</span><br><span class="line">star <span class="string">'*'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">17</span>:<span class="number">25</span>&gt;</span><br><span class="line">identifier 'argv'	 [LeadingSpace]	Loc=&lt;main.m:17:27&gt;</span><br><span class="line">l_square <span class="string">'['</span>		Loc=&lt;main.m:<span class="number">17</span>:<span class="number">31</span>&gt;</span><br><span class="line">r_square <span class="string">']'</span>		Loc=&lt;main.m:<span class="number">17</span>:<span class="number">32</span>&gt;</span><br><span class="line">r_paren <span class="string">')'</span>		Loc=&lt;main.m:<span class="number">17</span>:<span class="number">33</span>&gt;</span><br><span class="line">l_brace <span class="string">'&#123;'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">17</span>:<span class="number">35</span>&gt;</span><br><span class="line">int 'int'	 [StartOfLine] [LeadingSpace]	Loc=&lt;main.m:18:5&gt;</span><br><span class="line">identifier <span class="string">'a'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">18</span>:<span class="number">9</span>&gt;</span><br><span class="line">equal <span class="string">'='</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">18</span>:<span class="number">11</span>&gt;</span><br><span class="line">numeric_constant '100'	 [LeadingSpace]	Loc=&lt;main.m:18:13 &lt;Spelling=main.m:13:16&gt;&gt;</span><br><span class="line">plus <span class="string">'+'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">18</span>:<span class="number">19</span>&gt;</span><br><span class="line">numeric_constant '200'	 [LeadingSpace]	Loc=&lt;main.m:18:21 &lt;Spelling=main.m:14:16&gt;&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;main.m:<span class="number">18</span>:<span class="number">26</span>&gt;</span><br><span class="line">int 'int'	 [StartOfLine] [LeadingSpace]	Loc=&lt;main.m:19:5&gt;</span><br><span class="line">identifier <span class="string">'b'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">19</span>:<span class="number">9</span>&gt;</span><br><span class="line">equal <span class="string">'='</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">19</span>:<span class="number">11</span>&gt;</span><br><span class="line">numeric_constant <span class="string">'1'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">19</span>:<span class="number">13</span>&gt;</span><br><span class="line">plus <span class="string">'+'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">19</span>:<span class="number">15</span>&gt;</span><br><span class="line">numeric_constant <span class="string">'2'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">19</span>:<span class="number">17</span>&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;main.m:<span class="number">19</span>:<span class="number">18</span>&gt;</span><br><span class="line">return 'return'	 [StartOfLine] [LeadingSpace]	Loc=&lt;main.m:21:5&gt;</span><br><span class="line">numeric_constant <span class="string">'0'</span>	 [LeadingSpace]	Loc=&lt;main.m:<span class="number">21</span>:<span class="number">12</span>&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;main.m:<span class="number">21</span>:<span class="number">13</span>&gt;</span><br><span class="line">r_brace <span class="string">'&#125;'</span>	 [StartOfLine]	Loc=&lt;main.m:<span class="number">25</span>:<span class="number">1</span>&gt;</span><br><span class="line">eof ''		Loc=&lt;main.m:25:2&gt;</span><br></pre></td></tr></table></figure>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>&emsp;&emsp;语法分析命令如下</p>
<blockquote>
<p>clang  -fsyntax-only -Xclang -ast-dump main.m</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-FunctionDecl 0x7ff34f2eeae8 &lt;main.m:17:1, line:25:1&gt; line:17:5 main 'int (int, char **)'</span><br><span class="line">  |-ParmVarDecl 0x7ff34f2ee918 &lt;col:10, col:14&gt; col:14 argc 'int'</span><br><span class="line">  |-ParmVarDecl 0x7ff34f2ee9d0 &lt;col:20, col:32&gt; col:27 argv 'char **':'char **'</span><br><span class="line">  `-CompoundStmt <span class="number">0x7ff34f2eedb8</span> &lt;col:<span class="number">35</span>, line:<span class="number">25</span>:<span class="number">1</span>&gt;</span><br><span class="line">    |-DeclStmt <span class="number">0x7ff34f2eec70</span> &lt;line:<span class="number">18</span>:<span class="number">5</span>, col:<span class="number">26</span>&gt;</span><br><span class="line">    | `-VarDecl 0x7ff34f2eeba8 &lt;col:5, line:14:16&gt; line:18:9 a 'int' cinit</span><br><span class="line">    |   `-BinaryOperator 0x7ff34f2eec48 &lt;line:13:16, line:14:16&gt; 'int' '+'</span><br><span class="line">    |     |-IntegerLiteral 0x7ff34f2eec08 &lt;line:13:16&gt; 'int' 100</span><br><span class="line">    |     `-IntegerLiteral 0x7ff34f2eec28 &lt;line:14:16&gt; 'int' 200</span><br><span class="line">    |-DeclStmt <span class="number">0x7ff34f2eed68</span> &lt;line:<span class="number">19</span>:<span class="number">5</span>, col:<span class="number">18</span>&gt;</span><br><span class="line">    | `-VarDecl 0x7ff34f2eeca0 &lt;col:5, col:17&gt; col:9 b 'int' cinit</span><br><span class="line">    |   `-BinaryOperator 0x7ff34f2eed40 &lt;col:13, col:17&gt; 'int' '+'</span><br><span class="line">    |     |-IntegerLiteral 0x7ff34f2eed00 &lt;col:13&gt; 'int' 1</span><br><span class="line">    |     `-IntegerLiteral 0x7ff34f2eed20 &lt;col:17&gt; 'int' 2</span><br><span class="line">    `-ReturnStmt <span class="number">0x7ff34f2eeda0</span> &lt;line:<span class="number">21</span>:<span class="number">5</span>, col:<span class="number">12</span>&gt;</span><br><span class="line">      `-IntegerLiteral 0x7ff34f2eed80 &lt;col:12&gt; 'int' 0</span><br></pre></td></tr></table></figure>
<h3 id="生成IR"><a href="#生成IR" class="headerlink" title="生成IR"></a>生成IR</h3><p>&emsp;&emsp;IR是作为Clang的输出，llvm的输入，命令如下</p>
<blockquote>
<p>clang -S -fobjc-arc -emit-llvm main.m -o main.ll</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = 'main.m'</span><br><span class="line">source_filename = <span class="string">"main.m"</span></span><br><span class="line">target datalayout = <span class="string">"e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span></span><br><span class="line">target triple = <span class="string">"x86_64-apple-macosx10.13.0"</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone ssp uwtable</span><br><span class="line">define i32 @main(i32, i8**) #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = alloca i8**, align <span class="number">8</span></span><br><span class="line">  %<span class="number">6</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">7</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">0</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  store i8** %<span class="number">1</span>, i8*** %<span class="number">5</span>, align <span class="number">8</span></span><br><span class="line">  store i32 <span class="number">300</span>, i32* %<span class="number">6</span>, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">3</span>, i32* %<span class="number">7</span>, align <span class="number">4</span></span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind optnone ssp uwtable <span class="string">"correctly-rounded-divide-sqrt-fp-math"</span>=<span class="string">"false"</span> <span class="string">"disable-tail-calls"</span>=<span class="string">"false"</span> <span class="string">"less-precise-fpmad"</span>=<span class="string">"false"</span> <span class="string">"no-frame-pointer-elim"</span>=<span class="string">"true"</span> <span class="string">"no-frame-pointer-elim-non-leaf"</span> <span class="string">"no-infs-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-jump-tables"</span>=<span class="string">"false"</span> <span class="string">"no-nans-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-signed-zeros-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-trapping-math"</span>=<span class="string">"false"</span> <span class="string">"stack-protector-buffer-size"</span>=<span class="string">"8"</span> <span class="string">"target-cpu"</span>=<span class="string">"penryn"</span> <span class="string">"target-features"</span>=<span class="string">"+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87"</span> <span class="string">"unsafe-fp-math"</span>=<span class="string">"false"</span> <span class="string">"use-soft-float"</span>=<span class="string">"false"</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.<span class="keyword">module</span>.flags = !&#123;!<span class="number">0</span>, !<span class="number">1</span>, !<span class="number">2</span>, !<span class="number">3</span>, !<span class="number">4</span>, !<span class="number">5</span>, !<span class="number">6</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Version"</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Image Info Version"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">2</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Image Info Section"</span>, !<span class="string">"__DATA,__objc_imageinfo,regular,no_dead_strip"</span>&#125;</span><br><span class="line">!<span class="number">3</span> = !&#123;i32 <span class="number">4</span>, !<span class="string">"Objective-C Garbage Collection"</span>, i32 <span class="number">0</span>&#125;</span><br><span class="line">!<span class="number">4</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"Objective-C Class Properties"</span>, i32 <span class="number">64</span>&#125;</span><br><span class="line">!<span class="number">5</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"wchar_size"</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">6</span> = !&#123;i32 <span class="number">7</span>, !<span class="string">"PIC Level"</span>, i32 <span class="number">2</span>&#125;</span><br><span class="line">!<span class="number">7</span> = !&#123;!<span class="string">"Apple LLVM version 9.1.0 (clang-902.0.39.2)"</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>生成字节码</p>
<blockquote>
<p>clang -emit-llvm -c main.m -o main.bc</p>
</blockquote>
</li>
<li><p>生成汇编</p>
<blockquote>
<p>clang -S -fobjc-arc main.m -o main.s</p>
</blockquote>
</li>
<li><p>生成目标文件</p>
<blockquote>
<p>clang -fmodules -c main.m -o main.o</p>
</blockquote>
</li>
<li><p>生成可执行文件</p>
<blockquote>
<p>clang main.o -o main</p>
</blockquote>
</li>
</ul>
<h1 id="0x03-第一个插件"><a href="#0x03-第一个插件" class="headerlink" title="0x03 第一个插件"></a>0x03 第一个插件</h1><h3 id="初始化一个插件项目"><a href="#初始化一个插件项目" class="headerlink" title="初始化一个插件项目"></a>初始化一个插件项目</h3><p>&emsp;&emsp;打开源码路径llvm/tools/clang/example，example目录下新建目录，此例中为DemoPlugin。</p>
<p>&emsp;&emsp;接着，修改example目录的CMakeLists.txt文件，添加如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(DemoPlugin)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;来到testPlugin目录，新建如下三个文件</p>
<ul>
<li>CMakeLists.txt</li>
<li>DemoPlugin.exports</li>
<li>DemoPlugin.cpp</li>
</ul>
<p>&emsp;&emsp;其中CMakeLists.txt内容如下，可以参考example目录下其他例子的CMakeLists.txt内容。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If we don't need RTTI or EH, there's no reason to export anything</span></span><br><span class="line"><span class="comment"># from the plugin.</span></span><br><span class="line">if( NOT MSVC ) </span><br><span class="line">  if( NOT LLVM_REQUIRES_RTTI )</span><br><span class="line">    if( NOT LLVM_REQUIRES_EH )</span><br><span class="line">      set(LLVM_EXPORTED_SYMBOL_FILE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/DemoPlugin.exports)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">add_llvm_loadable_module(DemoPlugin DemoPlugin.cpp PLUGIN_TOOL clang)</span><br><span class="line"></span><br><span class="line">if(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))</span><br><span class="line">  target_link_libraries(DemoPlugin PRIVATE</span><br><span class="line">    clangAST</span><br><span class="line">    clangBasic</span><br><span class="line">    clangFrontend</span><br><span class="line">    LLVMSupport</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后开始最重要的testPlugin.cpp代码编写，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Frontend/FrontendPluginRegistry.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/AST.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/ASTConsumer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Frontend/CompilerInstance.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DemoPluginConsumer</span> :</span> <span class="keyword">public</span> ASTConsumer</span><br><span class="line">    &#123;</span><br><span class="line">    CompilerInstance &amp;Instance;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ParsedTemplates;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DemoPluginConsumer(CompilerInstance &amp;Instance,</span><br><span class="line">                               <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ParsedTemplates)</span><br><span class="line">        : Instance(Instance), ParsedTemplates(ParsedTemplates) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DemoPluginASTAction</span> :</span> <span class="keyword">public</span> PluginASTAction</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ParsedTemplates;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI,</span><br><span class="line">                                                       llvm::StringRef) override</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> llvm::make_unique&lt;DemoPluginConsumer&gt;(CI, ParsedTemplates);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 插件的入口函数</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ParseArgs</span><span class="params">(<span class="keyword">const</span> CompilerInstance &amp;CI,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;args)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">            DiagnosticsEngine &amp;D = CI.getDiagnostics();</span><br><span class="line">            <span class="comment">// Report的作用是向编译器报错</span></span><br><span class="line">            D.Report(D.getCustomDiagID(DiagnosticsEngine::Error,</span><br><span class="line">                                       <span class="string">"Hello Plugin"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> clang::FrontendPluginRegistry::Add&lt;DemoPluginASTAction&gt;</span><br><span class="line">X(<span class="string">"DemoPlugin"</span>, <span class="string">"demo plugin"</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;编译，在我们的之前编译源码时新建的目录</p>
<ul>
<li><p>cmake</p>
<blockquote>
<ul>
<li>cmake  llvm源代码目录</li>
<li>cmake –build .</li>
<li>make DemoPlugin </li>
<li>插件出现在lib目录下，DemoPlugin.dylib</li>
</ul>
</blockquote>
</li>
<li><p>Xcode</p>
<blockquote>
<ul>
<li>cmake -G Xcode .llvm源代码目录 -DCMAKE_BUILD_TYPE:STRING=MinSizeRel</li>
<li>打开LLVM.xcodeproj</li>
<li>选择Automatically Create Schemes</li>
<li>编译clang、DemoPlugin</li>
<li>插件出现在Debug/lib目录下，DemoPlugin.dylib</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="配置Xcode"><a href="#配置Xcode" class="headerlink" title="配置Xcode"></a>配置Xcode</h3><p>&emsp;&emsp;Xcode的Build Setting里的Other C Flags添加如下，也就是DemoPlugin.dylib所在目录</p>
<blockquote>
<p>-Xclang -load -Xclang /Users/ex-lifenglei/Desktop/llvm/myBuild/lib/DemoPlugin.dylib -Xclang -add-plugin -Xclang DemoPlugin</p>
</blockquote>
<p> <img src="buid_setting.png" alt="Build_Setting">  </p>
<p>&emsp;&emsp;这时，我们build下我们的项目大多数会遇到下面的报错</p>
<p><img src="build_error.png" alt="Build_Error">  </p>
<p>&emsp;&emsp;这是因为Xcode的Clang版本跟我们自己编译的Clang版本不一致。Clang插件需要对应的Clang版本来加载。所以我们还得修改Xcode指定的Clang。在Xcode的Build Setting里新增两个自定义项。</p>
<blockquote>
<p>CC = /Users/ex-lifenglei/Desktop/llvm/myBuild/bin/clang-7</p>
<p>CXX = /Users/ex-lifenglei/Desktop/llvm/myBuild/bin/clang-7</p>
</blockquote>
<p><img src="build_setting_2.png" alt="Build_Setting">  </p>
<p>&emsp;&emsp;然而在Xcode 9版本上，继续报错了，如下</p>
<p><img src="build_error_2.png" alt="Build_Error">  </p>
<p>&emsp;&emsp;解决办法就是关掉Build Setting里的<code>Index-While-Building</code></p>
<p><img src="build_error_3.png" alt="Build_Setting">  </p>
<p>&emsp;&emsp;紧接着再次编译，我们成功编译失败，那是当然的，我们本来就设置了一个编译错误提示，说明我们的插件成功运行了！！！</p>
<p><img src="build_success.png" alt="Build_Success">  </p>
<p>&emsp;&emsp;但是，因为这里是error，所以编译终止了，如果上面代码改成Warning让代码继续执行下去的话，可能会遇到下面这个错误</p>
<p><img src="build_error_4.png" alt="Build_Error"> </p>
<p>&emsp;&emsp;解决方法就是把Xcode程序下的<code>libarclite_iphonesimulator</code>拷贝到编译目录下的../lib/arc下。如果是真机，也是同样的方法把<code>libarclite_iphoneos.a</code>复制过来。</p>
<blockquote>
<p><code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/arc/libarclite_iphonesimulator.a</code></p>
</blockquote>
<p>&emsp;&emsp;我们再做个试验，我们把所有的类名和方法给打出来，代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Frontend/FrontendPluginRegistry.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/AST.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/ASTConsumer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/RecursiveASTVisitor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Frontend/CompilerInstance.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以深度优先搜索整个AST，并访问每一个基类，遍历需要处理的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DemoPluginVisitor</span> :</span> <span class="keyword">public</span> RecursiveASTVisitor&lt;DemoPluginVisitor&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        CompilerInstance &amp;Instance;</span><br><span class="line">        ASTContext *Context;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setASTContext</span> <span class="params">(ASTContext &amp;context)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span> -&gt; Context = &amp;context;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        DemoPluginVisitor (CompilerInstance &amp;Instance)</span><br><span class="line">        :Instance(Instance) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找类名</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">VisitObjCInterfaceDecl</span><span class="params">(ObjCInterfaceDecl *declaration)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isUserSourceCode(declaration)) &#123;</span><br><span class="line">                DiagnosticsEngine &amp;D = Instance.getDiagnostics();</span><br><span class="line">                <span class="keyword">unsigned</span> diagID = D.getCustomDiagID(DiagnosticsEngine::Warning, <span class="string">"查找到一个类名: %0"</span>);</span><br><span class="line">                D.Report(declaration-&gt;getLocStart(), diagID) &lt;&lt; declaration-&gt;getName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找方法名</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">VisitObjCMethodDecl</span><span class="params">(ObjCMethodDecl *declaration)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isUserSourceCode(declaration)) &#123;</span><br><span class="line">                DiagnosticsEngine &amp;D = Instance.getDiagnostics();</span><br><span class="line">                <span class="keyword">unsigned</span> diagID = D.getCustomDiagID(DiagnosticsEngine::Warning, <span class="string">"查找到一个方法名: %0"</span>);</span><br><span class="line"><span class="comment">//                D.Report(declaration-&gt;getLocStart(), diagID).AddString(declaration-&gt;getSelector().getAsString());</span></span><br><span class="line">                 D.Report(declaration-&gt;getLocStart(), diagID) &lt;&lt; declaration-&gt;getSelector().getAsString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是否用户代码</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isUserSourceCode</span> <span class="params">(Decl *decl)</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> filename = Instance.getSourceManager().getFilename(decl-&gt;getSourceRange().getBegin()).str();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (filename.empty())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 定义非Xcode中的源码都是用户源码</span></span><br><span class="line">            <span class="keyword">if</span>(filename.find(<span class="string">"/Applications/Xcode.app/"</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DemoPluginConsumer</span> :</span> <span class="keyword">public</span> ASTConsumer</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DemoPluginVisitor visitor;</span><br><span class="line">        CompilerInstance &amp;Instance;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ParsedTemplates;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DemoPluginConsumer(CompilerInstance &amp;Instance,</span><br><span class="line">                           <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ParsedTemplates)</span><br><span class="line">        : Instance(Instance), ParsedTemplates(ParsedTemplates), visitor(Instance) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每次分析到一个顶层定义时会回调此函数，返回true表示处理</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">HandleTopLevelDecl</span><span class="params">(DeclGroupRef DG)</span> override</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ASTConsumer的入口函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(ASTContext&amp; context)</span> override</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            visitor.setASTContext(context);</span><br><span class="line">            visitor.TraverseDecl(context.getTranslationUnitDecl());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DemoPluginASTAction</span> :</span> <span class="keyword">public</span> PluginASTAction</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ParsedTemplates;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI,</span><br><span class="line">                                                       llvm::StringRef) override</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> llvm::make_unique&lt;DemoPluginConsumer&gt;(CI, ParsedTemplates);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插件的入口函数</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ParseArgs</span><span class="params">(<span class="keyword">const</span> CompilerInstance &amp;CI,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;args)</span> override </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> clang::FrontendPluginRegistry::Add&lt;DemoPluginASTAction&gt;</span><br><span class="line">X(<span class="string">"DemoPlugin"</span>, <span class="string">"demo plugin"</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果如下，我们所有的类名和方法名都被打出来了。</p>
<p><img src="build_demo_1.png" alt="Build_Demo"> </p>
<p>&emsp;&emsp;更多文档查看：<a href="https://clang.llvm.org/doxygen/namespaceclang.html" target="_blank" rel="noopener">https://clang.llvm.org/doxygen/namespaceclang.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/30/iOS逆向的基本操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/iOS逆向的基本操作/" itemprop="url">iOS逆向的基本操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:27:17+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/逆向/" itemprop="url" rel="index">
                    <span itemprop="name">逆向</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-使用OpenSSH登录iPhone"><a href="#0x01-使用OpenSSH登录iPhone" class="headerlink" title="0x01 使用OpenSSH登录iPhone"></a>0x01 使用OpenSSH登录iPhone</h1><p>&emsp;&emsp; 首先在Cydia安装OpenSSH插件</p>
<p><img src="cydia_openssh.png" alt="OpenSSH插件示意图">  </p>
<blockquote>
<p>SSL：Secure Sockets Layer，是为了网络通信提供安全及数据完整性的一种安全协议，在传输层对网络连接进行加密。</p>
<p>OpenSSL：是SSL的开源实现，绝大部分的https其实就是http+openssl</p>
<p>OpenSSH：远程登录，并且可以保证登录的安全性，安全性指的就是其加密是由OpenSSL完成的。</p>
</blockquote>
<p>&emsp;&emsp; 接着，需要保证手机和Mac是在同一个wifi环境下。在Mac上的终端里输入</p>
<blockquote>
<p>ssh 用户名@手机ip地址</p>
</blockquote>
<p>&emsp;&emsp;这时候会让你保存散列值，这个散列值是用散列算法把公钥信息算出来的。</p>
<p><img src="login_1.png" alt="login示意图"> </p>
<p>&emsp;&emsp;输入yes后，会问你手机root账户的登录密码，密码默认是alpine。(通过passwd和passwd mobile修改两个账号的密码)</p>
<p><img src="login_2.png" alt="login示意图"> </p>
<p>&emsp;&emsp;密码输入后，就已经成功登录到你的手机上了，如果想要退出登录，终端输入exit即可。</p>
<h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>&emsp;&emsp;连接有三个步骤</p>
<ul>
<li><p>建立安全连接</p>
<blockquote>
<p>第一次登录时，iPhone会将其自己的公钥等信息发给Mac端，会问我们是否保存，即我们第一次连接手机时出现的提示。</p>
<blockquote>
<p>/etc/ssh/ssh_host_rsa_key.pub -&gt; ~/.ssh/known_hosts</p>
</blockquote>
</blockquote>
</li>
<li><p>客户端认证</p>
<blockquote>
<p>基于密码的认证</p>
<p>基于密钥的认证</p>
<blockquote>
<p>Mac端生成公钥和私钥(终端输入：ssh-keygen)，将公钥的内容追加到iPhone端(~/.ssh/authorized_keys，终端打开进.ssh目录：ssh-copy-id root@手机ip地址)</p>
</blockquote>
</blockquote>
</li>
<li><p>数据传输</p>
</li>
</ul>
<hr>
<h1 id="0x02-使用USB登录iPhone"><a href="#0x02-使用USB登录iPhone" class="headerlink" title="0x02 使用USB登录iPhone"></a>0x02 使用USB登录iPhone</h1><p>&emsp;&emsp;WIFI连接操作iPhone的效率低于直接用USB连接，所以我们有时候需要用USB进行登录手机的操作。</p>
<p>&emsp;&emsp;默认情况下SSH走的是TCP协议，所以需要用到WIFI环境，所以我们需要设置将SSH通过USB连接手机，一般我们Mac电脑都有一个usbmuxd服务程序，首先我们需要将Mac电脑自己ssh到自己电脑的端口，比如端口10010，然后通过usbmuxd将这个10010端口映射到iPhone的22端口，这样相当于ssh到了手机的22端口。</p>
<p>&emsp;&emsp;下载usbmuxd工具包：<a href="https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz" target="_blank" rel="noopener">https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz</a> ，需要用到里面的tcprelay.py和usbmux.py脚本</p>
<p><img src="usbmuxd_tool.png" alt="usbmuxd_tool示意图"> </p>
<p>&emsp;&emsp;映射端口，如果要保持端口映射就不能关闭或者结束当前终端命令</p>
<blockquote>
<p>python tcprelay.py -t 22:10010 </p>
</blockquote>
<p><img src="usbmuxd_operation_1.png" alt="usbmuxd操作示意图"> </p>
<p>&emsp;&emsp;新开一个终端窗口，ssh连接到10010端口</p>
<blockquote>
<p>ssh root@localhost -p 10010</p>
</blockquote>
<p>&emsp;&emsp;这种方式建立的连接，也可以进行拷贝文件操作</p>
<blockquote>
<p>pscp -P 10010 Mac上文件路径 root@localhost:iPhone文件夹路径</p>
</blockquote>
<p>&emsp;&emsp;默认情况下，iOS终端不支持中文输入和显示 新建一个~/.inputrc文件，文件内容设置为</p>
<blockquote>
<p> set convert-meta off  ：不将中文字符转化为转义序列 </p>
<p>set output-meta on ：允许向终端输出中文 </p>
<p>set meta-flag on   \  set input-meta on ：允许向终端输入中文 </p>
</blockquote>
<hr>
<h1 id="0x03-Cycript"><a href="#0x03-Cycript" class="headerlink" title="0x03 Cycript"></a>0x03 Cycript</h1><p>&emsp;&emsp;首先在手机Cydia上安装Cycript插件，安装完成后会要求重启Springboard。</p>
<p>&emsp;&emsp;Cycript的常规操作，连接到手机后进行操作</p>
<ul>
<li><p>cycript开启</p>
<ul>
<li>cycript</li>
</ul>
<p><img src="cy_enter.png" alt="进入cy示意图"> </p>
<ul>
<li>cycript -p 进程id</li>
<li>cycript -p 进程名称</li>
</ul>
</li>
<li><p>退出cycript：ctrl + d</p>
</li>
<li><p>取消输入：ctrl + c</p>
</li>
<li><p>查询进程：ps</p>
<ul>
<li>ps -A：查询所有进程</li>
<li>ps -A | grep 关键字，过滤进程</li>
</ul>
</li>
</ul>
<h3 id="1-简单实战"><a href="#1-简单实战" class="headerlink" title="1. 简单实战"></a>1. 简单实战</h3><p>&emsp;&emsp;我们有如下页面，需要把红色的view隐藏掉</p>
<p><img src="hidden_redView.png" alt="隐藏红色框示意图"> </p>
<p>&emsp;&emsp;首先找到我们的app，此例中我们的进程是594</p>
<blockquote>
<p>ps -A</p>
</blockquote>
<p><img src="sample1_ps.png" alt="寻找进程示意图"> </p>
<p>&emsp;&emsp;连上我们的app，然后打印下UIApplication对象</p>
<blockquote>
<p>cycript -p 594</p>
</blockquote>
<p><img src="sample1_cy_app.png" alt="打印UIApplication示意图"></p>
<p>&emsp;&emsp;如果想要打印所有成员变量</p>
<blockquote>
<p><code>*</code> 变量(或#地址)</p>
</blockquote>
<p><img src="sample1_cy_ivars.png" alt="打印成员变量示意图"></p>
<p>&emsp;&emsp;如果要递归打印所有子view</p>
<blockquote>
<p>① view对象(或#地址).recursiveDescription().toString() </p>
<p>② choose(UILabel)：可以筛选出所有子view是UILabel的</p>
<p>③ 层级打印：[view _printHierarchy].toString()</p>
</blockquote>
<p><img src="sample1_cy_views.png" alt="打印子View示意图"></p>
<p>&emsp;&emsp;至此，已经拿到我们要隐藏的Label的内存地址0x13ee12230，只需要设置hidden为YES即可</p>
<blockquote>
<p>[#0x13ee12230 setHidden:YES]</p>
</blockquote>
<p>&emsp;&emsp;更多使用，可以查看官方手册：<a href="http://www.cycript.org/manual/" target="_blank" rel="noopener">http://www.cycript.org/manual/</a></p>
<h3 id="2-封装Cycript常用方法"><a href="#2-封装Cycript常用方法" class="headerlink" title="2. 封装Cycript常用方法"></a>2. 封装Cycript常用方法</h3><p>&emsp;&emsp;比如想封装一个返回keyWindow的方法以及一个打印对应view所有子控件的方法，我们定义代码如下，函数前面加上exports表示调用的时候需要加上工具的名字，比如tool.keyWindow；如果不加exports，表示直接使用函数名调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">exports</span>)</span>&#123;</span><br><span class="line">	exports.keyWindow = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> UIApp.keyWindow;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(exports);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;保存的文件格式以cy结尾，并在文件保存到手机的/usr/lib/cycript0.9/com文件夹下，比如在此文件夹下新建一个文件夹myCycript，那么刚刚新建的cy文件保存到/usr/lib/cycript0.9/com/myCycript下</p>
<p><img src="sample1_cy_tool_path.png" alt="tool.cy保存示意图"></p>
<p>&emsp;&emsp;导入的时候@import com.myCycript.tool，并且进行使用</p>
<p><img src="sample1_cy_tool.png" alt="导入tool示意图"></p>
<hr>
<h1 id="0x04-Reveal的使用"><a href="#0x04-Reveal的使用" class="headerlink" title="0x04 Reveal的使用"></a>0x04 Reveal的使用</h1><p>&emsp;&emsp;首先手机的Cydia里面搜索安装Reveal Loader</p>
<p><img src="reveal_install.png" alt="手机安装reveal保存示意图"></p>
<p>&emsp;&emsp;然后设置 —&gt; Reveal  —&gt; Enabled Applications —&gt; 勾选要调试的app</p>
<p><img src="reveal_app.png" alt="勾选app示意图"></p>
<p>&emsp;&emsp;mac打开Reveal，菜单栏help —&gt; Show Reveal Library in Finder —&gt; iOS Library</p>
<p><img src="reveal_install_libary.png" alt="Reveal找到iOS库示意图"></p>
<p>&emsp;&emsp;打开库，找到里面的RevealServer</p>
<p><img src="reveal_install_server.png" alt="Reveal库示意图"></p>
<p>&emsp;&emsp;在iPhone的/Library下找到RHRevealLoader目录，如果没有就新建一个，并将之前的RevealServer文件复制到这个目录，并改名为libReveal.dylib</p>
<blockquote>
<p>scp /路径/RevealServer root@iPhone地址:/Library/RHRevealLoader/libReveal.dylib</p>
</blockquote>
<p><img src="reveal_catch.png" alt="Reveal获取app示意图"></p>
<hr>
<h1 id="0x05-脱壳"><a href="#0x05-脱壳" class="headerlink" title="0x05 脱壳"></a>0x05 脱壳</h1><p>&emsp;&emsp;脱壳分为硬脱壳和动态脱壳，硬脱壳是根据解密算法进行脱壳，也是官方的方式；动态脱壳是在内存中将程序导出。可以查看Mach-O格式来验证是否加壳</p>
<blockquote>
<p>① Mach-O View：Load Commands —&gt; LC_ENCRYPTION_INFO —&gt; Crypt ID的值为0是未加密</p>
<p>② otool工具：otool -l 文件路径 | grep crypt</p>
</blockquote>
<h4 id="1-Clutch"><a href="#1-Clutch" class="headerlink" title="1. Clutch"></a>1. Clutch</h4><p>&emsp;&emsp;首先下载 <a href="https://github.com/KJCracks/Clutch/releases" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch/releases</a> ，将Clutch文件拷贝到手机的/usr/bin目录，使用方法如下</p>
<blockquote>
<p>① clutch -i : 列出已安装的app</p>
<p>② clutch -d app序号或bundle id：脱壳</p>
<p>③ /private/var/mobile/Documents/Dumped下就是脱壳好的文件</p>
</blockquote>
<h4 id="2-Dumpdecrypted"><a href="#2-Dumpdecrypted" class="headerlink" title="2. Dumpdecrypted"></a>2. Dumpdecrypted</h4><p>&emsp;&emsp;首先下载<a href="https://github.com/stefanesser/dumpdecrypted。" target="_blank" rel="noopener">https://github.com/stefanesser/dumpdecrypted。</a></p>
<p>&emsp;&emsp;在源代码目录下make进行编译，得到dumpdecrypted.dylib动态库文件。将这个文件拷贝到手机的/var/root目录下，使用方法如下</p>
<blockquote>
<p>① 终端进入/var/root目录下</p>
<p>② 将这个动态库注入可执行文件中：DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib 文件路径/文件.app/dump出文件的名字</p>
<p>③ 生成的.dycrypted就是脱壳后的文件</p>
</blockquote>
<hr>
<h1 id="0x06-动态调试"><a href="#0x06-动态调试" class="headerlink" title="0x06 动态调试"></a>0x06 动态调试</h1><p>&emsp;&emsp;动态调试需要用到debugserver，一开始是放在Xcode里面，当识别到手机设备时，Xcode会将debugserver放到手机的/Developer/usr/bin/目录下。</p>
<p>&emsp;&emsp;但是一般情况下debugserver缺少权限，无法调试其他的app，需要重签名加上2个调试相关的权限。</p>
<blockquote>
<ul>
<li>get-task-allow</li>
<li>task_for_pid-allow</li>
</ul>
</blockquote>
<p>&emsp;&emsp;先将/Developer/usr/bin/目录下的debugserver导出到mac，接着导出原来的签名权限</p>
<blockquote>
<p>ldid -e debugserver &gt; debugserver.entitlements </p>
</blockquote>
<p>&emsp;&emsp;给debugserver.entitlements 加上get-task-allow和task-for-pid_allow权限。接着重新签名</p>
<blockquote>
<p>ldid -S debugserver.entitlements debugserver </p>
<p>如果没有安装ldid：brew install ldid  </p>
</blockquote>
<p><img src="debug_append.png" alt="加上权限示意图"></p>
<p>&emsp;&emsp;也可以用codesign重签</p>
<blockquote>
<p>① 查看权限信息：codesign -d —entitilements - debugserver</p>
<p>② 签名权限：codesign -f -s - –entitlements debugserver.entitlements debugserver </p>
</blockquote>
<p>&emsp;&emsp;最后放到/usr/bin/目录，注意不是之前的那个/Developer/usr/bin。</p>
<p>&emsp;&emsp;我们在手机终端敲下debugserver，如果拒绝执行，需要加上运行权限</p>
<blockquote>
<p>chmod +x debugserver </p>
</blockquote>
<h4 id="简单实战"><a href="#简单实战" class="headerlink" title="简单实战"></a>简单实战</h4><p>&emsp;&emsp;我们想要在button的点击事件打个断点</p>
<p><img src="sample2_demo.png" alt="程序示意图"></p>
<p>&emsp;&emsp;找到进程id，此例是607。接着debugserver进行附加程序</p>
<blockquote>
<p>debugserver *:10011 -a 607 </p>
<p>表示的意思是：debugserver 地址:端口 -a 进程id</p>
</blockquote>
<p>&emsp;&emsp;电脑上如果是wifi连接手机的话，命令如下：</p>
<blockquote>
<p>process connect connect://手机ip地址:debugserver的端口号(即上面的607)</p>
</blockquote>
<p>&emsp;&emsp;如果是usb映射连接手机的话，mac上需要多映射一个端口</p>
<blockquote>
<p>python tcprelay.py -t 10011:10011 </p>
</blockquote>
<p>&emsp;&emsp;接着，lldb连接debugserver服务</p>
<blockquote>
<p>process connect connect://localhost:10011 </p>
</blockquote>
<p>&emsp;&emsp;我们用私有方法<code>_shortMethodDescription</code>找到控制器当下所有的方法</p>
<blockquote>
<p>po [[UIApplication sharedApplication].keyWindow.rootViewController _shortMethodDescription] </p>
</blockquote>
<p><img src="sample2_lookup_method.png" alt="查找方法示意图"></p>
<p>&emsp;&emsp;我们找到了一个<code>buttonClick</code>的方法，我们设置断点</p>
<blockquote>
<p>b buttonClick </p>
</blockquote>
<p><img src="sample2_break_method.png" alt="设置方法断点示意图"></p>
<p>&emsp;&emsp;我们输入c，让程序继续运行，然后点下按钮，发现我们的方法被断下了</p>
<p><img src="sample2_break_done.png" alt="方法断点成功示意图"></p>
<h4 id="lldb其他命令"><a href="#lldb其他命令" class="headerlink" title="lldb其他命令"></a>lldb其他命令</h4><ul>
<li>br l ：查看所有断的点</li>
<li>br del 8：把标号为8的断点删除</li>
<li>b name：所有方法叫name的都下断点</li>
<li>b -[NSString stringWithFormat:]：给NSString类的stringWithFormat方法下断点</li>
<li>br s -S count：给所有selector为count的方法下断点</li>
<li>br s -a：内存地址断点 </li>
<li>s：源码级别单步执行，遇到子函数进入</li>
<li>si：单步执行，遇到子函数进入</li>
<li>n：源码级别单步执行，遇到子函数不进入</li>
<li>ni：单步执行，遇到子函数不进入</li>
<li>f：退出子函数</li>
<li>image lookup –address 内存地址</li>
<li>image list -o -f：查看当前进程中的所有模块，一般第一个使我们的主程序，会出现两个值，左边的是ASLR偏移地址，右边是偏移后的地址。右边减去前面就是hopper查看到的基地址</li>
</ul>
<p>参考页面：<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="noopener">http://lldb.llvm.org/lldb-gdb.html</a></p>
<h4 id="更多私有函数"><a href="#更多私有函数" class="headerlink" title="更多私有函数"></a>更多私有函数</h4><ul>
<li>recursiveDescription：按层次打印视图结构，递归方法，所以子视图下的子视图层级也会被打印</li>
<li>_printHierarchy：直接打印某个view的信息</li>
<li>_autolayoutTrace：recursiveDescription的简化版，去掉了view的相关描述</li>
<li>_ivarDescription：所有成员变量的名字和值</li>
<li>_methodDescription：打印对象的属性、实例方法和类方法</li>
</ul>
<hr>
<h1 id="0x07-theos"><a href="#0x07-theos" class="headerlink" title="0x07 theos"></a>0x07 theos</h1><h4 id="1-修改Mac的环境变量"><a href="#1-修改Mac的环境变量" class="headerlink" title="1. 修改Mac的环境变量"></a>1. 修改Mac的环境变量</h4><ul>
<li><p>新建一个theos目录，此例中我们为~/Documents/theos</p>
</li>
<li><p>编辑配置文件</p>
<blockquote>
<p><code>vi ~/.bash_profile</code></p>
</blockquote>
</li>
<li><p>新加入如下两行内容</p>
<blockquote>
<p><code>export THEOS=~/Documents/theos</code></p>
<p><code>export PATH=$THEOS/bin:$PATH</code></p>
</blockquote>
</li>
<li><p>使环境变量生效</p>
<blockquote>
<p><code>source ~/.bash_profile</code></p>
</blockquote>
</li>
</ul>
<h4 id="2-下载theos"><a href="#2-下载theos" class="headerlink" title="2. 下载theos"></a>2. 下载theos</h4><p>&emsp;&emsp; 下载到我们刚才的~/Documents/theos目录</p>
<blockquote>
<p><code>git clone --recursive https://github.com/theos/theos.git $THEOS</code></p>
</blockquote>
<h4 id="3-新建一个Tweak项目"><a href="#3-新建一个Tweak项目" class="headerlink" title="3. 新建一个Tweak项目"></a>3. 新建一个Tweak项目</h4><p>&emsp;&emsp;新建一个目录存放项目，本例中使用~/Documents/hack，进入该目录后输入命令</p>
<blockquote>
<p>nic.pl</p>
</blockquote>
<p><img src="theos_create.png" alt="新建tweak示意图"></p>
<p>&emsp;&emsp;我们选择序号11</p>
<p><img src="tweak_init_project.png" alt="tweak项目初始化示意图"></p>
<p>① 项目名称，<em>随便写</em></p>
<p>② 项目ID，<em>随便写</em></p>
<p>③ 作者，<em>随便写，不写直接回车的话默认选择Mac用户名</em></p>
<p>④ 要被hack的项目Bundle ID，<em>可以用Cycript找到你要项目的Bundle ID</em></p>
<p>⑤ 安装后要关闭的程序列表，<em>直接回车即可</em></p>
<h4 id="4-编辑Makefile"><a href="#4-编辑Makefile" class="headerlink" title="4. 编辑Makefile"></a>4. 编辑Makefile</h4><p>&emsp;&emsp;打开Makefile，添加两个变量说明是通过什么ip和什么端口来访问手机</p>
<ul>
<li>THEOS_DEVICE_IP</li>
<li>THEOS_DEVICE_PORT</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> THEOS_DEVICE_IP=127.0.0.1</span><br><span class="line"><span class="keyword">export</span> THEOS_DEVICE_PORT=10010</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(THEOS)</span>/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = firstTweak</span><br><span class="line">firstTweak_FILES = Tweak.xm</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(THEOS_MAKE_PATH)</span>/tweak.mk</span><br><span class="line"></span><br><span class="line"><span class="section">after-install::</span></span><br><span class="line">	install.exec <span class="string">"killall -9 SpringBoard"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;每次操作嫌麻烦的话，也可以直接到~/.bach_profile中添加。</p>
<h4 id="5-安装"><a href="#5-安装" class="headerlink" title="5. 安装"></a>5. 安装</h4><p>&emsp;&emsp;安装到手机，我们需要三个步骤：编译 –&gt; 打包为deb –&gt;安装</p>
<ul>
<li><p>编译：make</p>
<blockquote>
<p>如果装了多个Xcode可能会导致make报错，需要制定Xcode</p>
<p>sudo xcode-select –switch /Application/Xcode.app/Contents/Developer</p>
<p>如果继续报错，清理下之前的缓存：make clean</p>
</blockquote>
</li>
<li><p>打包：make package</p>
<blockquote>
<p>打包的时候如果遇到错误：</p>
<p><img src="tweak_make_error.png" alt="make package报错示意图"></p>
<p>那就是压缩问题，改成gzip压缩就可以了</p>
<ul>
<li><p>修改dm.pl文件，<code>vim $THEOS/vendor/dm.pl/dm.pl</code>。用#号注释掉<code>use IO::Compress::Lzma;</code>和<code>use IO::Compress::Xz;</code></p>
</li>
<li><p>修改deb.mk内的压缩方式为gzip</p>
<p><code>$ vim $THEOS/makefiles/package/deb.mk</code></p>
<p><code>_THEOS_PLATFORM_DPKG_DEB_COMPRESSION ?= gzip</code></p>
</li>
</ul>
</blockquote>
</li>
<li><p>安装：make install</p>
</li>
</ul>
<h4 id="6-演示"><a href="#6-演示" class="headerlink" title="6. 演示"></a>6. 演示</h4><p>&emsp;&emsp;做个简单demo，我们如下图有5个cell，要求新增2个cell，分别展示6娃和7娃。</p>
<p><img src="tweak_demo_1.png" alt="tweak_demo示意图"></p>
<p>&emsp;&emsp;我们在我们的Tweak项目里，打开Tweak.xm文件，编写代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">%hook ViewController</span><br><span class="line"></span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class="line">    <span class="keyword">return</span> %orig + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">	<span class="keyword">if</span>(indexPath.row == <span class="number">5</span> || indexPath.row == <span class="number">6</span>) &#123;</span><br><span class="line">		UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@<span class="string">"cell"</span>];</span><br><span class="line">	    <span class="keyword">if</span>(!cell) &#123;</span><br><span class="line">	        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@<span class="string">"cell"</span>];</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    cell.textLabel.text = [NSString stringWithFormat:@<span class="string">"%@娃"</span>, @(indexPath.row + <span class="number">1</span>)];</span><br><span class="line">	    <span class="keyword">return</span> cell;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;安装到手机后，会需要确认两次手机root用户的密码</p>
<p><img src="tweak_install.png" alt="tweak_install示意图"></p>
<p>&emsp;&emsp;看下我们软件的变化，我们已经完成了我们的需求。即使重启app，也会一直生效。</p>
<p><img src="tweak_demo_done.png" alt="tweak_demo示意图"></p>
<p>&emsp;&emsp;theos常用语法：</p>
<ul>
<li><p>%hook：与%end配对，表示hook的类名</p>
</li>
<li><p>%orig：调用原来的实现</p>
</li>
<li><p>%new：新建类或方法</p>
</li>
<li><p>%log：打印到控制台</p>
</li>
<li><p>%property：新加属性</p>
<p>更多语法参见：<a href="http://iphonedevwiki.net/index.php/Logos" target="_blank" rel="noopener">http://iphonedevwiki.net/index.php/Logos</a></p>
</li>
</ul>
<hr>
<h1 id="0x08-Frida"><a href="#0x08-Frida" class="headerlink" title="0x08 Frida"></a>0x08 Frida</h1><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><p>&emsp;&emsp;Mac的安装</p>
<blockquote>
<p>sudo pip install frida</p>
</blockquote>
<p>&emsp;&emsp;iPhone的安装</p>
<blockquote>
<p>① 添加源：<a href="https://build.frida.re/" target="_blank" rel="noopener">https://build.frida.re/</a></p>
<p>② 源加完后，搜索Frida进行安装</p>
</blockquote>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h4><p>所有进程：frida-ps -U</p>
<p>附加进程：frida -U 进程名字</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/28/dyld启动流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/dyld启动流程/" itemprop="url">dyld启动流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T17:00:34+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-launchd"><a href="#0x01-launchd" class="headerlink" title="0x01 launchd"></a>0x01 launchd</h1><p>&emsp;&emsp;  launchd是第一个被内核启动的用户态进程，负责直接或间接的启动系统中的其他进程。它是用户模式里所有进程的父进程，同时也将负责两种后台作业：守护程序和代理程序。</p>
<blockquote>
<p>守护程序：后台服务，通常和用户没有交互。比如push通知、外接设备插入的处理和XPC等。</p>
<p>代理程序：可以和用户交互，比如Mac的Finder或iOS的SpringBoard就是其中之一，即广义上我们理解的桌面。</p>
</blockquote>
<p>&emsp;&emsp;  launchd是如何被创建的，得先看下下面这张XNU启动流程图</p>
<p><img src="xnu_start.png" alt="xnu启动示意图"> </p>
<ul>
<li><p>start(iOS)：初始化MSR、物理页映射、安装中断处理函数</p>
</li>
<li><p>arm_init(iOS)：初始化平台，为启动内核做准备</p>
</li>
<li><p>machine_startup：解析命令行参数和调试参数</p>
</li>
<li><p>kernel_bootstrap：安装和初始化mach内核的子系统，包括：进程间通信、时钟、访问策略、进程和线程调度。</p>
</li>
<li><p>kernel_bootstrap_thread：创建idle线程，初始化iokit设备驱动框架，初始化应用程序和dyld运行所需的共享模块。如果内核开启了mac(强制访问控制)策略，则会进行mac的初始化，以确保系统的安全。</p>
</li>
<li><p>bsd_init：内核部分剩余的事情都由其来做，初始化各个子系统。网络、文件系统、管道、内存cache、线程、进程、同步对象、权限策略等等。  一切完成后，会执行/sbin/launchd来创建一个launchd。</p>
</li>
</ul>
<p>  我们看下源码的初始化过程，launchd是怎么被启动起来的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsd_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    bsd_utaskbootstrap();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsd_utaskbootstrap</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">thread_t</span> thread;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">ut</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从内核进程克隆引导进程，但不从内核继承任何任务特性或内存</span></span><br><span class="line">	thread = cloneproc(TASK_NULL, COALITION_NULL, kernproc, FALSE, TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hold the reference as it will be dropped during shutdown */</span></span><br><span class="line">	initproc = proc_find(<span class="number">1</span>);				</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Since we aren't going back out the normal way to our parent,</span></span><br><span class="line"><span class="comment">	 * we have to drop the transition locks explicitly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	proc_signalend(initproc, <span class="number">0</span>);</span><br><span class="line">	proc_transend(initproc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ut = (struct uthread *)get_bsdthread_info(thread);</span><br><span class="line">	ut-&gt;uu_sigmask = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为了真正地创建出任务，对创建出的线程调用这个函数</span></span><br><span class="line">    <span class="comment">// 执行后产生一个异步系统陷阱(AST)，Mach的AST异步处理程序会特别处理这个情况，即调用bsd_ast()</span></span><br><span class="line">	act_set_astbsd(thread);</span><br><span class="line">	task_clear_return_wait(get_threadtask(thread));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsd_ast</span><span class="params">(<span class="keyword">thread_t</span> thread)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">if</span> (!bsd_init_done) &#123;</span><br><span class="line">		bsd_init_done = <span class="number">1</span>;</span><br><span class="line">		bsdinit_task();</span><br><span class="line">	&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsdinit_task</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">proc_t</span> p = current_proc();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">ut</span>;</span></span><br><span class="line">	<span class="keyword">thread_t</span> thread;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将这个从内核态克隆到用户态的第一个线程的名字设置为init</span></span><br><span class="line">	process_name(<span class="string">"init"</span>, p);</span><br><span class="line">	<span class="comment">// 内部创建了一个Mach内核线程处理ux_handler，而ux_handler设置了一个消息循环用于监听异常，如果接收到异常，将异常转换为UNIX信号，并投递到出错线程。</span></span><br><span class="line">	ux_handler_init();</span><br><span class="line"></span><br><span class="line">	thread = current_thread();</span><br><span class="line">    <span class="comment">// ux_handler_init()返回时，ux_handler已经在另一个线程中执行了，并注册好了ux_exception_port。</span></span><br><span class="line">    <span class="comment">// 这个函数将所有的Mach异常消息都重定向到ux_exception_port</span></span><br><span class="line">    <span class="comment">// 由于所有程序都是launchld后代，所以都会继承这个异常端口</span></span><br><span class="line">	(<span class="keyword">void</span>) host_set_exception_ports(host_priv_self(),</span><br><span class="line">					EXC_MASK_ALL &amp; ~(EXC_MASK_RPC_ALERT),<span class="comment">//pilotfish (shark) needs this port</span></span><br><span class="line">					(<span class="keyword">mach_port_t</span>) ux_exception_port,</span><br><span class="line">					EXCEPTION_DEFAULT| MACH_EXCEPTION_CODES,</span><br><span class="line">					<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ut = (<span class="keyword">uthread_t</span>)get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">    vm_init_before_launchd();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	bsd_init_kprintf(<span class="string">"bsd_do_post - done"</span>);</span><br><span class="line">	<span class="comment">// 加载launchd</span></span><br><span class="line">	load_init_program(p);</span><br><span class="line">	lock_trace = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_init_program</span><span class="params">(<span class="keyword">proc_t</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">vm_map_t</span> <span class="built_in">map</span> = current_map();</span><br><span class="line">	<span class="keyword">mach_vm_offset_t</span> scratch_addr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span> map_page_size = vm_map_page_size(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">	(<span class="keyword">void</span>) mach_vm_allocate_kernel(<span class="built_in">map</span>, &amp;scratch_addr, map_page_size, VM_FLAGS_ANYWHERE, VM_KERN_MEMORY_NONE);</span><br><span class="line">    </span><br><span class="line">    error = ENOENT;</span><br><span class="line">    <span class="comment">// 加载“init”程序，这里指的是launchd</span></span><br><span class="line">    <span class="comment">// init_programs保存着要运行程序的路径</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(init_programs)/<span class="keyword">sizeof</span>(init_programs[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"load_init_program: attempting to load %s\n"</span>, init_programs[i]);</span><br><span class="line">        <span class="comment">// 使用从系统克隆出的那个第一个线程加载这个"init"程序，即加载launchd</span></span><br><span class="line">		error = load_init_program_at_path(p, (<span class="keyword">user_addr_t</span>)scratch_addr, init_programs[i]);</span><br><span class="line">		<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"load_init_program: failed loading %s: errno %d\n"</span>, init_programs[i], error);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">"Process 1 exec of %s failed, errno %d"</span>, ((i == <span class="number">0</span>) ? <span class="string">"&lt;null&gt;"</span> : init_programs[i<span class="number">-1</span>]), error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_init_program_at_path</span><span class="params">(<span class="keyword">proc_t</span> p, <span class="keyword">user_addr_t</span> scratch_addr, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execve(p, &amp;init_exec_args, retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;  init_programs装的就是launchd程序的路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * init_programs[] = &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG</span><br><span class="line">	<span class="string">"/usr/local/sbin/launchd.debug"</span>,</span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> DEVELOPMENT || DEBUG</span><br><span class="line">	<span class="string">"/usr/local/sbin/launchd.development"</span>,</span><br><span class="line">#endif</span><br><span class="line">	<span class="string">"/sbin/launchd"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp; &emsp; 我们知道iOS和Mac执行的都是Mach-O格式的文件，即使是launchd也是一样，所以接下来的步骤，同样适用于其他进程加载app程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">proc_t</span> p, struct execve_args *uap, <span class="keyword">int32_t</span> *retval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">mac_execve_args</span> <span class="title">muap</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	memoryshot(VM_EXECVE, DBG_FUNC_NONE);</span><br><span class="line"></span><br><span class="line">	muap.fname = uap-&gt;fname;</span><br><span class="line">	muap.argp = uap-&gt;argp;</span><br><span class="line">	muap.envp = uap-&gt;envp;</span><br><span class="line">	muap.mac_p = USER_ADDR_NULL;</span><br><span class="line">	err = __mac_execve(p, &amp;muap, retval);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-MACH-O格式"><a href="#0x02-MACH-O格式" class="headerlink" title="0x02 MACH-O格式"></a>0x02 MACH-O格式</h1><p>&emsp;&emsp;Mach-O是OS X和iOS的可执行文件，类似于安卓的elf和微软的PE，但又不仅限于可执行文件，比如iOS的动态库其实也可以Mach-O格式。其格式如下图：</p>
<p><img src="MachO_Format.png" alt="Mach-O格式示意图"> </p>
<p>&emsp;&emsp;Mach-O在加载过程中，在内核态的处理主要是对进程的一些基本设置，比如分配虚拟内存、创建主线程以及代码签名、加密等任务。而在转由去用户态的时候调用动态加载器dyld会继续对Mach-O做处理，比如库加载和符号解析等。</p>
<h3 id="1-header"><a href="#1-header" class="headerlink" title="1. header"></a>1. header</h3><p>&emsp;&emsp;头信息的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* 0xfeedfacf表示64位，而0xfeedface表示32位 */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* CPU平台:arm还是i386 */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* armv7、armv8等等 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* 文件类型，比如是可执行程序还是动态库等 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* load commands的数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* load commands的大小 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* 标签参数 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved，保留字段，暂时没用 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-filetype"><a href="#1-1-filetype" class="headerlink" title="1.1 filetype"></a>1.1 filetype</h4><p>&emsp;&emsp;常见的Mach-O文件类型有以下几种：</p>
<ul>
<li><p>MH_OBJECT </p>
<blockquote>
<p>目标文件，比如编译后得到的.o文件</p>
<p>静态库文件，比如.a文件</p>
</blockquote>
</li>
<li><p>MH_EXECUTE </p>
<blockquote>
<p>可执行文件，广义上我们口中常说的app文件，即ipa拆包后得到的文件</p>
</blockquote>
</li>
<li><p>MH_DYLIB </p>
<blockquote>
<p>动态库文件，比如.dylib或.framework</p>
</blockquote>
</li>
<li><p>MH_DYLINKER </p>
<blockquote>
<p>动态链接器，启动dyld</p>
</blockquote>
</li>
<li><p>MH_DSYM </p>
<blockquote>
<p>存储着二进制文件符号信息的文件，常用于分析闪退信息等</p>
</blockquote>
</li>
</ul>
<h4 id="1-2-flags"><a href="#1-2-flags" class="headerlink" title="1.2 flags"></a>1.2 flags</h4><p>&emsp;&emsp;常见的标签参数有以下几种</p>
<ul>
<li><p>MH_DYLDLINK</p>
<blockquote>
<p>作为动态链接器的输入文件，不能再次被静态链接编辑</p>
</blockquote>
</li>
<li><p>MH_PIE</p>
<blockquote>
<p>加载主程序在一个随机地址。仅文件类型是MH_EXECUTE的才有效</p>
</blockquote>
</li>
</ul>
<h3 id="2-Load-Commands"><a href="#2-Load-Commands" class="headerlink" title="2. Load Commands"></a>2. Load Commands</h3><p>&emsp;&emsp;这个主要描述的是文件在虚拟内存中的逻辑结构和布局，可以在被调用的时候清晰地知道如何设置并加载二进制数据。其结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* load command类型 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* 大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Load Commands紧跟着mach_header，其总的大小保存在mach_header里的sizeofcmds里。所有的load commands都必须有自己的两个成员cmd和cmdsize，其中cmdsize在64架构中必须是8的倍数。而cmd表示的是类型，常见的类型如下</p>
<ul>
<li><p>LC_SEGMENT(LC_SEGMENT_64)</p>
<blockquote>
<p>将文件中(32位或64位)的段映射到进程地址空间。包括__text代码区、常量区和OC类信息等。</p>
</blockquote>
</li>
<li><p>LC_LOAD_DYLINKER</p>
<blockquote>
<p>启动动态链接器，dyld</p>
</blockquote>
</li>
<li><p>LC_UUID</p>
<p>这个id是匹配一个二进制文件及其对应的符号，是个唯一值</p>
</li>
<li><p>LC_THREAD</p>
<blockquote>
<p>开启一个Mach线程，不分配栈</p>
</blockquote>
</li>
<li><p>LC_UNIXTHREAD</p>
<blockquote>
<p>开启一个Unix线程，现被LC_MAIN替代</p>
</blockquote>
</li>
<li><p>LC_CORE_SIGNATURE</p>
<blockquote>
<p>代码签名，如果签名与代码本身不匹配，进程会被杀掉</p>
</blockquote>
</li>
<li><p>LC_ENCRYPTION_INFO</p>
<blockquote>
<p>加密信息</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;load_commands在Mach-O中的实例结构如下：</p>
<p><img src="load_commands.png" alt="load_commands示意图"> </p>
<h3 id="3-通用-Mach-O"><a href="#3-通用-Mach-O" class="headerlink" title="3. 通用 Mach-O"></a>3. 通用 Mach-O</h3><p>&emsp;&emsp;根据编译配置，我们可以生成只包含一种架构的Mach-O文件，比如armv7。当然也可以编译生成多架构的的Mach-O文件，这种包含多种架构的我们称之为通用Mach-O，也可以称为Fat Mach-O。运行通用Mach-O的时候，加载器会选择合适的架构的代码去执行。</p>
<h1 id="0x03-地址空间随机布局-ASLR"><a href="#0x03-地址空间随机布局-ASLR" class="headerlink" title="0x03 地址空间随机布局(ASLR)"></a>0x03 地址空间随机布局(ASLR)</h1><p>&emsp;&emsp;如果应用启动的时候都是进程空间某个固定地址开始，这也就意味着内存中的地址分布具有非常强的可预测性，这就给黑客很大的利用机会。所以现在大部分操作系统都会采用ASLR这样的技术，这将有效防止被攻击。</p>
<p>&emsp;&emsp;进程每一次启动时，地址空间都将被随机化，即偏移。实现方法是通过内核将Mach-O的Segment平移某个随机系数。后面的代码阅读中，我们将会遇到这个技术。</p>
<h1 id="0x04-dyld被加载流程"><a href="#0x04-dyld被加载流程" class="headerlink" title="0x04 dyld被加载流程"></a>0x04 dyld被加载流程</h1><p>&emsp;&emsp;在UNIX中，进程不能被创建出来，只能通过fork( ) 系统调用复制出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __mac_execve(<span class="keyword">proc_t</span> p, struct __mac_execve_args *uap, <span class="keyword">int32_t</span> *retval)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *bufp = <span class="literal">NULL</span>; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">image_params</span> *<span class="title">imgp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vnode_attr</span> *<span class="title">vap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vnode_attr</span> *<span class="title">origvap</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> is_64 = IS_64BIT_PROCESS(p);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfs_context</span> <span class="title">context</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span>	*<span class="title">uthread</span>;</span></span><br><span class="line">	<span class="keyword">task_t</span> new_task = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">boolean_t</span> should_release_proc_ref = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span> exec_done = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span> in_vfexec = FALSE;</span><br><span class="line">	<span class="keyword">void</span> *inherit = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    context.vc_thread = current_thread();</span><br><span class="line">	context.vc_ucred = kauth_cred_proc_ref(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配一大块内存</span></span><br><span class="line">    MALLOC(bufp, <span class="keyword">char</span> *, (<span class="keyword">sizeof</span>(*imgp) + <span class="keyword">sizeof</span>(*vap) + <span class="keyword">sizeof</span>(*origvap)), M_TEMP, M_WAITOK | M_ZERO);</span><br><span class="line">	imgp = (struct image_params *) bufp;</span><br><span class="line">	<span class="keyword">if</span> (bufp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error = ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> exit_with_error;</span><br><span class="line">	&#125;</span><br><span class="line">	vap = (struct vnode_attr *) (bufp + <span class="keyword">sizeof</span>(*imgp));</span><br><span class="line">	origvap = (struct vnode_attr *) (bufp + <span class="keyword">sizeof</span>(*imgp) + <span class="keyword">sizeof</span>(*vap));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    imgp-&gt;ip_user_fname = uap-&gt;fname;</span><br><span class="line">	imgp-&gt;ip_user_argv = uap-&gt;argp;</span><br><span class="line">	imgp-&gt;ip_user_envv = uap-&gt;envp;</span><br><span class="line">	imgp-&gt;ip_vattr = vap;</span><br><span class="line">	imgp-&gt;ip_origvattr = origvap;</span><br><span class="line">	imgp-&gt;ip_vfs_context = &amp;context;</span><br><span class="line">	imgp-&gt;ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE) | ((p-&gt;p_flag &amp; P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE);</span><br><span class="line">	imgp-&gt;ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);</span><br><span class="line">	imgp-&gt;ip_mac_return = <span class="number">0</span>;</span><br><span class="line">	imgp-&gt;ip_cs_error = OS_REASON_NULL;</span><br><span class="line">    </span><br><span class="line">    uthread = get_bsdthread_info(current_thread());</span><br><span class="line">	<span class="keyword">if</span> (uthread-&gt;uu_flag &amp; UT_VFORK) &#123;</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_VFORK_EXEC;</span><br><span class="line">		in_vfexec = TRUE;</span><br><span class="line">    <span class="comment">// 程序启动需要fork一条新的进程，会走这个else分支</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		imgp-&gt;ip_flags |= IMGPF_EXEC;</span><br><span class="line">        <span class="comment">// fork进程</span></span><br><span class="line">        imgp-&gt;ip_new_thread = fork_create_child(current_task(),</span><br><span class="line">					<span class="literal">NULL</span>, p, FALSE, p-&gt;p_flag &amp; P_LP64, TRUE);</span><br><span class="line">		<span class="comment">/* task and thread ref returned by fork_create_child */</span></span><br><span class="line">		<span class="keyword">if</span> (imgp-&gt;ip_new_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			error = ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> exit_with_error;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		new_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">		context.vc_thread = imgp-&gt;ip_new_thread;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析程序</span></span><br><span class="line">    error = exec_activate_image(imgp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (imgp-&gt;ip_new_thread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        new_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!error &amp;&amp; !in_vfexec) &#123;</span><br><span class="line">		p = proc_exec_switch_task(p, current_task(), new_task, imgp-&gt;ip_new_thread);</span><br><span class="line">	</span><br><span class="line">		should_release_proc_ref = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kauth_cred_unref(&amp;context.vc_ucred);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		task_bank_init(get_threadtask(imgp-&gt;ip_new_thread));</span><br><span class="line">		proc_transend(p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Sever any extant thread affinity */</span></span><br><span class="line">		thread_affinity_exec(current_thread());</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Inherit task role from old task to new task for exec */</span></span><br><span class="line">		<span class="keyword">if</span> (!in_vfexec) &#123;</span><br><span class="line">			proc_inherit_task_role(get_threadtask(imgp-&gt;ip_new_thread), current_task());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">thread_t</span> main_thread = imgp-&gt;ip_new_thread;</span><br><span class="line">		<span class="comment">// 设置进程的主线程</span></span><br><span class="line">		task_set_main_thread_qos(new_task, main_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exec_activate_image</span><span class="params">(struct image_params *imgp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// 调用格式对应的加载函数</span></span><br><span class="line">        <span class="comment">// 比如胖指令集有对应的胖指令集加载函数</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; error == <span class="number">-1</span> &amp;&amp; execsw[i].ex_imgact != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">			error = (*execsw[i].ex_imgact)(imgp);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;execsw的结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">execsw</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*ex_imgact)(struct image_params *);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ex_name;</span><br><span class="line">&#125; execsw[] = &#123;</span><br><span class="line">	&#123; exec_mach_imgact,		<span class="string">"Mach-o Binary"</span> &#125;,</span><br><span class="line">	&#123; exec_fat_imgact,		<span class="string">"Fat Binary"</span> &#125;,</span><br><span class="line">	&#123; exec_shell_imgact,		<span class="string">"Interpreter Script"</span> &#125;,</span><br><span class="line">	&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对应的指令加载，load_machfile函数加载mach-o文件，activate_exec_state处理拿到的结果信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exec_mach_imgact</span><span class="params">(struct image_params *imgp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    lret = load_machfile(imgp, mach_header, thread, &amp;<span class="built_in">map</span>, &amp;load_result);</span><br><span class="line">    .......</span><br><span class="line">    lret = activate_exec_state(task, p, thread, &amp;load_result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">load_return_t</span> load_machfile(</span><br><span class="line">	struct image_params	*imgp,</span><br><span class="line">	struct mach_header	*header,</span><br><span class="line">	<span class="keyword">thread_t</span> 		thread,</span><br><span class="line">	<span class="keyword">vm_map_t</span> 		*mapp,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*result</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	lret = parse_machfile(vp, <span class="built_in">map</span>, thread, header, file_offset, macho_size,</span><br><span class="line">	                      <span class="number">0</span>, aslr_page_offset, dyld_aslr_page_offset, result,</span><br><span class="line">			      <span class="literal">NULL</span>, imgp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">activate_exec_state</span><span class="params">(<span class="keyword">task_t</span> task, <span class="keyword">proc_t</span> p, <span class="keyword">thread_t</span> thread, <span class="keyword">load_result_t</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">     <span class="comment">// 设置入口点</span></span><br><span class="line">    thread_setentrypoint(thread, result-&gt;entry_point);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们再解析完mach-o文件后，就会拿到结果信息取做处理，其中就有一个设置入口点，也就是在解析完毕后就会跳转到这个入口点运行程序，所以这个入口点很关键，那这个入口点是什么呢？其赋值肯定是在解析mach-o的过程中，所以还是得先来看看解析mach-o文件的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">load_return_t</span></span><br><span class="line">parse_machfile(</span><br><span class="line">	struct vnode 		*vp,       </span><br><span class="line">	<span class="keyword">vm_map_t</span>		<span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">thread_t</span>		thread,</span><br><span class="line">	struct mach_header	*header,</span><br><span class="line">	<span class="keyword">off_t</span>			file_offset,</span><br><span class="line">	<span class="keyword">off_t</span>			macho_size,</span><br><span class="line">	<span class="keyword">int</span>			depth,</span><br><span class="line">	<span class="keyword">int64_t</span>			aslr_offset,</span><br><span class="line">	<span class="keyword">int64_t</span>			dyld_aslr_offset,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*result,</span><br><span class="line">	<span class="keyword">load_result_t</span>		*binresult,</span><br><span class="line">	struct image_params	*imgp</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span>		ncmds;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>	*<span class="title">lcp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dylinker_command</span>	*<span class="title">dlp</span> = 0;</span></span><br><span class="line">	<span class="keyword">integer_t</span>		dlarchbits = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span> *			control;</span><br><span class="line">	<span class="keyword">load_return_t</span>		ret = LOAD_SUCCESS;</span><br><span class="line">	<span class="keyword">void</span> *			addr;</span><br><span class="line">	<span class="keyword">vm_size_t</span>		alloc_size, cmds_size;</span><br><span class="line">	<span class="keyword">size_t</span>			offset;</span><br><span class="line">	<span class="keyword">size_t</span>			oldoffset;	<span class="comment">/* for overflow check */</span></span><br><span class="line">	<span class="keyword">int</span>			pass;</span><br><span class="line">	<span class="keyword">proc_t</span>			p = current_proc();		<span class="comment">/* XXXX */</span></span><br><span class="line">	<span class="keyword">int</span>			error;</span><br><span class="line">	<span class="keyword">int</span> 			resid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span>			mach_header_sz = <span class="keyword">sizeof</span>(struct mach_header);</span><br><span class="line">	<span class="keyword">boolean_t</span>		abi64;</span><br><span class="line">	<span class="keyword">boolean_t</span>		got_code_signatures = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span>		found_header_segment = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span>		found_xhdr = FALSE;</span><br><span class="line">	<span class="keyword">int64_t</span>			slide = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">boolean_t</span>		dyld_no_load_addr = FALSE;</span><br><span class="line">	<span class="keyword">boolean_t</span>		is_dyld = FALSE;</span><br><span class="line">	<span class="keyword">vm_map_offset_t</span>		effective_page_mask = MAX(PAGE_MASK, vm_map_page_mask(<span class="built_in">map</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">	<span class="keyword">uint32_t</span>		pagezero_end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span>		executable_end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span>		writable_start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">vm_map_size_t</span>		effective_page_size;</span><br><span class="line"></span><br><span class="line">	effective_page_size = MAX(PAGE_SIZE, vm_map_page_size(<span class="built_in">map</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __arm64__ */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (header-&gt;magic == MH_MAGIC_64 ||</span><br><span class="line">	    header-&gt;magic == MH_CIGAM_64) &#123;</span><br><span class="line">	    	mach_header_sz = <span class="keyword">sizeof</span>(struct mach_header_64);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Break infinite recursion</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (depth &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(LOAD_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此函数会被遍历两次，第一次解析主程序的Mach-O，第二次解析dyld</span></span><br><span class="line">	depth++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	校验文件的CPU架构和当前运行环境的CPU架构是否一致</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (((<span class="keyword">cpu_type_t</span>)(header-&gt;cputype &amp; ~CPU_ARCH_MASK) != (cpu_type() &amp; ~CPU_ARCH_MASK)) ||</span><br><span class="line">	    !grade_binary(header-&gt;cputype, </span><br><span class="line">	    	header-&gt;cpusubtype &amp; ~CPU_SUBTYPE_MASK))</span><br><span class="line">		<span class="keyword">return</span>(LOAD_BADARCH);</span><br><span class="line">		</span><br><span class="line">	abi64 = ((header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 根据文件类型，区别处理</span></span><br><span class="line">	<span class="keyword">switch</span> (header-&gt;filetype) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果是应用程序，即app</span></span><br><span class="line">	<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">		<span class="keyword">if</span> (depth != <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_EMBEDDED</span></span><br><span class="line">		<span class="comment">// 如果需要作为动态链接器的输入文件，肯定会进入这里，因为dyld还需要解析一次主程序</span></span><br><span class="line">		<span class="keyword">if</span> (header-&gt;flags &amp; MH_DYLDLINK) &#123;</span><br><span class="line">			<span class="comment">/* Check properties of dynamic executables */</span></span><br><span class="line">			<span class="keyword">if</span> (!(header-&gt;flags &amp; MH_PIE) &amp;&amp; pie_required(header-&gt;cputype, header-&gt;cpusubtype &amp; ~CPU_SUBTYPE_MASK)) &#123;</span><br><span class="line">				<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">			&#125;</span><br><span class="line">			result-&gt;needs_dynlinker = TRUE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Check properties of static executables (disallowed except for development) */</span></span><br><span class="line">#<span class="keyword">if</span> !(DEVELOPMENT || DEBUG)</span><br><span class="line">			<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果是动态链接器</span></span><br><span class="line">	<span class="keyword">case</span> MH_DYLINKER:</span><br><span class="line">		<span class="keyword">if</span> (depth != <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		is_dyld = TRUE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addr = kalloc(alloc_size);</span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> LOAD_NOSPACE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是dyld动态链接器，并且设置了随机地址加载这个动态链接器，就将随机地址的偏移值赋给slide</span></span><br><span class="line">	<span class="keyword">if</span> ((header-&gt;flags &amp; MH_PIE) || is_dyld) &#123;</span><br><span class="line">		slide = aslr_offset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *  遍历四次，每次只做一件事</span></span><br><span class="line"><span class="comment">	 *  0: 检查代码段和数据段是否对齐</span></span><br><span class="line"><span class="comment">	 *  1: 进程状态, uuid, 代码签名</span></span><br><span class="line"><span class="comment">	 *  2: segments</span></span><br><span class="line"><span class="comment">	 *  3: dyld, encryption, check entry point</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean_t</span> slide_realign = FALSE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">	<span class="keyword">if</span> (!abi64) &#123;</span><br><span class="line">		slide_realign = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (pass = <span class="number">0</span>; pass &lt;= <span class="number">3</span>; pass++) &#123;</span><br><span class="line">		<span class="comment">// 如果不需要做对齐校验，直接下一轮</span></span><br><span class="line">		<span class="keyword">if</span> (pass == <span class="number">0</span> &amp;&amp; !slide_realign &amp;&amp; !is_dyld) &#123;</span><br><span class="line">			<span class="comment">/* if we dont need to realign the slide or determine dyld's load</span></span><br><span class="line"><span class="comment">			 * address, pass 0 can be skipped */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pass == <span class="number">1</span>) &#123;</span><br><span class="line">#<span class="keyword">if</span> __arm64__</span><br><span class="line">			<span class="keyword">boolean_t</span>	is_pie;</span><br><span class="line">			<span class="keyword">int64_t</span>		adjust;</span><br><span class="line"></span><br><span class="line">			is_pie = ((header-&gt;flags &amp; MH_PIE) != <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (pagezero_end != <span class="number">0</span> &amp;&amp;</span><br><span class="line">			    pagezero_end &lt; effective_page_size) &#123;</span><br><span class="line">				<span class="comment">/* need at least 1 page for PAGEZERO */</span></span><br><span class="line">				adjust = effective_page_size;</span><br><span class="line">				MACHO_PRINTF((<span class="string">"pagezero boundary at "</span></span><br><span class="line">					      <span class="string">"0x%llx; adjust slide from "</span></span><br><span class="line">					      <span class="string">"0x%llx to 0x%llx%s\n"</span>,</span><br><span class="line">					      (<span class="keyword">uint64_t</span>) pagezero_end,</span><br><span class="line">					      slide,</span><br><span class="line">					      slide + adjust,</span><br><span class="line">					      (is_pie</span><br><span class="line">					       ? <span class="string">""</span></span><br><span class="line">					       : <span class="string">" BUT NO PIE ****** :-("</span>)));</span><br><span class="line">				<span class="keyword">if</span> (is_pie) &#123;</span><br><span class="line">					slide += adjust;</span><br><span class="line">					pagezero_end += adjust;</span><br><span class="line">					executable_end += adjust;</span><br><span class="line">					writable_start += adjust;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pagezero_end != <span class="number">0</span>) &#123;</span><br><span class="line">				result-&gt;has_pagezero = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (executable_end == writable_start &amp;&amp; </span><br><span class="line">			    (executable_end &amp; effective_page_mask) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">			    (executable_end &amp; FOURK_PAGE_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">				 <span class="comment">// 数据段或代码段校对，让其页对齐</span></span><br><span class="line">				adjust =</span><br><span class="line">					(effective_page_size -</span><br><span class="line">					 (executable_end &amp; effective_page_mask));</span><br><span class="line">				MACHO_PRINTF((<span class="string">"page-unaligned X-W boundary at "</span></span><br><span class="line">					      <span class="string">"0x%llx; adjust slide from "</span></span><br><span class="line">					      <span class="string">"0x%llx to 0x%llx%s\n"</span>,</span><br><span class="line">					      (<span class="keyword">uint64_t</span>) executable_end,</span><br><span class="line">					      slide,</span><br><span class="line">					      slide + adjust,</span><br><span class="line">					      (is_pie</span><br><span class="line">					       ? <span class="string">""</span></span><br><span class="line">					       : <span class="string">" BUT NO PIE ****** :-("</span>)));</span><br><span class="line">				<span class="keyword">if</span> (is_pie)</span><br><span class="line">					slide += adjust;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __arm64__ */</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dyld_no_load_addr &amp;&amp; binresult) &#123;</span><br><span class="line">				<span class="comment">// dyld在用户态的地址 = 随机地址 + 文件最大的虚拟地址</span></span><br><span class="line">				slide = vm_map_round_page(slide + binresult-&gt;max_vm_addr, effective_page_mask);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		offset = mach_header_sz;</span><br><span class="line">		ncmds = header-&gt;ncmds;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (ncmds--) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 *	获取要解析的load_command地址</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			lcp = (struct load_command *)(addr + offset);</span><br><span class="line">			oldoffset = offset;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">switch</span>(lcp-&gt;cmd) &#123;</span><br><span class="line">			<span class="comment">// 指导内核如何设置新运行进行的内存空间。这些段直接从Mach-O加载到内存中</span></span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT: &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> *<span class="title">scp</span> = (<span class="title">struct</span> <span class="title">segment_command</span> *) <span class="title">lcp</span>;</span></span><br><span class="line"></span><br><span class="line">				......</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// segment映射和解析</span></span><br><span class="line">				<span class="comment">// segment下还有区的概念，比如__objc_classlist，__objc_protolist</span></span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 映射文件中的特定的字节到虚拟内存</span></span><br><span class="line">			<span class="keyword">case</span> LC_SEGMENT_64: &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> *<span class="title">scp64</span> = (<span class="title">struct</span> <span class="title">segment_command_64</span> *) <span class="title">lcp</span>;</span></span><br><span class="line">				</span><br><span class="line">				......</span><br><span class="line"></span><br><span class="line">				ret = load_segment(lcp,</span><br><span class="line">				                   header-&gt;filetype,</span><br><span class="line">				                   control,</span><br><span class="line">				                   file_offset,</span><br><span class="line">				                   macho_size,</span><br><span class="line">				                   vp,</span><br><span class="line">				                   <span class="built_in">map</span>,</span><br><span class="line">				                   slide,</span><br><span class="line">				                   result);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// UNIX线程，包含堆栈</span></span><br><span class="line">			<span class="keyword">case</span> LC_UNIXTHREAD:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = load_unixthread(</span><br><span class="line">						 (struct thread_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 替换LC_UNIXTHREAD</span></span><br><span class="line">			<span class="keyword">case</span> LC_MAIN:</span><br><span class="line">				......</span><br><span class="line">				ret = load_main(</span><br><span class="line">						 (struct entry_point_command *) lcp,</span><br><span class="line">						 thread,</span><br><span class="line">						 slide,</span><br><span class="line">						 result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 加载动态链接器</span></span><br><span class="line">			<span class="keyword">case</span> LC_LOAD_DYLINKER:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> ((depth == <span class="number">1</span>) &amp;&amp; (dlp == <span class="number">0</span>)) &#123;</span><br><span class="line">					<span class="comment">// 动态解析器地址</span></span><br><span class="line">					dlp = (struct dylinker_command *)lcp;</span><br><span class="line">					dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ret = LOAD_FAILURE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// uuid</span></span><br><span class="line">			<span class="keyword">case</span> LC_UUID:</span><br><span class="line">				<span class="keyword">if</span> (pass == <span class="number">1</span> &amp;&amp; depth == <span class="number">1</span>) &#123;</span><br><span class="line">					ret = load_uuid((struct uuid_command *) lcp,</span><br><span class="line">							(<span class="keyword">char</span> *)addr + cmds_size,</span><br><span class="line">							result);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">// 代码签名</span></span><br><span class="line">			<span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">				<span class="comment">/* CODE SIGNING */</span></span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">/* pager -&gt; uip -&gt;</span></span><br><span class="line"><span class="comment">				   load signatures &amp; store in uip</span></span><br><span class="line"><span class="comment">				   set VM object "signed_pages"</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				ret = load_code_signature(</span><br><span class="line">					(struct linkedit_data_command *) lcp,</span><br><span class="line">					vp,</span><br><span class="line">					file_offset,</span><br><span class="line">					macho_size,</span><br><span class="line">					header-&gt;cputype,</span><br><span class="line">					result,</span><br><span class="line">					imgp);</span><br><span class="line"></span><br><span class="line">					.......</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_CODE_DECRYPTION</span></span><br><span class="line">			<span class="comment">// 加密的段信息</span></span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">			<span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">				<span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				ret = set_code_unprotect(</span><br><span class="line">					(struct encryption_info_command *) lcp,</span><br><span class="line">					addr, <span class="built_in">map</span>, slide, vp, file_offset,</span><br><span class="line">					header-&gt;cputype, header-&gt;cpusubtype);</span><br><span class="line">					......</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* Other commands are ignored by the kernel */</span></span><br><span class="line">				ret = LOAD_SUCCESS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == LOAD_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Make sure if we need dyld, we got it */</span></span><br><span class="line">		<span class="keyword">if</span> (result-&gt;needs_dynlinker &amp;&amp; !dlp) &#123;</span><br><span class="line">			ret = LOAD_FAILURE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((ret == LOAD_SUCCESS) &amp;&amp; (dlp != <span class="number">0</span>)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 加载动态解析器, 会再次调用一次parse_machfile</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ret = load_dylinker(dlp, dlarchbits, <span class="built_in">map</span>, thread, depth,</span><br><span class="line">					    dyld_aslr_offset, result, imgp);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		.......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == LOAD_BADMACHO &amp;&amp; found_xhdr) &#123;</span><br><span class="line">		ret = LOAD_BADMACHO_UPX;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(addr, alloc_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的过程得到的结果会被赋值进load_result_t这个结果体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">load_result</span> &#123;</span></span><br><span class="line">	<span class="keyword">user_addr_t</span>		mach_header;</span><br><span class="line">	<span class="keyword">user_addr_t</span>		entry_point;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">user_addr_t</span>		user_stack;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>		user_stack_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">user_addr_t</span>		user_stack_alloc;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>		user_stack_alloc_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>	all_image_info_addr;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>		all_image_info_size;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span>			thread_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">		<span class="comment">/* boolean_t */</span>	unixproc	:<span class="number">1</span>,</span><br><span class="line">				needs_dynlinker : <span class="number">1</span>,</span><br><span class="line">				dynlinker	:<span class="number">1</span>,</span><br><span class="line">				validentry	:<span class="number">1</span>,</span><br><span class="line">				has_pagezero    :<span class="number">1</span>,</span><br><span class="line">				using_lcmain	:<span class="number">1</span>,</span><br><span class="line">				is64bit         :<span class="number">1</span>,</span><br><span class="line">						:<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		csflags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		uuid[<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>	min_vm_addr;</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>	max_vm_addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		platform_binary;</span><br><span class="line">	<span class="keyword">off_t</span>			cs_end_offset;</span><br><span class="line">	<span class="keyword">void</span>			*threadstate;</span><br><span class="line">	<span class="keyword">size_t</span>			threadstate_sz;</span><br><span class="line">&#125; <span class="keyword">load_result_t</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么在哪里设置entry_point，其实entry_point的设置在load_dylinker里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">load_return_t</span> load_dylinker&#123;</span><br><span class="line">    .......</span><br><span class="line">	*myresult = load_result_null;</span><br><span class="line">	myresult-&gt;is64bit = result-&gt;is64bit;</span><br><span class="line"></span><br><span class="line">	ret = parse_machfile(vp, <span class="built_in">map</span>, thread, header, file_offset,</span><br><span class="line">	                     macho_size, depth, slide, <span class="number">0</span>, myresult, result, imgp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == LOAD_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">if</span> (result-&gt;threadstate) &#123;</span><br><span class="line">			<span class="comment">/* don't use the app's threadstate if we have a dyld */</span></span><br><span class="line">			kfree(result-&gt;threadstate, result-&gt;threadstate_sz);</span><br><span class="line">		&#125;</span><br><span class="line">		result-&gt;threadstate = myresult-&gt;threadstate;</span><br><span class="line">		result-&gt;threadstate_sz = myresult-&gt;threadstate_sz;</span><br><span class="line"></span><br><span class="line">		result-&gt;dynlinker = TRUE;</span><br><span class="line">        <span class="comment">// 将load_result_t的entry_point，设置为dyld动态链接库的entrypoint，所以启动的时候首先加载的会是dyld。</span></span><br><span class="line">		result-&gt;entry_point = myresult-&gt;entry_point;</span><br><span class="line">		result-&gt;validentry = myresult-&gt;validentry;</span><br><span class="line">		result-&gt;all_image_info_addr = myresult-&gt;all_image_info_addr;</span><br><span class="line">		result-&gt;all_image_info_size = myresult-&gt;all_image_info_size;</span><br><span class="line">		<span class="keyword">if</span> (myresult-&gt;platform_binary) &#123;</span><br><span class="line">			result-&gt;csflags |= CS_DYLD_PLATFORM;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后，梳理下这个app启动流程：</p>
<ul>
<li><p>fork一条新的进程出来</p>
</li>
<li><p>激活app</p>
<blockquote>
<p>a.  区分文件，Mach-o Binary和Fat Binary都有对应的加载函数</p>
<p>b.  分配内存</p>
<p>c.  解析主程序的Mach-O信息</p>
<p>d.  读取主程序Mach-O头信息</p>
<p>e.  遍历主程序每条load command信息，装载进内存</p>
<p>f.  解析dyld，再把d,e的内容再做一遍，期间会将entry_point入口地址改为dyld的入口地址。</p>
</blockquote>
</li>
<li><p>进入entry_point对应的入口，启动dyld</p>
</li>
<li><p>设置进程的主线程</p>
</li>
</ul>
<p>&emsp;&emsp;所有的操作做完，这时候也已经从内核态进入用户态了。</p>
<h1 id="0x05-dyld加载程序流程"><a href="#0x05-dyld加载程序流程" class="headerlink" title="0x05 dyld加载程序流程"></a>0x05 dyld加载程序流程</h1><p>&emsp;&emsp;上面在最后一次加载完dyld后，就进入dyld的入口函数，即<code>__dyld_start</code>，这段其实是一段汇编代码</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__dyld_start</span>:</span><br><span class="line">	// 一些准备工作，获取头、参数等等这类的信息</span><br><span class="line">	<span class="keyword">mov </span>	x28, <span class="built_in">sp</span></span><br><span class="line">	<span class="keyword">and </span>    <span class="built_in">sp</span>, x28, #~<span class="number">15</span>		// force <span class="number">16</span>-<span class="keyword">byte </span>alignment of stack</span><br><span class="line">	<span class="keyword">mov	</span>x0, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">mov	</span>x1, <span class="number">#0</span></span><br><span class="line">	stp	x1, x0, [<span class="built_in">sp</span>, #-<span class="number">16</span>]!	// make aligned terminating frame</span><br><span class="line">	<span class="keyword">mov	</span><span class="built_in">fp</span>, <span class="built_in">sp</span>			// set up <span class="built_in">fp</span> to point to terminating frame</span><br><span class="line">	<span class="keyword">sub	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             // make room for local variables</span><br><span class="line">	<span class="keyword">ldr </span>    x0, [x28]		// <span class="meta">get</span> app<span class="string">'s mh into x0</span></span><br><span class="line"><span class="string"> 	ldr     x1, [x28, #8]           // get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="string">	add     x2, x28, #16		// get argv into x2</span></span><br><span class="line"><span class="string">	adrp	x4,___dso_handle@page</span></span><br><span class="line"><span class="string">	add 	x4,x4,___dso_handle@pageoff // get dyld'</span>s mh in to x4</span><br><span class="line">	<span class="keyword">adrp	</span>x3,__dso_static<span class="comment">@page</span></span><br><span class="line">	<span class="keyword">ldr </span>	x3,[x3,__dso_static<span class="comment">@pageoff] // get unslid start of dyld</span></span><br><span class="line">	<span class="keyword">sub </span>	x3,x4,x3		// x3 now has slide of dyld</span><br><span class="line">	<span class="keyword">mov	</span>x5,<span class="built_in">sp</span>                   // x5 has &amp;startGlue</span><br><span class="line">	</span><br><span class="line">	// 启动引导，入口为dyldbootstrap::start函数</span><br><span class="line">	<span class="keyword">bl	</span>__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br><span class="line">	// 会返回主程序的入口地址，并保存到x16寄存器</span><br><span class="line">	<span class="keyword">mov	</span>x16,x0                  </span><br><span class="line">	<span class="keyword">ldr </span>    x1, [<span class="built_in">sp</span>]</span><br><span class="line">	<span class="keyword">cmp	</span>x1, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">b.ne	</span>Lnew</span><br><span class="line"></span><br><span class="line">	// LC_UNIXTHREAD，由LC_MAIN代替，所以直接看下面的LC_MAIN</span><br><span class="line">	<span class="keyword">add	</span><span class="built_in">sp</span>, x28, <span class="number">#8</span>		</span><br><span class="line">	<span class="keyword">br	</span>x16			</span><br><span class="line"></span><br><span class="line">	// LC_MAIN ，设置栈信息，并跳入到主程序的入口</span><br><span class="line"><span class="symbol">Lnew</span>:	<span class="keyword">mov	</span><span class="built_in">lr</span>, x1		    // simulate return <span class="keyword">address </span>into _start in libdyld.dylib</span><br><span class="line">	<span class="keyword">ldr </span>    x0, [x28, <span class="number">#8</span>] 	    // 参数<span class="number">1</span> = argc</span><br><span class="line">	<span class="keyword">add </span>    x1, x28, <span class="number">#16</span>	    // 参数<span class="number">2</span> = argv</span><br><span class="line">	<span class="keyword">add	</span>x2, x1, x0, <span class="keyword">lsl </span><span class="number">#3</span>  </span><br><span class="line">	<span class="keyword">add	</span>x2, x2, <span class="number">#8</span>	    // 参数<span class="number">3</span> = &amp;env[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">mov	</span>x3, x2</span><br><span class="line"><span class="symbol">Lapple</span>:	<span class="keyword">ldr	</span>x4, [x3]</span><br><span class="line">	<span class="keyword">add	</span>x3, x3, <span class="number">#8</span></span><br><span class="line">	<span class="keyword">cmp	</span>x4, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">b.ne	</span>Lapple		    // 参数<span class="number">4</span> = apple</span><br><span class="line">	// 跳转到主程序的main函数</span><br><span class="line">	<span class="keyword">br	</span>x16</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>__dyld_start</code>首先会调用<code>dyldbootstrap::start</code>函数对主程序再次进行一些处理，比如加载动态库，处理完成后会返回主程序的入口地址，然后设置好主程序入口的一些参数后就进入到主程序的main函数。我们关注的是主程序启动前还做了些什么事情？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> start(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span><br><span class="line">				<span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span><br><span class="line">				<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( slide != <span class="number">0</span> ) &#123;</span><br><span class="line">		rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	mach_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line">	<span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> _main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	dyld3::kdebug_trace_dyld_signpost(DBG_DYLD_SIGNPOST_START_DYLD, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line">	<span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> ( hexToBytes(_simple_getenv(apple, <span class="string">"executable_cdhash"</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line">		mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trace dyld's load</span></span><br><span class="line">	notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">"dyld_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">	<span class="comment">// Trace the main executable's load</span></span><br><span class="line">	notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, <span class="string">"executable_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line">	sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line">	sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line"></span><br><span class="line">	CRSetCrashLogMessage(<span class="string">"dyld: launch started"</span>);</span><br><span class="line">	<span class="comment">// 设置上下文运行环境</span></span><br><span class="line">	setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line">	sExecPath = _simple_getenv(apple, <span class="string">"executable_path"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remember short name of process for later logging</span></span><br><span class="line">	sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">'/'</span>);</span><br><span class="line">	<span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">		++sExecShortName;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置进程限制</span></span><br><span class="line">    configureProcessRestrictions(mainExecutableMH);</span><br><span class="line"></span><br><span class="line">	checkEnvironmentVariables(envp);</span><br><span class="line">    </span><br><span class="line">	defaultUninitializedFallbackPaths(envp);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">		printOptions(argv);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">		printEnvironmentVariables(envp);</span><br><span class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	checkSharedRegionDisable((mach_header*)mainExecutableMH);</span><br><span class="line">	<span class="comment">// 加载共享缓存库</span></span><br><span class="line">	<span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">		mapSharedCache();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// install gdb notifier</span></span><br><span class="line">	stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB);</span><br><span class="line">	stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages);</span><br><span class="line">	<span class="comment">// make initial allocations large enough that it is unlikely to need to be re-alloced</span></span><br><span class="line">	sImageRoots.reserve(<span class="number">16</span>);</span><br><span class="line">	sAddImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">	sRemoveImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">	sImageFilesNeedingTermination.reserve(<span class="number">16</span>);</span><br><span class="line">	sImageFilesNeedingDOFUnregistration.reserve(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// add dyld itself to UUID list</span></span><br><span class="line">		addDyldImageToUUIDList();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		<span class="keyword">bool</span> mainExcutableAlreadyRebased = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> ( (sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span>) &amp;&amp; !dylibsCanOverrideCache() &amp;&amp; !sDisableAcceleratorTables &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.accelerateInfoAddr != <span class="number">0</span>) ) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statBuf</span>;</span></span><br><span class="line">			<span class="keyword">if</span> ( ::stat(IPHONE_DYLD_SHARED_CACHE_DIR <span class="string">"no-dyld2-accelerator-tables"</span>, &amp;statBuf) != <span class="number">0</span> )</span><br><span class="line">				sAllCacheImagesProxy = ImageLoaderMegaDylib::makeImageLoaderMegaDylib(&amp;sSharedCacheLoadInfo.loadAddress-&gt;header, sSharedCacheLoadInfo.slide, mainExecutableMH, gLinkContext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">reloadAllImages:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line">		<span class="comment">// 初始化主程序</span></span><br><span class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">		gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		gLinkContext.strictMachORequired = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		sAllImages.reserve((sAllCacheImagesProxy != <span class="literal">NULL</span>) ? <span class="number">16</span> : INITIAL_IMAGE_COUNT);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		sAllImages.reserve(INITIAL_IMAGE_COUNT);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line">		checkVersionedPaths();</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line">		<span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line">		<span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">		<span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line">		<span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="comment">// get path of dyld itself</span></span><br><span class="line">		<span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> len = proc_regionfilename(getpid(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line">		<span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			dyldPathBuffer[len] = <span class="string">'\0'</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">				gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加载插入的动态库</span></span><br><span class="line">		<span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">				loadInsertedDylib(*lib);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line">		<span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">		sInsertedDylibCount = sAllImages.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 链接主程序</span></span><br><span class="line">		gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">		<span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">			gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 链接插入的动态库</span></span><br><span class="line">		<span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line">		<span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line">		<span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">				link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">				image-&gt;setNeverUnloadRecursive();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line">			<span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">				image-&gt;registerInterposing();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">			ImageLoader* image = sAllImages[i];</span><br><span class="line">			<span class="keyword">if</span> ( image-&gt;inSharedCache() )</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			image-&gt;registerInterposing();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		<span class="keyword">if</span> ( (sAllCacheImagesProxy != <span class="literal">NULL</span>) &amp;&amp; ImageLoader::haveInterposingTuples() ) &#123;</span><br><span class="line">			<span class="comment">// Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled</span></span><br><span class="line">			ImageLoader::clearInterposingTuples();</span><br><span class="line">			<span class="comment">// unmap all loaded dylibs (but not main executable)</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> i=<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i];</span><br><span class="line">				<span class="keyword">if</span> ( image == sMainExecutable )</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> ( image == sAllCacheImagesProxy )</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				image-&gt;setCanUnload();</span><br><span class="line">				ImageLoader::deleteImage(image);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table</span></span><br><span class="line">			sAllImages.clear();</span><br><span class="line">			sImageRoots.clear();</span><br><span class="line">			sImageFilesNeedingTermination.clear();</span><br><span class="line">			sImageFilesNeedingDOFUnregistration.clear();</span><br><span class="line">			sAddImageCallbacks.clear();</span><br><span class="line">			sRemoveImageCallbacks.clear();</span><br><span class="line">			sDisableAcceleratorTables = <span class="literal">true</span>;</span><br><span class="line">			sAllCacheImagesProxy = <span class="literal">NULL</span>;</span><br><span class="line">			sMappedRangesStart = <span class="literal">NULL</span>;</span><br><span class="line">			mainExcutableAlreadyRebased = <span class="literal">true</span>;</span><br><span class="line">			gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">			resetAllImages();</span><br><span class="line">			<span class="keyword">goto</span> reloadAllImages;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// apply interposing to initial set of images</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.size(); ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;applyInterposing(gLinkContext);</span><br><span class="line">		&#125;</span><br><span class="line">		gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">        <span class="comment">// 弱符号绑定</span></span><br><span class="line">		sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		CRSetCrashLogMessage(<span class="string">"dyld: launch, running initializers"</span>);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">		initializeMainExecutable(); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line">		dyld3::kdebug_trace_dyld_signpost(DBG_DYLD_SIGNPOST_START_MAIN_DYLD2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		notifyMonitoringDyldMain();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 寻找主程序入口点</span></span><br><span class="line">		result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getThreadPC();</span><br><span class="line">		<span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="comment">// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib</span></span><br><span class="line">			<span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">				*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				halt(<span class="string">"libdyld.dylib support not present for LC_MAIN"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let "start" in program set up for main()</span></span><br><span class="line">			result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getMain();</span><br><span class="line">			*startGlue = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* message) &#123;</span><br><span class="line">		syncAllImages();</span><br><span class="line">		halt(message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(...) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: launch failed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CRSetCrashLogMessage(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sSkipMain) &#123;</span><br><span class="line">		dyld3::kdebug_trace_dyld_signpost(DBG_DYLD_SIGNPOST_START_MAIN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		result = (<span class="keyword">uintptr_t</span>)&amp;fake_main;</span><br><span class="line">		*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;主要的步骤如下：</p>
<ul>
<li>设置上下文运行环境</li>
<li>加载共享缓存库</li>
<li>初始化主程序</li>
<li>加载插入的动态库</li>
<li>链接主程序</li>
<li>链接插入的动态库</li>
<li>初始化主程序</li>
<li>寻找主程序入口点</li>
<li>进入主程序入口点</li>
</ul>
<h4 id="加载共享缓存库：mapSharedCache"><a href="#加载共享缓存库：mapSharedCache" class="headerlink" title="加载共享缓存库：mapSharedCache"></a>加载共享缓存库：mapSharedCache</h4><p>&emsp;&emsp;我们需要知道，像每个app自带的动态库，比如libobj或者libdispatch，都是被映射到在一个共享区，每个app都是从这里读取动态库的内容。这样就可以大大节省了内存空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapSharedCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dyld3::SharedCacheOptions opts;</span><br><span class="line">	opts.cacheDirOverride	= sSharedCacheOverrideDir;</span><br><span class="line">	opts.forcePrivate		= (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion);</span><br><span class="line">	opts.useHaswell			= sHaswell;</span><br><span class="line">	opts.verbose			= gLinkContext.verboseMapping;</span><br><span class="line">    <span class="comment">// 加载动态库缓存</span></span><br><span class="line">	loadDyldCache(opts, &amp;sSharedCacheLoadInfo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update global state</span></span><br><span class="line">	<span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">		dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate;</span><br><span class="line">		dyld::gProcessInfo-&gt;sharedCacheSlide                = sSharedCacheLoadInfo.slide;</span><br><span class="line">		dyld::gProcessInfo-&gt;sharedCacheBaseAddress          = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">		sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID);</span><br><span class="line">		dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, (<span class="keyword">const</span> <span class="keyword">uuid_t</span> *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[<span class="number">0</span>], &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;&#123; <span class="number">0</span>, <span class="number">0</span> &#125;&#125;, (<span class="keyword">const</span> mach_header *)sSharedCacheLoadInfo.loadAddress);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadDyldCache</span><span class="params">(<span class="keyword">const</span> SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    results-&gt;loadAddress        = <span class="number">0</span>;</span><br><span class="line">    results-&gt;slide              = <span class="number">0</span>;</span><br><span class="line">    results-&gt;cachedDylibsGroup  = <span class="literal">nullptr</span>;</span><br><span class="line">    results-&gt;errorMessage       = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( options.forcePrivate ) &#123;</span><br><span class="line">        <span class="comment">// mmap cache into this process only</span></span><br><span class="line">        <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经映射到了共享区域了，直接将它在共享内存中的内存地址映射到进程的内存地址空间</span></span><br><span class="line">        <span class="keyword">if</span> ( reuseExistingCache(options, results) )</span><br><span class="line">            <span class="keyword">return</span> (results-&gt;errorMessage != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是第一个程序刚刚启动，共享区其实没内容的，需要将库映射到共享区</span></span><br><span class="line">        <span class="keyword">return</span> mapCacheSystemWide(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化主程序：instantiateFromLoadedImage"><a href="#初始化主程序：instantiateFromLoadedImage" class="headerlink" title="初始化主程序：instantiateFromLoadedImage"></a>初始化主程序：instantiateFromLoadedImage</h4><p>&emsp;&emsp;主要工作就是创建一个装在主程序的映像加载器(ImageLoader)。主要流程就三步：</p>
<ul>
<li>检查主程序运行的CPU架构与当前设备的CPU架构是否匹配</li>
<li>实例化一个ImageLoader</li>
<li>把ImageLoader添加到一个管理表中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">		addImage(image);</span><br><span class="line">		<span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;主要看下<code>instantiateMainExecutable</code>的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> compressed;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line">	<span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line">	<span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line">    <span class="comment">// 判断主程序是否压缩的，现在基本的程序都是压缩的</span></span><br><span class="line">    <span class="comment">// 判断方式通过段类型为LC_DYLD_INFO和LC_DYLD_INFO_ONLY的信息</span></span><br><span class="line">    <span class="comment">// switch (cmd-&gt;cmd) &#123;</span></span><br><span class="line">	<span class="comment">// 		case LC_DYLD_INFO:</span></span><br><span class="line">	<span class="comment">// 		case LC_DYLD_INFO_ONLY:</span></span><br><span class="line">	<span class="comment">// 			if ( cmd-&gt;cmdsize != sizeof(dyld_info_command) )</span></span><br><span class="line">	<span class="comment">// 				throw "malformed mach-o image: LC_DYLD_INFO size wrong";</span></span><br><span class="line">	<span class="comment">// 			dyldInfoCmd = (struct dyld_info_command*)cmd;</span></span><br><span class="line">	<span class="comment">//			*compressed = true;</span></span><br><span class="line">	<span class="comment">//			break;</span></span><br><span class="line">    <span class="comment">//      .......</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//  ......</span></span><br><span class="line">	sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line">	<span class="comment">// 根据load commands的内容来实例化具体类，这里返回一个ImageLoaderMachOCompressed对象</span></span><br><span class="line">	<span class="keyword">if</span> ( compressed ) </span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加载插入的动态库：loadInsertedDylib"><a href="#加载插入的动态库：loadInsertedDylib" class="headerlink" title="加载插入的动态库：loadInsertedDylib"></a>加载插入的动态库：loadInsertedDylib</h4><p>&emsp;&emsp;循环遍历<code>DYLD_INSERT_LIBRARIES</code>环境变量中指定的动态库列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInsertedDylib</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> cacheIndex;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		LoadContext context;</span><br><span class="line">		.......</span><br><span class="line">		image = load(path, context, cacheIndex);</span><br><span class="line">	&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从DYLD_ROOT_PATH路径进行查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase0</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ROOT_PATH</span></span><br><span class="line">	<span class="comment">// handle DYLD_ROOT_PATH which forces absolute paths to use a new root</span></span><br><span class="line">	<span class="keyword">if</span> ( (gLinkContext.rootPaths != <span class="literal">NULL</span>) &amp;&amp; (path[<span class="number">0</span>] == <span class="string">'/'</span>) ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* rootPath = gLinkContext.rootPaths ; *rootPath != <span class="literal">NULL</span>; ++rootPath) &#123;</span><br><span class="line">			<span class="keyword">char</span> newPath[<span class="built_in">strlen</span>(*rootPath) + <span class="built_in">strlen</span>(path)+<span class="number">2</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(newPath, *rootPath);</span><br><span class="line">			<span class="built_in">strcat</span>(newPath, path);</span><br><span class="line">			ImageLoader* image = loadPhase1(newPath, orgPath, context, cacheIndex, exceptions);</span><br><span class="line">			<span class="keyword">if</span> ( image != <span class="literal">NULL</span> )</span><br><span class="line">				<span class="keyword">return</span> image;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// try raw path</span></span><br><span class="line">	<span class="keyword">return</span> loadPhase1(path, orgPath, context, cacheIndex, exceptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loadPhase1从LD_LIBRARY_PATH路径进行查找</span></span><br><span class="line"><span class="comment">// loadPhase2从executable_path路径进行查找</span></span><br><span class="line"><span class="comment">// loadPhase3 ~ loadPhase4类似的路径查找</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase5</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* orgPath, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;* exceptions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DylibOverride&gt;::iterator it = sDylibOverrides.begin(); it != sDylibOverrides.end(); ++it) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(it-&gt;installName, path) == <span class="number">0</span> ) &#123;</span><br><span class="line">			path = it-&gt;override;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( exceptions != <span class="literal">NULL</span> ) </span><br><span class="line">        <span class="comment">// 尝试打开，如果在共享区，直接返回该动态库对应的加载器(ImageLoader)，如果不是则在硬盘区，则尝试打开，如果能打开调用loadPhase6将动态库映射到一个加载器</span></span><br><span class="line">		<span class="keyword">return</span> loadPhase5load(path, orgPath, context, cacheIndex, exceptions);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 检查是否已经存在，如果已经存在直接返回</span></span><br><span class="line">		<span class="keyword">return</span> loadPhase5check(path, orgPath, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase6</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct stat&amp; stat_buf, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ( isCompatibleMachO(firstPages, path) ) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查MACH-0类型，只有MH_BUNDLE, MH_DYLIB, 和一些MH_EXECUTE类型才可以被动态加载</span></span><br><span class="line">		<span class="keyword">const</span> mach_header* mh = (mach_header*)firstPages;</span><br><span class="line">		<span class="keyword">switch</span> ( mh-&gt;filetype ) &#123;</span><br><span class="line">			<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">			<span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> MH_BUNDLE:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"mach-o, but wrong filetype"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 初始化一个映像加载器</span></span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateFromFile(path, fd, firstPages, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 添加到全局管理</span></span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链接主程序：link"><a href="#链接主程序：link" class="headerlink" title="链接主程序：link"></a>链接主程序：link</h4><p>&emsp;&emsp;这步主要加载所有的动态库，符号绑定等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::link(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// clear error strings</span></span><br><span class="line">	(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">    <span class="comment">// 递归加载所有动态库</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">	context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we only do the loading step for preflights</span></span><br><span class="line">	<span class="keyword">if</span> ( preflightOnly )</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	context.clearAllDepths();</span><br><span class="line">    <span class="comment">// 刷新库依赖的层级。层级越深，depth越大</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">    <span class="comment">// 递归修正自己和加载动态库的基地址</span></span><br><span class="line"> 	<span class="keyword">this</span>-&gt;recursiveRebase(context);</span><br><span class="line">	context.notifyBatch(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uint64_t</span> t3 = mach_absolute_time();</span><br><span class="line">    <span class="comment">// 对no-lazy符号进行绑定，修正那些指向其他二进制文件所包含的符号的指针</span></span><br><span class="line">    <span class="comment">// lazy在运行时绑定。</span></span><br><span class="line"> 	<span class="keyword">this</span>-&gt;recursiveBind(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> t4 = mach_absolute_time();</span><br><span class="line">    <span class="comment">// 弱符号绑定</span></span><br><span class="line">	<span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">		<span class="keyword">this</span>-&gt;weakBind(context);</span><br><span class="line">	<span class="keyword">uint64_t</span> t5 = mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	context.notifyBatch(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> t6 = mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DOFInfo&gt; dofs;</span><br><span class="line">    <span class="comment">// 注册程序的DOF节区，供dtrace使用</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">	context.registerDOFs(dofs);</span><br><span class="line">	<span class="keyword">uint64_t</span> t7 = mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line">	<span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != <span class="number">0</span>) ) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;recursiveApplyInterposing(context);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// clear error strings</span></span><br><span class="line">	(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">	fgTotalRebaseTime += t3 - t2;</span><br><span class="line">	fgTotalBindTime += t4 - t3;</span><br><span class="line">	fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">	fgTotalDOF += t7 - t6;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// done with initial dylib loads</span></span><br><span class="line">	fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;继续看Mach-O格式图，我们可以看到text段下有<code>__stubs</code>和<code>__stb_helper</code>，以及data段下有<code>__nl_symbol_ptr</code>和<code>__la_symbol_ptr</code>。</p>
<p><img src="MachO_Stub.png" alt="Mach-O示意图"> </p>
<p>&emsp;&emsp;<code>__nl_symbol_ptr</code>和<code>__la_symbol_ptr</code> 分别表示non lazy binding指针表和lazy binding指针表，这两个指针表分别保存的是字符串标对应的函数地址。</p>
<p>&emsp;&emsp;我们通过一个例子来了解<code>__stubs</code>、<code>__stb_helper</code>和<code>__nl_symbol_ptr</code>、<code>__la_symbol_ptr</code> 之间的关系。测试代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"测试1"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"测试2"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在第一个printf打下断点，进入汇编模式进行查看</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">testData</span>`main:</span><br><span class="line">    <span class="number">0x1000ca618</span> &lt;+<span class="number">0</span>&gt;:  <span class="keyword">sub </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x30</span>             <span class="comment">; =0x30 </span></span><br><span class="line">    <span class="number">0x1000ca61c</span> &lt;+<span class="number">4</span>&gt;:  stp    x29, x30, [<span class="built_in">sp</span>, <span class="number">#0x20</span>]</span><br><span class="line">    <span class="number">0x1000ca620</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">add </span>   x29, <span class="built_in">sp</span>, <span class="number">#0x20</span>            <span class="comment">; =0x20 </span></span><br><span class="line">    <span class="number">0x1000ca624</span> &lt;+<span class="number">12</span>&gt;: stur   wzr, [x29, #-<span class="number">0x4</span>]</span><br><span class="line">    <span class="number">0x1000ca628</span> &lt;+<span class="number">16</span>&gt;: stur   w0, [x29, #-<span class="number">0x8</span>]</span><br><span class="line">    <span class="number">0x1000ca62c</span> &lt;+<span class="number">20</span>&gt;: <span class="keyword">str </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">-&gt;  <span class="number">0x1000ca630</span> &lt;+<span class="number">24</span>&gt;: <span class="keyword">adrp </span>  x0, <span class="number">4</span></span><br><span class="line">    <span class="number">0x1000ca634</span> &lt;+<span class="number">28</span>&gt;: <span class="keyword">add </span>   x0, x0, <span class="number">#0x871</span>            <span class="comment">; =0x871 </span></span><br><span class="line">    <span class="comment">; 跳入__stubs区</span></span><br><span class="line">    <span class="number">0x1000ca638</span> &lt;+<span class="number">32</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x1000cc67c</span>               <span class="comment">; symbol stub for: printf</span></span><br><span class="line">   </span><br><span class="line">// 查看<span class="number">0x1000cc67c</span>处内存内容是什么</span><br><span class="line">// 的确是跳入stubs区</span><br><span class="line">(lldb) image lookup --<span class="keyword">address </span><span class="number">0x1000cc67c</span></span><br><span class="line"><span class="symbol">      Address:</span> testData[<span class="number">0x000000010000867c</span>] (testData.__TEXT.__stubs + <span class="number">540</span>)</span><br><span class="line"><span class="symbol">      Summary:</span> testData`symbol stub for: printf</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;给<code>0x1000cc67c</code>下断点，继续看进入stub做什么了</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">testData</span>`printf:</span><br><span class="line">-&gt;  <span class="number">0x1000cc67c</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">nop</span></span><br><span class="line"><span class="keyword">	</span><span class="comment">; 跳入0x00000001000cc934，即进入stub_helper</span></span><br><span class="line">    <span class="number">0x1000cc680</span> &lt;+<span class="number">4</span>&gt;: <span class="keyword">ldr </span>   x16, <span class="number">#0x3b70</span>              <span class="comment">; (void *)0x0000000100080934</span></span><br><span class="line">    <span class="number">0x1000cc684</span> &lt;+<span class="number">8</span>&gt;: <span class="keyword">br </span>    x16</span><br><span class="line">    </span><br><span class="line"> // 查看<span class="number">0x00000001000cc934</span>内容，发现进入了stub_helper</span><br><span class="line"> (lldb) image lookup --<span class="keyword">address </span><span class="number">0x0000000100080934</span></span><br><span class="line"><span class="symbol">      Address:</span> testData[<span class="number">0x0000000100008934</span>] (testData.__TEXT.__stub_helper + <span class="number">588</span>)</span><br><span class="line"><span class="symbol">      Summary:</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;0x0000000100080934  - 0x0000000000078000  = 0x0000000100008934 ，而这个0x0000000100008934在Mach-O的位置，就是<code>__la_symbol_ptr</code> 内指向printf位置的地址</p>
<p><img src="stub_lazy.png" alt="Mach-O示意图"> </p>
<p>&emsp;&emsp;继续给0x0000000100080934 下断点，查看后面指令</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt;  <span class="number">0x1000cc934</span>: <span class="keyword">ldr </span>   w16, <span class="number">0x1000cc93c</span></span><br><span class="line">    <span class="number">0x1000cc938</span>: <span class="keyword">b </span>     <span class="number">0x1000cc6e8</span></span><br><span class="line">  </span><br><span class="line"> (lldb) image lookup --<span class="keyword">address </span><span class="number">0x1001046e8</span></span><br><span class="line"><span class="symbol">      Address:</span> testData[<span class="number">0x00000001000086e8</span>] (testData.__TEXT.__stub_helper + <span class="number">0</span>)</span><br><span class="line"><span class="symbol">      Summary:</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;0x1000cc6e8处下断点</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1001046e8</span>: <span class="keyword">adr </span>   x17, <span class="number">#0x3998</span>              <span class="comment">; (void *)0x00000001200da038: initialPoolContent + 2856</span></span><br><span class="line"><span class="number">0x1001046ec</span>: <span class="keyword">nop </span>   </span><br><span class="line"><span class="number">0x1001046f0</span>: stp    x16, x17, [<span class="built_in">sp</span>, #-<span class="number">0x10</span>]!</span><br><span class="line"><span class="number">0x1001046f4</span>: <span class="keyword">nop </span></span><br><span class="line"><span class="comment">;跳入dyld_stub_binder函数</span></span><br><span class="line"><span class="number">0x1001046f8</span>: <span class="keyword">ldr </span>   x16, <span class="number">#0x3980</span>              <span class="comment">; (void *)0x00000001944e915c: dyld_stub_binder</span></span><br><span class="line"><span class="number">0x1001046fc</span>: <span class="keyword">br </span>    x16</span><br><span class="line"><span class="number">0x100104700</span>: <span class="keyword">ldr </span>   w16, <span class="number">0x100104708</span></span><br><span class="line"><span class="number">0x100104704</span>: <span class="keyword">b </span>     <span class="number">0x1001046e8</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>dyld_stub_binder</code>函数是个汇编函数，它函数地址其实是从<code>__nl_symbol_ptr</code>取到的，在ARM中<code>__nl_symbol_ptr</code>就是<code>__got</code>。</p>
<p><img src="stub_binder.png" alt="Mach-O示意图"></p>
<p>&emsp;&emsp;总结，第一次访问printf符号的时候先去<code>stub</code>，<code>stub</code>告诉从<code>__la_symbol_ptr</code>查找，<code>__la_symbol_ptr</code>表示还没有printf符号真实函数地址，需要动态绑定，于是去<code>__nl_symbol_ptr</code>查找<code>dyld_stub_binder</code>函数的地址，进行查找真实的printf地址。找到后调用printf函数，并把这个地址保存进<code>__la_symbol_ptr</code>。下次调用printf函数的时候在<code>__la_symbol_ptr</code>就能得到真实地址进行跳转。</p>
<h4 id="初始化主程序：initializeMainExecutable"><a href="#初始化主程序：initializeMainExecutable" class="headerlink" title="初始化主程序：initializeMainExecutable"></a>初始化主程序：initializeMainExecutable</h4><p>&emsp;&emsp;初始化主程序和以及其相关的模块，比如动态库。这时候就会执行以前文章说的libobjc库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record that we've reached this step</span></span><br><span class="line">	gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">	initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.size();</span><br><span class="line">	<span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">	<span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dump info if requested</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">		ImageLoader::printStatistics((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">		ImageLoaderMachO::printStatisticsDetails((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImageLoader::runInitializers(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	<span class="keyword">mach_port_t</span> thisThread = mach_thread_self();</span><br><span class="line">	ImageLoader::UninitedUpwards up;</span><br><span class="line">	up.count = <span class="number">1</span>;</span><br><span class="line">	up.images[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line">	processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">	context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line">	mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line">	<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">	fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImageLoader::processInitializers(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread,</span><br><span class="line">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> maxImageCount = context.imageCount()+<span class="number">2</span>;</span><br><span class="line">	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">	ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">	ups.count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 递归初始化所有的映像加载器内的数据，Load方法也在这里被初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line">	<span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line">		processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="寻找主程序入口点：getThreadPC"><a href="#寻找主程序入口点：getThreadPC" class="headerlink" title="寻找主程序入口点：getThreadPC"></a>寻找主程序入口点：getThreadPC</h4><p>&emsp;&emsp;在<code>LC_MAIN</code>段，程序入口点的保存位置是程序的头的起始位置 + 段记录的偏移地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* ImageLoaderMachO::getThreadPC() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">const</span> <span class="title">cmds</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)&amp;<span class="title">fMachOData</span>[<span class="title">sizeof</span>(<span class="title">macho_header</span>)];</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">cmd</span> = <span class="title">cmds</span>;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( cmd-&gt;cmd == LC_MAIN ) &#123;</span><br><span class="line">			entry_point_command* mainCmd = (entry_point_command*)cmd;</span><br><span class="line">			<span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(mainCmd-&gt;entryoff + (<span class="keyword">char</span>*)fMachOData);</span><br><span class="line">			<span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line">				<span class="keyword">return</span> entry;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"LC_MAIN entryoff is out of range"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/26/iOS的内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/26/iOS的内存管理/" itemprop="url">iOS的内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-26T15:25:13+08:00">
                2018-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-Tagged-Pointer"><a href="#0x01-Tagged-Pointer" class="headerlink" title="0x01 Tagged Pointer"></a>0x01 Tagged Pointer</h1><p>&emsp;&emsp;当我们定义一个变量的时候，比如<code>NSNumber *a = @123</code>，内存中的分布如下</p>
<p><img src="temp_var_sample.png" alt="变量内存示意图"> </p>
<p>&emsp;&emsp;这样就造成了资源浪费，定义一个变量，保存简单的<code>123</code>却用了16个字节，造成了内存碎片；而且为了维护它，还需要额外的开销用引用计数管理它。所以在64系统中，苹果为了解决这样的问题，提出了Tagged Pointer概念。</p>
<p>&emsp;&emsp;Tagged Pointer直接将数据保存到指针中，其指针格式变为tag + data的形式，一般用于NSNumber、NSString、NSDate。我们以NSString为例，看下什么是Tagged Pointer。</p>
<p>&emsp;&emsp;首先定义变量如下</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *a = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"123"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *b = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"1234567890123456"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能下面这样定义，这样定义的@"123"是常量</span></span><br><span class="line"><span class="built_in">NSString</span> *a = <span class="string">@"123"</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们看到变量a的类型变为<code>NSTaggedPointerString</code></p>
<p><img src="NSTaggedPointerString.png" alt="NSTaggedPointerString示意图"> </p>
<p>&emsp;&emsp;我们再打印下内存地址看下，很明显变量a的地址由33 + 32 + 31 + 字符串长度组成，其中3表示字符串类型的tag，后面的3、2、1就是保存的值。而变量b的地址很明显是个堆地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p a</span><br><span class="line">(NSTaggedPointerString *) $<span class="number">0</span> = <span class="number">0xa000000003332313</span> @<span class="string">"123"</span></span><br><span class="line">(lldb) p b</span><br><span class="line">(__NSCFString *) $<span class="number">1</span> = <span class="number">0x00000001d004b250</span> @<span class="string">"1234567890123456"</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么，下面的代码会有什么问题？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"123456789012"</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们会看到闪退，这是因为多线程环境下，调用setter方法的时候，可能多个线程同时进入到if语句内，导致同一个对象在引用计数只有1的情况下，<code>release</code>方法被重复调用，从而造成闪退。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">if</span>(_name != name) &#123;</span><br><span class="line">        [_name release];</span><br><span class="line">        _name = [name <span class="keyword">retain</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么同样的，下面的代码会闪退吗？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"123"</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;答案是不会，因为self.name此时是Tagged Pointer，不参与引用计数管理，其retainCount可以认为是个无限值，所以任由你release，能闪退算它输。</p>
<p>&emsp;&emsp;我们可以通过<code>CFGetRetainCount</code>计算retainCount来证实下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            self.name = [NSString stringWithFormat:@<span class="string">"%@"</span>, @<span class="string">"123"</span>];</span><br><span class="line">            CFIndex idx = CFGetRetainCount((__bridge CFTypeRef)(self.name));</span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印的值</span></span><br><span class="line">(CFIndex) idx = <span class="number">9223372036854775807</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;正是因为这样的特性，同样我们在下面的代码，打印变量a的值还是<code>123</code>，而不是<code>nil</code>。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *a = <span class="literal">nil</span>;</span><br><span class="line">   <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        a = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"123"</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, a);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么，我们看下系统是怎么判断是不是Tagged Pointer。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于宏<code>_OBJC_TAG_MASK</code>定义又如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK 1UL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于OBJC_MSB_TAGGED_POINTERS定义如下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX &amp;&amp; __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 0 <span class="comment">// macOS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 1 <span class="comment">// iOS或者模拟器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以我们可以看到，当时macOS系统的时候，就拿地址最后一位是不是1来判断是不是taggedPoint；而对于iOS来说，则判断最高位是不是为1，就拿之前例子里的<code>0xa000000003332313</code>为例，0xa表示为1010，最高位显然为1，所以是这个是TaggedPointer。</p>
<h1 id="0x02-weak"><a href="#0x02-weak" class="headerlink" title="0x02 weak"></a>0x02 weak</h1><p>&emsp;&emsp;首先，看下如下测试代码</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着，我们看下其汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">testData`main:</span><br><span class="line">    0x102e1d808 &lt;+0&gt;:   sub    sp, sp, #0x40             ; =0x40 </span><br><span class="line">    0x102e1d80c &lt;+4&gt;:   stp    x29, x30, [sp, #0x30]</span><br><span class="line">    0x102e1d810 &lt;+8&gt;:   add    x29, sp, #0x30            ; =0x30 </span><br><span class="line">    0x102e1d814 &lt;+12&gt;:  adrp   x8, 9</span><br><span class="line">    0x102e1d818 &lt;+16&gt;:  add    x8, x8, #0xf8             ; =0xf8 </span><br><span class="line">    0x102e1d81c &lt;+20&gt;:  adrp   x9, 8</span><br><span class="line">    0x102e1d820 &lt;+24&gt;:  add    x9, x9, #0xf38            ; =0xf38 </span><br><span class="line">    0x102e1d824 &lt;+28&gt;:  adrp   x10, 7</span><br><span class="line">    0x102e1d828 &lt;+32&gt;:  ldr    x10, [x10, #0x68]</span><br><span class="line">    0x102e1d82c &lt;+36&gt;:  add    x11, sp, #0x18            ; =0x18 </span><br><span class="line">    0x102e1d830 &lt;+40&gt;:  stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x102e1d834 &lt;+44&gt;:  stur   w0, [x29, #-0x8]</span><br><span class="line">    0x102e1d838 &lt;+48&gt;:  stur   x1, [x29, #-0x10]</span><br><span class="line">-&gt;  0x102e1d83c &lt;+52&gt;:  ldr    x0, [x8]</span><br><span class="line">    0x102e1d840 &lt;+56&gt;:  ldr    x1, [x9]</span><br><span class="line">    0x102e1d844 &lt;+60&gt;:  str    x11, [sp, #0x10]</span><br><span class="line">    0x102e1d848 &lt;+64&gt;:  blr    x10</span><br><span class="line">    0x102e1d84c &lt;+68&gt;:  ldr    x8, [sp, #0x10]</span><br><span class="line">    0x102e1d850 &lt;+72&gt;:  str    x0, [sp, #0x8]</span><br><span class="line">    0x102e1d854 &lt;+76&gt;:  mov    x0, x8</span><br><span class="line">    0x102e1d858 &lt;+80&gt;:  ldr    x1, [sp, #0x8]</span><br><span class="line">    0x102e1d85c &lt;+84&gt;:  bl     0x102e20e68               ; symbol stub for: objc_initWeak</span><br><span class="line">    0x102e1d860 &lt;+88&gt;:  ldr    x1, [sp, #0x8]</span><br><span class="line">    0x102e1d864 &lt;+92&gt;:  mov    x0, x1</span><br><span class="line">    0x102e1d868 &lt;+96&gt;:  bl     0x102e20eb0               ; symbol stub for: objc_release</span><br><span class="line">    0x102e1d86c &lt;+100&gt;: stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x102e1d870 &lt;+104&gt;: ldr    x0, [sp, #0x10]</span><br><span class="line">    0x102e1d874 &lt;+108&gt;: bl     0x102e20e14               ; symbol stub for: objc_destroyWeak</span><br><span class="line">    0x102e1d878 &lt;+112&gt;: ldur   w0, [x29, #-0x4]</span><br><span class="line">    0x102e1d87c &lt;+116&gt;: ldp    x29, x30, [sp, #0x30]</span><br><span class="line">    0x102e1d880 &lt;+120&gt;: add    sp, sp, #0x40             ; =0x40 </span><br><span class="line">    0x102e1d884 &lt;+124&gt;: ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以发现，声明<code>__weak</code>后其内部实现过程中调用了<code>objc_initWeak</code>和<code>objc_destroyWeak</code>。但是如果测试例子再修改如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;汇编代码变化如下，发现再给<code>__weak</code>声明的变量重新赋值的时候调用的是<code>objc_storeWeak</code></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">testData</span>`main:</span><br><span class="line">    <span class="number">0x102cc5778</span> &lt;+<span class="number">0</span>&gt;:   <span class="keyword">sub </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x70</span>             <span class="comment">; =0x70 </span></span><br><span class="line">    <span class="number">0x102cc577c</span> &lt;+<span class="number">4</span>&gt;:   stp    x29, x30, [<span class="built_in">sp</span>, <span class="number">#0x60</span>]</span><br><span class="line">    <span class="number">0x102cc5780</span> &lt;+<span class="number">8</span>&gt;:   <span class="keyword">add </span>   x29, <span class="built_in">sp</span>, <span class="number">#0x60</span>            <span class="comment">; =0x60 </span></span><br><span class="line">    <span class="number">0x102cc5784</span> &lt;+<span class="number">12</span>&gt;:  <span class="keyword">adrp </span>  x8, <span class="number">9</span></span><br><span class="line">    <span class="number">0x102cc5788</span> &lt;+<span class="number">16</span>&gt;:  <span class="keyword">add </span>   x8, x8, <span class="number">#0xf8</span>             <span class="comment">; =0xf8 </span></span><br><span class="line">    <span class="number">0x102cc578c</span> &lt;+<span class="number">20</span>&gt;:  <span class="keyword">adrp </span>  x9, <span class="number">8</span></span><br><span class="line">    <span class="number">0x102cc5790</span> &lt;+<span class="number">24</span>&gt;:  <span class="keyword">add </span>   x9, x9, <span class="number">#0xf38</span>            <span class="comment">; =0xf38 </span></span><br><span class="line">    <span class="number">0x102cc5794</span> &lt;+<span class="number">28</span>&gt;:  <span class="keyword">adrp </span>  x10, <span class="number">7</span></span><br><span class="line">    <span class="number">0x102cc5798</span> &lt;+<span class="number">32</span>&gt;:  <span class="keyword">ldr </span>   x10, [x10, <span class="number">#0x68</span>]</span><br><span class="line">    <span class="number">0x102cc579c</span> &lt;+<span class="number">36</span>&gt;:  <span class="keyword">sub </span>   x11, x29, <span class="number">#0x18</span>           <span class="comment">; =0x18 </span></span><br><span class="line">    <span class="number">0x102cc57a0</span> &lt;+<span class="number">40</span>&gt;:  stur   wzr, [x29, #-<span class="number">0x4</span>]</span><br><span class="line">    <span class="number">0x102cc57a4</span> &lt;+<span class="number">44</span>&gt;:  stur   w0, [x29, #-<span class="number">0x8</span>]</span><br><span class="line">    <span class="number">0x102cc57a8</span> &lt;+<span class="number">48</span>&gt;:  stur   x1, [x29, #-<span class="number">0x10</span>]</span><br><span class="line">-&gt;  <span class="number">0x102cc57ac</span> &lt;+<span class="number">52</span>&gt;:  <span class="keyword">ldr </span>   x0, [x8]</span><br><span class="line">    <span class="number">0x102cc57b0</span> &lt;+<span class="number">56</span>&gt;:  <span class="keyword">ldr </span>   x1, [x9]</span><br><span class="line">    <span class="number">0x102cc57b4</span> &lt;+<span class="number">60</span>&gt;:  <span class="keyword">str </span>   x11, [<span class="built_in">sp</span>, <span class="number">#0x30</span>]</span><br><span class="line">    <span class="number">0x102cc57b8</span> &lt;+<span class="number">64</span>&gt;:  <span class="keyword">str </span>   x10, [<span class="built_in">sp</span>, <span class="number">#0x28</span>]</span><br><span class="line">    <span class="number">0x102cc57bc</span> &lt;+<span class="number">68</span>&gt;:  <span class="keyword">str </span>   x8, [<span class="built_in">sp</span>, <span class="number">#0x20</span>]</span><br><span class="line">    <span class="number">0x102cc57c0</span> &lt;+<span class="number">72</span>&gt;:  <span class="keyword">str </span>   x9, [<span class="built_in">sp</span>, <span class="number">#0x18</span>]</span><br><span class="line">    <span class="number">0x102cc57c4</span> &lt;+<span class="number">76</span>&gt;:  <span class="keyword">blr </span>   x10</span><br><span class="line">    <span class="number">0x102cc57c8</span> &lt;+<span class="number">80</span>&gt;:  <span class="keyword">ldr </span>   x8, [<span class="built_in">sp</span>, <span class="number">#0x30</span>]</span><br><span class="line">    <span class="number">0x102cc57cc</span> &lt;+<span class="number">84</span>&gt;:  <span class="keyword">str </span>   x0, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="number">0x102cc57d0</span> &lt;+<span class="number">88</span>&gt;:  <span class="keyword">mov </span>   x0, x8</span><br><span class="line">    <span class="number">0x102cc57d4</span> &lt;+<span class="number">92</span>&gt;:  <span class="keyword">ldr </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="number">0x102cc57d8</span> &lt;+<span class="number">96</span>&gt;:  <span class="keyword">bl </span>    <span class="number">0x102cc8e44</span>               <span class="comment">; symbol stub for: objc_initWeak</span></span><br><span class="line">    <span class="number">0x102cc57dc</span> &lt;+<span class="number">100</span>&gt;: <span class="keyword">ldr </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="number">0x102cc57e0</span> &lt;+<span class="number">104</span>&gt;: <span class="keyword">mov </span>   x0, x1</span><br><span class="line">    <span class="number">0x102cc57e4</span> &lt;+<span class="number">108</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x102cc8e8c</span>               <span class="comment">; symbol stub for: objc_release</span></span><br><span class="line">    <span class="number">0x102cc57e8</span> &lt;+<span class="number">112</span>&gt;: <span class="keyword">ldr </span>   x8, [<span class="built_in">sp</span>, <span class="number">#0x20</span>]</span><br><span class="line">    <span class="number">0x102cc57ec</span> &lt;+<span class="number">116</span>&gt;: <span class="keyword">ldr </span>   x0, [x8]</span><br><span class="line">    <span class="number">0x102cc57f0</span> &lt;+<span class="number">120</span>&gt;: <span class="keyword">ldr </span>   x9, [<span class="built_in">sp</span>, <span class="number">#0x18</span>]</span><br><span class="line">    <span class="number">0x102cc57f4</span> &lt;+<span class="number">124</span>&gt;: <span class="keyword">ldr </span>   x1, [x9]</span><br><span class="line">    <span class="number">0x102cc57f8</span> &lt;+<span class="number">128</span>&gt;: <span class="keyword">ldr </span>   x10, [<span class="built_in">sp</span>, <span class="number">#0x28</span>]</span><br><span class="line">    <span class="number">0x102cc57fc</span> &lt;+<span class="number">132</span>&gt;: <span class="keyword">blr </span>   x10</span><br><span class="line">    <span class="number">0x102cc5800</span> &lt;+<span class="number">136</span>&gt;: <span class="keyword">str </span>   x0, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">    <span class="number">0x102cc5804</span> &lt;+<span class="number">140</span>&gt;: <span class="keyword">b </span>     <span class="number">0x102cc5808</span>               <span class="comment">; &lt;+144&gt; at main.m</span></span><br><span class="line">    <span class="number">0x102cc5808</span> &lt;+<span class="number">144</span>&gt;: <span class="keyword">sub </span>   x8, x29, <span class="number">#0x18</span>            <span class="comment">; =0x18 </span></span><br><span class="line">    <span class="number">0x102cc580c</span> &lt;+<span class="number">148</span>&gt;: <span class="keyword">mov </span>   x0, x8</span><br><span class="line">    <span class="number">0x102cc5810</span> &lt;+<span class="number">152</span>&gt;: <span class="keyword">ldr </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">    <span class="number">0x102cc5814</span> &lt;+<span class="number">156</span>&gt;: <span class="keyword">str </span>   x8, [<span class="built_in">sp</span>]</span><br><span class="line">    <span class="number">0x102cc5818</span> &lt;+<span class="number">160</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x102cc8ee0</span>               <span class="comment">; symbol stub for: objc_storeWeak</span></span><br><span class="line">    <span class="number">0x102cc581c</span> &lt;+<span class="number">164</span>&gt;: <span class="keyword">ldr </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">    <span class="number">0x102cc5820</span> &lt;+<span class="number">168</span>&gt;: <span class="keyword">mov </span>   x0, x1</span><br><span class="line">    <span class="number">0x102cc5824</span> &lt;+<span class="number">172</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x102cc8e8c</span>               <span class="comment">; symbol stub for: objc_release</span></span><br><span class="line">    <span class="number">0x102cc5828</span> &lt;+<span class="number">176</span>&gt;: stur   wzr, [x29, #-<span class="number">0x4</span>]</span><br><span class="line">    <span class="number">0x102cc582c</span> &lt;+<span class="number">180</span>&gt;: <span class="keyword">ldr </span>   x0, [<span class="built_in">sp</span>]</span><br><span class="line">    <span class="number">0x102cc5830</span> &lt;+<span class="number">184</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x102cc8df0</span>               <span class="comment">; symbol stub for: objc_destroyWeak</span></span><br><span class="line">    <span class="number">0x102cc5834</span> &lt;+<span class="number">188</span>&gt;: ldur   w0, [x29, #-<span class="number">0x4</span>]</span><br><span class="line">    <span class="number">0x102cc5838</span> &lt;+<span class="number">192</span>&gt;: ldp    x29, x30, [<span class="built_in">sp</span>, <span class="number">#0x60</span>]</span><br><span class="line">    <span class="number">0x102cc583c</span> &lt;+<span class="number">196</span>&gt;: <span class="keyword">add </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x70</span>             <span class="comment">; =0x70 </span></span><br><span class="line">    <span class="number">0x102cc5840</span> &lt;+<span class="number">200</span>&gt;: ret    </span><br><span class="line">    <span class="number">0x102cc5844</span> &lt;+<span class="number">204</span>&gt;: <span class="keyword">sub </span>   x8, x29, <span class="number">#0x18</span>            <span class="comment">; =0x18 </span></span><br><span class="line">    <span class="number">0x102cc5848</span> &lt;+<span class="number">208</span>&gt;: <span class="keyword">mov </span>   x9, x1</span><br><span class="line">    <span class="number">0x102cc584c</span> &lt;+<span class="number">212</span>&gt;: stur   x0, [x29, #-<span class="number">0x20</span>]</span><br><span class="line">    <span class="number">0x102cc5850</span> &lt;+<span class="number">216</span>&gt;: stur   w9, [x29, #-<span class="number">0x24</span>]</span><br><span class="line">    <span class="number">0x102cc5854</span> &lt;+<span class="number">220</span>&gt;: <span class="keyword">mov </span>   x0, x8</span><br><span class="line">    <span class="number">0x102cc5858</span> &lt;+<span class="number">224</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x102cc8df0</span>               <span class="comment">; symbol stub for: objc_destroyWeak</span></span><br><span class="line">    <span class="number">0x102cc585c</span> &lt;+<span class="number">228</span>&gt;: ldur   x0, [x29, #-<span class="number">0x20</span>]</span><br><span class="line">    <span class="number">0x102cc5860</span> &lt;+<span class="number">232</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x102cc8c94</span>               <span class="comment">; symbol stub for: _Unwind_Resume</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;查看源码比较下<code>objc_initWeak</code>和<code>objc_storeWeak</code>的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_storeWeak</span><span class="params">(id *location, id newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;虽然都是统一调用<code>storeWeak</code>函数，两者之间只有一个区分，就是<code>objc_initWeak</code>是没有旧值的，而<code>objc_storeWeak</code>是有旧值的，即<code>DontHaveOld</code>和<code>DoHaveOld</code>的区别。</p>
<p>&emsp;&emsp;最后会调用<code>objc_destroyWeak</code>函数进行销毁所有指向对象的弱引用对象。销毁的时候，告诉<code>storeWeak</code>函数没有新值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_destroyWeak</span><span class="params">(id *location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h3><p>&emsp;&emsp;我们直接来到源码，看下其实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> id <span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line">              </span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// 如果是旧值，拿到旧值的那个哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        <span class="comment">// *location 赋值给oldObj</span></span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是新值，拿到新值的那个哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">	<span class="comment">// 如果是旧值。之前*location赋值给过oldObj，如果不一致，说明有别的线程进来改过了，则重新尝试。</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是新值则需要判断有没有调用过initialized方法，如果没有这里进行调用</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line"></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理旧值，解除注册</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册新值</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            <span class="comment">// newObject为所赋的值。比如例子中的[NSObject new], location为例子中的NSObject *obj</span></span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置isa的weakly_referenced位为true</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SlideTable"><a href="#SlideTable" class="headerlink" title="SlideTable"></a>SlideTable</h3><p>&emsp;&emsp;定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts; <span class="comment">// 引用的数量</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table; <span class="comment">// 弱引用表，保存着所有的关联着对象的弱引用地址</span></span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries; <span class="comment">// 上面说的保存的地址就是保存在这里</span></span><br><span class="line">    <span class="keyword">size_t</span>    num_entries;</span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span> *referrers; <span class="comment">// 关联着对象的弱引用地址保存在这里</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        mask;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">weak_entry_t</span>&amp; other) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;具体解释是这样的，在我们的例子中<code>__weak NSObject *obj = [NSObject new];</code>，<code>[NSObject new]</code>新构造了一个对象，这个对象有个SlideTable维护弱引用表，表里保存的就是<code>NSObject *obj</code>变量的地址。</p>
<h3 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h3><p>&emsp;&emsp;源码先行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">weak_unregister_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span></span></span><br><span class="line"><span class="function"><span class="params">                        id *referrer_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 解除引用关联，referer为引用对象的地址，即例子中的NSObject *obj变量的地址</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 如果弱引用对象没有关联的对象了，表也可以删了</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;具体如何解除引用过程如下，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **old_referrer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="keyword">size_t</span> index = begin;</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 入参old_referrer在我们的例子中就是NSObject *obj变量的地址。然后查找表中的每个引用数据，如果找到的数据跟NSObject *obj变量的地址相等，就将其置为nil</span></span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></span><br><span class="line">                         <span class="string">"at %p. This is probably incorrect use of "</span></span><br><span class="line">                         <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                         <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h3><p>&emsp;&emsp;还是先看源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">weak_register_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span></span></span><br><span class="line"><span class="function"><span class="params">                      id *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BOOL (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (BOOL(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((id)referent, </span><br><span class="line">                                           SEL_allowsWeakReference);</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((id)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="comment">// 结合例子来说，就是找到[NSObject new]新创建出对象的weak_entry_t，然后把NSObject *obj变量的地址加入到这个表中，这样做的目的就是，当[NSObject new]的对象销毁后，只要遍历这个对象里的弱引用表，就可以把所有指向这块内存的变量地址都可以置nil。</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">weak_entry_t</span> new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h3><p>&emsp;&emsp;当一个对象销毁时，会调用<code>object_dispose</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">object_dispose</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line">		<span class="comment">// 是否c++，是的话调用析构函数</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="comment">// 是否有关联属性，是的话移出关联属性</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="comment">// 清理并销毁对象</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">		<span class="comment">// 如果是弱引用对象</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最终如果是弱引用对象会来到<code>weak_clear_no_lock</code>函数，里面遍历所有指向此对象的对象地址，然后都置为nil。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">weak_clear_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-Copy"><a href="#0x03-Copy" class="headerlink" title="0x03 Copy"></a>0x03 Copy</h1><h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><p>&emsp;&emsp;首先，看下<code>NSString</code>相关的例子</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *a = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"1234567890"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *b = [a <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *c = [a mutableCopy];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p -- %p -- %p"</span>, a, b, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出的结果</span></span><br><span class="line"><span class="number">0x1d02202c0</span> -- <span class="number">0x1d02202c0</span> -- <span class="number">0x1d0445cd0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们发现对于不可变的<code>NSString</code>，<code>copy</code>出来的是不可变对象，并且是浅拷贝，因为地址相同；<code>mutableCopy</code>出来的是可变对象，而且是深拷贝，地址都不同了。</p>
<h3 id="NSMutableString"><a href="#NSMutableString" class="headerlink" title="NSMutableString"></a>NSMutableString</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *a = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"1234567890"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *b = [a <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSMutableString</span> *c = [a mutableCopy];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p -- %p -- %p"</span>, a, b, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出的结果</span></span><br><span class="line"><span class="number">0x1d425d5e0</span> -- <span class="number">0x1d422bfa0</span> -- <span class="number">0x1d425d5b0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于可变的<code>NSMutableString</code>，<code>copy</code>出来的是不可变对象，并且是深拷贝；<code>mutableCopy</code>出来的是可变对象，但也是深拷贝。</p>
<p>&emsp;&emsp;<code>NSArray</code>、<code>NSMutableArray</code>、<code>NSDictionay</code>、<code>NSMutableDictionary</code>其实也类似，具体例子不表述了，总结规律如下：</p>
<ul>
<li>不可变对象的<code>copy</code>出来的是不可变对象，且是浅拷贝；<code>mutableCopy</code>的是可变对象，且是深拷贝。</li>
<li>可变对象的<code>copy</code>出来的是不可变对象，但是深拷贝；<code>mutableCopy</code>的是可变对象，且也是深拷贝</li>
</ul>
<h1 id="0x04-NSProxy"><a href="#0x04-NSProxy" class="headerlink" title="0x04 NSProxy"></a>0x04 NSProxy</h1><p>&emsp;&emsp;在定时器相关的初始化方法中，如果使用的是下面这样的初始化方法，那么由于控制器<code>self</code>本身强引用定时器，而<code>target</code>又会把<code>self</code>传入定时器内部，而在定时器内部又会对<code>self</code>做强引用，这样就造成了循环引用。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.</span>f target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerFire) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span>.displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(displayLinkFire)];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;解决方法，使用NSProxy，通过这个中间介打破强引用关系，然后再利用消息转发，将方法的实现还是转发回原来的target上。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> target;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    MyProxy *proxy = [MyProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 使用自定义的Proxy   </span></span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.</span>f target:[MyProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(timerFire) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span>.displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:[MyProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(displayLinkFire)];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么为什么不是继承<code>NSObject</code>呢，这是因为这样就会走一遍消息转发流程，具体在<code>runtime</code>篇已经讲过，效率没有直接使用<code>NSProxy</code>高。</p>
<p>&emsp;&emsp;当然，这样的使用场景也不止在定时器上，别的地方遇到类似的互相强引用，也可以使用这样的方法解决。</p>
<h1 id="0x05-autoreleasepool"><a href="#0x05-autoreleasepool" class="headerlink" title="0x05 autoreleasepool"></a>0x05 autoreleasepool</h1><p>&emsp;&emsp;我们的示例代码如下</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;转换汇编后，我们可以看到<code>@autoreleasepool</code>实际会被转换为<code>objc_autoreleasePoolPush</code>和<code>objc_autoreleasePoolPop</code>两个函数，而<code>@autoreleasepool</code>中间的代码则被包在这两个函数中间。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">testData</span>`main:</span><br><span class="line">    <span class="number">0x10019d7d0</span> &lt;+<span class="number">0</span>&gt;:   <span class="keyword">sub </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x70</span>             <span class="comment">; =0x70 </span></span><br><span class="line">    <span class="number">0x10019d7d4</span> &lt;+<span class="number">4</span>&gt;:   stp    x29, x30, [<span class="built_in">sp</span>, <span class="number">#0x60</span>]</span><br><span class="line">    <span class="number">0x10019d7d8</span> &lt;+<span class="number">8</span>&gt;:   <span class="keyword">add </span>   x29, <span class="built_in">sp</span>, <span class="number">#0x60</span>            <span class="comment">; =0x60 </span></span><br><span class="line">    <span class="number">0x10019d7dc</span> &lt;+<span class="number">12</span>&gt;:  <span class="keyword">mov </span>   x8, <span class="number">#0x0</span></span><br><span class="line">    <span class="number">0x10019d7e0</span> &lt;+<span class="number">16</span>&gt;:  <span class="keyword">adrp </span>  x9, <span class="number">9</span></span><br><span class="line">    <span class="number">0x10019d7e4</span> &lt;+<span class="number">20</span>&gt;:  <span class="keyword">add </span>   x9, x9, <span class="number">#0xf0</span>             <span class="comment">; =0xf0 </span></span><br><span class="line">    <span class="number">0x10019d7e8</span> &lt;+<span class="number">24</span>&gt;:  <span class="keyword">adrp </span>  x10, <span class="number">8</span></span><br><span class="line">    <span class="number">0x10019d7ec</span> &lt;+<span class="number">28</span>&gt;:  <span class="keyword">add </span>   x10, x10, <span class="number">#0xf30</span>          <span class="comment">; =0xf30 </span></span><br><span class="line">    <span class="number">0x10019d7f0</span> &lt;+<span class="number">32</span>&gt;:  <span class="keyword">adrp </span>  x11, <span class="number">7</span></span><br><span class="line">    <span class="number">0x10019d7f4</span> &lt;+<span class="number">36</span>&gt;:  <span class="keyword">ldr </span>   x11, [x11, <span class="number">#0x68</span>]</span><br><span class="line">    <span class="number">0x10019d7f8</span> &lt;+<span class="number">40</span>&gt;:  stur   wzr, [x29, #-<span class="number">0x4</span>]</span><br><span class="line">    <span class="number">0x10019d7fc</span> &lt;+<span class="number">44</span>&gt;:  stur   w0, [x29, #-<span class="number">0x8</span>]</span><br><span class="line">    <span class="number">0x10019d800</span> &lt;+<span class="number">48</span>&gt;:  stur   x1, [x29, #-<span class="number">0x10</span>]</span><br><span class="line">-&gt;  <span class="number">0x10019d804</span> &lt;+<span class="number">52</span>&gt;:  stur   x8, [x29, #-<span class="number">0x28</span>]</span><br><span class="line">    <span class="number">0x10019d808</span> &lt;+<span class="number">56</span>&gt;:  <span class="keyword">str </span>   x10, [<span class="built_in">sp</span>, <span class="number">#0x30</span>]</span><br><span class="line">    <span class="number">0x10019d80c</span> &lt;+<span class="number">60</span>&gt;:  <span class="keyword">str </span>   x11, [<span class="built_in">sp</span>, <span class="number">#0x28</span>]</span><br><span class="line">    <span class="number">0x10019d810</span> &lt;+<span class="number">64</span>&gt;:  <span class="keyword">str </span>   x9, [<span class="built_in">sp</span>, <span class="number">#0x20</span>]</span><br><span class="line">    <span class="number">0x10019d814</span> &lt;+<span class="number">68</span>&gt;:  <span class="keyword">bl </span>    <span class="number">0x1001a0e14</span>               <span class="comment">; symbol stub for: objc_autoreleasePoolPush</span></span><br><span class="line">    <span class="number">0x10019d818</span> &lt;+<span class="number">72</span>&gt;:  stur   xzr, [x29, #-<span class="number">0x18</span>]</span><br><span class="line">    <span class="number">0x10019d81c</span> &lt;+<span class="number">76</span>&gt;:  <span class="keyword">str </span>   x0, [<span class="built_in">sp</span>, <span class="number">#0x18</span>]</span><br><span class="line">    <span class="number">0x10019d820</span> &lt;+<span class="number">80</span>&gt;:  <span class="keyword">mov </span>   x8, <span class="number">#0x64</span></span><br><span class="line">    <span class="number">0x10019d824</span> &lt;+<span class="number">84</span>&gt;:  ldur   x9, [x29, #-<span class="number">0x18</span>]</span><br><span class="line">    <span class="number">0x10019d828</span> &lt;+<span class="number">88</span>&gt;:  <span class="keyword">cmp </span>   x9, x8</span><br><span class="line">    <span class="number">0x10019d82c</span> &lt;+<span class="number">92</span>&gt;:  cset   w10, lt</span><br><span class="line">    <span class="number">0x10019d830</span> &lt;+<span class="number">96</span>&gt;:  tbnz   w10, <span class="number">#0x0</span>, <span class="number">0x10019d838</span>    <span class="comment">; &lt;+104&gt; at main.m</span></span><br><span class="line">    <span class="number">0x10019d834</span> &lt;+<span class="number">100</span>&gt;: <span class="keyword">b </span>     <span class="number">0x10019d87c</span>               <span class="comment">; &lt;+172&gt; at main.m</span></span><br><span class="line">    <span class="number">0x10019d838</span> &lt;+<span class="number">104</span>&gt;: <span class="keyword">sub </span>   x0, x29, <span class="number">#0x20</span>            <span class="comment">; =0x20 </span></span><br><span class="line">    <span class="number">0x10019d83c</span> &lt;+<span class="number">108</span>&gt;: <span class="keyword">ldr </span>   x8, [<span class="built_in">sp</span>, <span class="number">#0x20</span>]</span><br><span class="line">    <span class="number">0x10019d840</span> &lt;+<span class="number">112</span>&gt;: <span class="keyword">ldr </span>   x9, [x8]</span><br><span class="line">    <span class="number">0x10019d844</span> &lt;+<span class="number">116</span>&gt;: <span class="keyword">ldr </span>   x10, [<span class="built_in">sp</span>, <span class="number">#0x30</span>]</span><br><span class="line">    <span class="number">0x10019d848</span> &lt;+<span class="number">120</span>&gt;: <span class="keyword">ldr </span>   x1, [x10]</span><br><span class="line">    <span class="number">0x10019d84c</span> &lt;+<span class="number">124</span>&gt;: <span class="keyword">str </span>   x0, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="number">0x10019d850</span> &lt;+<span class="number">128</span>&gt;: <span class="keyword">mov </span>   x0, x9</span><br><span class="line">    <span class="number">0x10019d854</span> &lt;+<span class="number">132</span>&gt;: <span class="keyword">ldr </span>   x9, [<span class="built_in">sp</span>, <span class="number">#0x28</span>]</span><br><span class="line">    <span class="number">0x10019d858</span> &lt;+<span class="number">136</span>&gt;: <span class="keyword">blr </span>   x9</span><br><span class="line">    <span class="number">0x10019d85c</span> &lt;+<span class="number">140</span>&gt;: stur   x0, [x29, #-<span class="number">0x20</span>]</span><br><span class="line">    <span class="number">0x10019d860</span> &lt;+<span class="number">144</span>&gt;: <span class="keyword">ldr </span>   x0, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="number">0x10019d864</span> &lt;+<span class="number">148</span>&gt;: ldur   x1, [x29, #-<span class="number">0x28</span>]</span><br><span class="line">    <span class="number">0x10019d868</span> &lt;+<span class="number">152</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x1001a0f04</span>               <span class="comment">; symbol stub for: objc_storeStrong</span></span><br><span class="line">    <span class="number">0x10019d86c</span> &lt;+<span class="number">156</span>&gt;: ldur   x8, [x29, #-<span class="number">0x18</span>]</span><br><span class="line">    <span class="number">0x10019d870</span> &lt;+<span class="number">160</span>&gt;: <span class="keyword">add </span>   x8, x8, <span class="number">#0x1</span>              <span class="comment">; =0x1 </span></span><br><span class="line">    <span class="number">0x10019d874</span> &lt;+<span class="number">164</span>&gt;: stur   x8, [x29, #-<span class="number">0x18</span>]</span><br><span class="line">    <span class="number">0x10019d878</span> &lt;+<span class="number">168</span>&gt;: <span class="keyword">b </span>     <span class="number">0x10019d820</span>               <span class="comment">; &lt;+80&gt; at main.m</span></span><br><span class="line">    <span class="number">0x10019d87c</span> &lt;+<span class="number">172</span>&gt;: <span class="keyword">mov </span>   w0, <span class="number">#0x0</span></span><br><span class="line">    <span class="number">0x10019d880</span> &lt;+<span class="number">176</span>&gt;: <span class="keyword">ldr </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x18</span>]</span><br><span class="line">    <span class="number">0x10019d884</span> &lt;+<span class="number">180</span>&gt;: <span class="keyword">str </span>   w0, [<span class="built_in">sp</span>, <span class="number">#0xc</span>]</span><br><span class="line">    <span class="number">0x10019d888</span> &lt;+<span class="number">184</span>&gt;: <span class="keyword">mov </span>   x0, x1</span><br><span class="line">    <span class="number">0x10019d88c</span> &lt;+<span class="number">188</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x1001a0e08</span>               <span class="comment">; symbol stub for: objc_autoreleasePoolPop</span></span><br><span class="line">    <span class="number">0x10019d890</span> &lt;+<span class="number">192</span>&gt;: <span class="keyword">ldr </span>   w0, [<span class="built_in">sp</span>, <span class="number">#0xc</span>]</span><br><span class="line">    <span class="number">0x10019d894</span> &lt;+<span class="number">196</span>&gt;: ldp    x29, x30, [<span class="built_in">sp</span>, <span class="number">#0x60</span>]</span><br><span class="line">    <span class="number">0x10019d898</span> &lt;+<span class="number">200</span>&gt;: <span class="keyword">add </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x70</span>             <span class="comment">; =0x70 </span></span><br><span class="line">    <span class="number">0x10019d89c</span> &lt;+<span class="number">204</span>&gt;: ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而这两个函数的实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;继续往下前，需要了解<code>AutoreleasePoolPage</code>的结构，定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = PAGE_MAX_SIZE;</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;</span><br><span class="line">    id *next; <span class="comment">// 指向能存放“autorelease对象的地址”的地址</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;</span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;</span><br><span class="line">    </span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先，看到这个结构中有<code>parent</code>和<code>child</code>成员，第一反应这个结构是双向链表。这个结构的大小为<code>PAGE_MAX_SIZE</code>，这是一个宏，其定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_MAX_SIZE           PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PAGE_SIZE				I386_PGBYTES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I386_PGBYTES			4096</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;一个<code>AutoreleasePoolPage</code>的大小为4096字节，除了用来存放其成员变量所占用的空间外，剩余的空间都是用来存放autorelease对象的地址。</p>
<p>&emsp;&emsp;继续之前的源码分析，首先看下<code>push</code>方法的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>push</code>方法里面接着调用了<code>autoreleaseFast</code>，并且传入了一个<code>POOL_BOUNDARY</code>对象，从字面意思理解这个对象是自动释放池的边界，那么它具体指的是什么？我们看到它的宏定义如下，其实就是个<code>nil</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;再继续往下看下源代码，首先看看有没有已经创建了的自动释放池，并且如果没满的话调用<code>AutoreleasePoolPage</code>的<code>add</code>方法，如果满了的话就调用<code>autoreleaseFullPage</code>，最后如果没有创建过自动释放池就新建一个，则调用<code>autoreleaseNoPage</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先看下<code>add</code>方法，直接将<code>POOL_BOUNDARY</code>加入进自动释放池中，并返回<code>POOL_BOUNDARY</code>的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    assert(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    id *ret = next;  </span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着看<code>autoreleaseFullPage</code>，前面说过自动释放池是双链表形式存在的，所以先遍历表，找到空的链表，然后把对象加入这个池子中；但是如果没子链表，那么就新建一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    assert(page == hotPage());</span><br><span class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后，看下<code>autoreleaseNoPage</code>，也是简单明了的代码，直接新建一个自动释放池，并将其设置为hot，因为自动释放池肯定有很多个，当前活跃的可添加自动释放对象的自动释放池为hot，否则为cold。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">        setHotPage(page);</span><br><span class="line">        </span><br><span class="line">		... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看完<code>push</code>方法源码，我们可以总结，当首次调用<code>AutoreleasePoolPage</code>的<code>push</code>方法时候，会将一个<code>POOL_BOUNDARY</code>入栈，并且会返回其存放的内存地址，这个地址也就是能存放自动释放对象的空间的首地址。所以，后面的autorelease对象的地址存放在这个<code>POOL_BOUNDARY</code>所在地址的后面。</p>
<p><img src="autoreleasepool_format.png" alt="AutoreleasePoolPage内存示意图"> </p>
<p>&emsp;&emsp;如果4096的空间都被用完了，就会新创建一个<code>AutoreleasePoolPage</code>对象。</p>
<p>&emsp;&emsp;看完<code>push</code>方法，接着看下<code>pop</code>方法，核心方法就是<code>releaseUntil</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);</span><br><span class="line">    stop = (id *)token;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对自动释放池内的对象调用release方法，直到遇到POOL_BOUNDARY</span></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放自动释放池</span></span><br><span class="line">    page-&gt;kill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着看<code>releaseUntil</code>方法，遍历池子，在找到<code>POOL_BOUNDARY</code>之前的对象，都调用<code>release</code>方法进行释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">                </span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">        	<span class="comment">// 之前说过，next指向下一个可存放自动释放对象的地址，所以往前就是已经存放过的那些自动释放对象了</span></span><br><span class="line">            id obj = *--page-&gt;next;</span><br><span class="line">            </span><br><span class="line">        	··· ···</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">                objc_release(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setHotPage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;总结，最后调用<code>pop</code>方法的时候，会把这个<code>POOL_BOUNDARY</code>所在地址作为参数传进去。然后从整个链表中所存放的最后一个autorelease对象的地址开始，依次往前调用对象的<code>release</code>方法，直到遇到前面传进来的<code>POOL_BOUNDARY</code>所在地址。</p>
<p>&emsp;&emsp;如果是嵌套<code>autorelease</code>，因为没遇到一次<code>@autorelease{}</code>都会加入一个<code>POOL_BOUNDARY</code>，所以pop的时候，遇到<code>POOL_BOUNDARY</code>就停止了。所以对于对象来说，在最里面嵌套里的对象最先被释放掉。</p>
<p>&emsp;&emsp;我们举个例子，会调用到私有函数<code>_objc_autoreleasePoolPrint</code>来帮助我们完成这个例子，然后我们需要将工程配置成MRC。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_autoreleasePoolPrint();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *a1 = [[Animal new] autorelease];</span><br><span class="line">        Animal *a2 = [[Animal new] autorelease];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            Animal *a3 = [[Animal new] autorelease];</span><br><span class="line">            _objc_autoreleasePoolPrint(); <span class="comment">// 打印自动释放池</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第二个释放池结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个释放池结束"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">objc[<span class="number">53031</span>]: <span class="meta">##############</span></span><br><span class="line">objc[<span class="number">53031</span>]: AUTORELEASE POOLS <span class="keyword">for</span> thread <span class="number">0x112b03380</span></span><br><span class="line">objc[<span class="number">53031</span>]: <span class="number">5</span> releases pending.</span><br><span class="line">objc[<span class="number">53031</span>]: [<span class="number">0x7fdff9002000</span>]  ................  PAGE  (hot) (cold)</span><br><span class="line">objc[<span class="number">53031</span>]: [<span class="number">0x7fdff9002038</span>]  <span class="meta">################  POOL 0x7fdff9002038 // 第一个AutoReleasePool的POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">53031</span>]: [<span class="number">0x7fdff9002040</span>]    <span class="number">0x60c00001dca0</span>  Animal</span><br><span class="line">objc[<span class="number">53031</span>]: [<span class="number">0x7fdff9002048</span>]    <span class="number">0x60c00001dc90</span>  Animal</span><br><span class="line">objc[<span class="number">53031</span>]: [<span class="number">0x7fdff9002050</span>]  <span class="meta">################  POOL 0x7fdff9002050 // 第二个AutoReleasePool的POOL_BOUNDARY</span></span><br><span class="line">objc[<span class="number">53031</span>]: [<span class="number">0x7fdff9002058</span>]    <span class="number">0x60c00001dc80</span>  Animal</span><br><span class="line">objc[<span class="number">53031</span>]: <span class="meta">##############</span></span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-20</span> <span class="number">19</span>:<span class="number">49</span>:<span class="number">15.576802</span>+<span class="number">0800</span> testData[<span class="number">53031</span>:<span class="number">3013783</span>] -[Animal dealloc] <span class="comment">// 第二个AutoReleasePool内的对象被释放</span></span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-20</span> <span class="number">19</span>:<span class="number">49</span>:<span class="number">15.577441</span>+<span class="number">0800</span> testData[<span class="number">53031</span>:<span class="number">3013783</span>] 第二个释放池结束</span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-20</span> <span class="number">19</span>:<span class="number">49</span>:<span class="number">15.577533</span>+<span class="number">0800</span> testData[<span class="number">53031</span>:<span class="number">3013783</span>] -[Animal dealloc] <span class="comment">// 第一个AutoReleasePool内的对象被释放</span></span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-20</span> <span class="number">19</span>:<span class="number">49</span>:<span class="number">15.577645</span>+<span class="number">0800</span> testData[<span class="number">53031</span>:<span class="number">3013783</span>] -[Animal dealloc]</span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-20</span> <span class="number">19</span>:<span class="number">49</span>:<span class="number">15.577768</span>+<span class="number">0800</span> testData[<span class="number">53031</span>:<span class="number">3013783</span>] 第一个释放池结束</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于释放时机，在<code>@autorelease{}</code>是出了大括号就会进行释放。</p>
<p>&emsp;&emsp;那么，我们知道主线程中默认会自动开启一个RunLoop，所以在这种情况下，如果只是调用<code>autorelease</code>方法，释放时机是根据RunLoop的，比如像这样的情况。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Animal *a1 = [[Animal new] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在主线程中，RunLoop注册了2个Observer，第一个，监听kCFRunLoopEntry，调用objc_autoreleasePoolPush()；第二个，监听了kCFRunLoopBeforeWaiting和kCFRunLoopBeforeExit，前者会调用objc_autoreleasePoolPop()和objc_autoreleasePoolPush()，后者会调用objc_autoreleasePoolPop()。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/24/深入分析Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/深入分析Runloop/" itemprop="url">深入分析Runloop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T15:24:39+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;一般写的程序都是像下面这样的，代码一行行执行，到return的时候代码都已经执行完毕，程序退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 代码段 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但实际的应用中，我们的软件不可能像这样线性的执行，执行完我们的软件就退出，所以就需要一种技术，让我们的软件始终保持运行状态。在iOS系统中，这项技术就是Runloop。</p>
<h1 id="0x01-主要的结构信息"><a href="#0x01-主要的结构信息" class="headerlink" title="0x01 主要的结构信息"></a>0x01 主要的结构信息</h1><h3 id="1-CFRunloop"><a href="#1-CFRunloop" class="headerlink" title="1. CFRunloop"></a>1. CFRunloop</h3><p>&emsp;&emsp;Runloop都会对应一个线程。而且Runloop可以有多种模式，但是当前使用的只能是一种模式。我们的CFRunloop结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;			<span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">    __CFPort _wakeUpPort;			<span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;  <span class="comment">// 对应的线程</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes; <span class="comment">// 保存的commonMode</span></span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode; <span class="comment">// 当前模式</span></span><br><span class="line">    CFMutableSetRef _modes; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-CFRunLoopMode"><a href="#2-CFRunLoopMode" class="headerlink" title="2. CFRunLoopMode"></a>2. CFRunLoopMode</h3><p>&emsp;&emsp;Mode管理着各种事件，我们的source0、source1、observer、timer都归mode管理。每个模式下又包含多个source0，source1，observer和timer。不同mode下的source0、source1、observer、timer都是隔离开的。</p>
<p>&emsp;&emsp;如果Mode里面没有source0，source1，observer和timer，Runloop会立马退出。</p>
<p>&emsp;&emsp;模式的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;	<span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 需要处理的几种事件</span></span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    </span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap; <span class="comment">// mach_port_t对应的CFRunLoopSourceRef</span></span><br><span class="line">    __CFPortSet _portSet; <span class="comment">// 所有要监听的mach_port_t</span></span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-CFRunLoopSource"><a href="#3-CFRunLoopSource" class="headerlink" title="3. CFRunLoopSource"></a>3. CFRunLoopSource</h3><p>&emsp;&emsp;source分为source0和source1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">uint32_t</span> _bits;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">	CFRunLoopSourceContext version0;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">        CFRunLoopSourceContext1 version1;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;source0一般都是应用的内部事件，比如触摸事件、CFSocket等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CFIndex	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    CFHashCode	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*schedule)(<span class="keyword">void</span> *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line">    <span class="keyword">void</span>	(*cancel)(<span class="keyword">void</span> *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info);</span><br><span class="line">&#125; CFRunLoopSourceContext;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;source1一般与mach_port通信，所以接收的是内核态的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CFIndex	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    Boolean	(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    CFHashCode	(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</span></span><br><span class="line">    <span class="keyword">mach_port_t</span>	(*getPort)(<span class="keyword">void</span> *info); <span class="comment">// 相比source0多了mach_port_t，即端口，用于线程之间通信</span></span><br><span class="line">    <span class="keyword">void</span> *	(*perform)(<span class="keyword">void</span> *msg, CFIndex size, CFAllocatorRef allocator, <span class="keyword">void</span> *info);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">void</span> *	(*getPort)(<span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*perform)(<span class="keyword">void</span> *info);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; CFRunLoopSourceContext1;</span><br></pre></td></tr></table></figure>
<h3 id="4-CFRunLoopObserver"><a href="#4-CFRunLoopObserver" class="headerlink" title="4. CFRunLoopObserver"></a>4. CFRunLoopObserver</h3><p>&emsp;&emsp;观察runloop的各种状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;		<span class="comment">/* immutable */</span></span><br><span class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopObserverCallBack _callout;	<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopObserverContext _context;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可被观察的状态有如下几种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), <span class="comment">// 进入runloop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入睡眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), <span class="comment">// 唤醒后</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>), <span class="comment">// 退出runloop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-CFRunLoopTimer"><a href="#5-CFRunLoopTimer" class="headerlink" title="5. CFRunLoopTimer"></a>5. CFRunLoopTimer</h3><p>&emsp;&emsp;可以在设定的时间到达后触发回调。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">uint16_t</span> _bits;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;		<span class="comment">/* immutable */</span></span><br><span class="line">    CFTimeInterval _tolerance;          <span class="comment">/* mutable */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _fireTSR;			<span class="comment">/* TSR units */</span></span><br><span class="line">    CFIndex _order;			<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopTimerCallBack _callout;	<span class="comment">/* immutable */</span></span><br><span class="line">    CFRunLoopTimerContext _context;	<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-获取线程"><a href="#0x02-获取线程" class="headerlink" title="0x02 获取线程"></a>0x02 获取线程</h1><h3 id="1-CFRunLoopGetMain"><a href="#1-CFRunLoopGetMain" class="headerlink" title="1. CFRunLoopGetMain"></a>1. CFRunLoopGetMain</h3><p>&emsp;&emsp;内部调用了<code>_CFRunLoopGet0</code>函数，传入的参数是主线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-CFRunLoopGetCurrent"><a href="#2-CFRunLoopGetCurrent" class="headerlink" title="2. CFRunLoopGetCurrent"></a>2. CFRunLoopGetCurrent</h3><p>&emsp;&emsp;跟<code>CFRunLoopGetMain</code>函数一样，调用的同样是<code>_CFRunLoopGet0</code>函数，只是参数不同，这里的入参是当前所在线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-CFRunLoopGet0"><a href="#3-CFRunLoopGet0" class="headerlink" title="3. CFRunLoopGet0"></a>3. CFRunLoopGet0</h3><p>&emsp;&emsp;既然<code>CFRunLoopGetMain</code>和<code>CFRunLoopGetCurrent</code>都调用了<code>_CFRunLoopGet0</code>函数，我们看下这个函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">// 如果线程为空，默认视作主线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">		t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// __CFRunLoops是个CFMutableDictionaryRef类型的全局变量，用来保存RunLoop。这里首先判断有没有这个全局变量，如果没有就新创建一个这个全局变量，并同时创建一个主线程对应的runloop。</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">       <span class="comment">// 创建一个主线程对应的runloop。</span></span><br><span class="line">	CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        <span class="comment">// 保存主线程</span></span><br><span class="line">	CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        <span class="comment">// 交换dict和__CFRunLoops，也就是这里开始__CFRunLoops就是刚刚创建的那个全局变量</span></span><br><span class="line">	<span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">	    CFRelease(dict);</span><br><span class="line">	&#125;</span><br><span class="line">	CFRelease(mainLoop);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据线程取其对应的runloop</span></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// 如果这个线程没有对应的runloop，就新建立一个runloop对象	</span></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">		CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        <span class="comment">// 二次确认，是否的确没有该线程对应的runloop</span></span><br><span class="line">		loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">		<span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">            <span class="comment">// 如果的确没有对应的runloop，就保存进全局变量中</span></span><br><span class="line">	    	CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">	    	loop = newLoop;</span><br><span class="line">		&#125;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">		CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            <span class="comment">// 注册一个回调，当线程销毁时一同销毁对应的runloop</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;获取线程流程总结如下：</p>
<ul>
<li>有个全局变量保存着各个线程与各个runloop对象的关系，该变量初始化的时候会同时创建一个主线程对应的runloop对象。</li>
<li>子线程的runloop默认是获取的时候才开始创建。所以多线程环境中，只有主线程的runloop是一开始就创建出来的，其他线程被创建的时候并不会一起创建一个runloop对象。</li>
<li>runloop对象的生命周期和线程的生命周期同步。</li>
</ul>
<h1 id="0x03-创建RunLoop"><a href="#0x03-创建RunLoop" class="headerlink" title="0x03 创建RunLoop"></a>0x03 创建RunLoop</h1><p>&emsp;&emsp;上面我们的RunLoop是在获取的时候被创建的，创建源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> CFRunLoopRef __CFRunLoopCreate(<span class="keyword">pthread_t</span> t) &#123;</span><br><span class="line">    CFRunLoopRef loop = <span class="literal">NULL</span>;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = <span class="keyword">sizeof</span>(struct __CFRunLoop) - <span class="keyword">sizeof</span>(CFRuntimeBase);</span><br><span class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, CFRunLoopGetTypeID(), size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == loop) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="keyword">void</span>)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</span><br><span class="line">    <span class="keyword">if</span> (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_currentMode = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_blocks_tail = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_counterpart = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_pthread = t;</span><br><span class="line">    loop-&gt;_winthread = <span class="number">0</span>;</span><br><span class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> <span class="title">srlm</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;srlm, <span class="number">0</span>, <span class="keyword">sizeof</span>(srlm));</span><br><span class="line">    _CFRuntimeSetInstanceTypeIDAndIsa(&amp;srlm, __kCFRunLoopModeTypeID);</span><br><span class="line">    srlm._name = modeName;</span><br><span class="line">    rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">		__CFRunLoopModeLock(rlm);</span><br><span class="line">	<span class="keyword">return</span> rlm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!create) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopModeTypeID, <span class="keyword">sizeof</span>(struct __CFRunLoopMode) - <span class="keyword">sizeof</span>(CFRuntimeBase), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rlm) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLockInit(&amp;rlm-&gt;_lock);</span><br><span class="line">    rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);</span><br><span class="line">    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">    rlm-&gt;_portToV1SourceMap = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_sources0 = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_sources1 = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_observers = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_timers = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_observerMask = <span class="number">0</span>;</span><br><span class="line">    rlm-&gt;_portSet = __CFPortSetAllocate();</span><br><span class="line">    rlm-&gt;_timerSoftDeadline = UINT64_MAX;</span><br><span class="line">    rlm-&gt;_timerHardDeadline = UINT64_MAX;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">kern_return_t</span> ret = KERN_SUCCESS;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    rlm-&gt;_timerFired = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 新建一个runloop的队列，用来处理timer相关事件</span></span><br><span class="line">    rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(<span class="string">"Run Loop Mode Queue"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">mach_port_t</span> queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">    <span class="keyword">if</span> (queuePort == MACH_PORT_NULL) CRASH(<span class="string">"*** Unable to create run loop mode queue port. (%d) ***"</span>, <span class="number">-1</span>);</span><br><span class="line">    rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, rlm-&gt;_queue);</span><br><span class="line">    </span><br><span class="line">    __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);</span><br><span class="line">    dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^&#123;</span><br><span class="line">        *timerFiredPointer = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.</span></span><br><span class="line">    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, <span class="number">321</span>);</span><br><span class="line">    dispatch_resume(rlm-&gt;_timerSource);</span><br><span class="line">    </span><br><span class="line">    ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS != ret) CRASH(<span class="string">"*** Unable to insert timer port into port set. (%d) ***"</span>, ret);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    rlm-&gt;_timerPort = mk_timer_create();</span><br><span class="line">    ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS != ret) CRASH(<span class="string">"*** Unable to insert timer port into port set. (%d) ***"</span>, ret);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS != ret) CRASH(<span class="string">"*** Unable to insert wake up port into port set. (%d) ***"</span>, ret);</span><br><span class="line"></span><br><span class="line">    CFSetAddValue(rl-&gt;_modes, rlm);</span><br><span class="line">    CFRelease(rlm);</span><br><span class="line">    __CFRunLoopModeLock(rlm);	<span class="comment">/* return mode locked */</span></span><br><span class="line">    <span class="keyword">return</span> rlm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;构建一个mode的时候会同时创建一个GCD Queue，用来处理时间相关的任务。</p>
<h1 id="0x04-运行RunLoop"><a href="#0x04-运行RunLoop" class="headerlink" title="0x04 运行RunLoop"></a>0x04 运行RunLoop</h1><p>&emsp;&emsp;runloop内部其实就是一个do…while()循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;	<span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;调用的是<code>CFRunLoopRunSpecific</code>函数，用<code>kCFRunLoopDefaultMode</code>模式进行启动</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 根据模式名字，找到对应模式</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 如果没有找到这个模式或者这个模式里是空的(source0\source1\timers都为空)，就退出runloop循环</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) 	 &#123;</span><br><span class="line">		Boolean did = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">		__CFRunLoopUnlock(rl);</span><br><span class="line">		<span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    <span class="comment">// 取出runloop当前的模式</span></span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    <span class="comment">// 将runloop的模式改为传进来的默认模式</span></span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="keyword">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 通知observers要进入runloop了</span></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    <span class="comment">// 主要工作内容还是在__CFRunLoopRun</span></span><br><span class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    <span class="comment">// 通知observers要退出runloop了</span></span><br><span class="line">	<span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">	rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看下最重要的<code>__CFRunLoopRun</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    <span class="comment">// 获取当前mach的时间，纳秒级精度</span></span><br><span class="line">    <span class="keyword">uint64_t</span> startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果runloop暂停或者mode暂停，那么就退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">		<span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">		rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是主线程并且是默认mode，将gcd获取主线程的端口赋值给dispatchPort，以便和主线程通信</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="comment">// 将gcd中根队列的端口赋值给modeQueuePort</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_queue) &#123;</span><br><span class="line">        <span class="comment">// cgd根队列管理着所有的子队列，获取根队列的端口，方便与其通信，来处理后面传递进队列的任务</span></span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        <span class="keyword">if</span> (!modeQueuePort) &#123;</span><br><span class="line">            CRASH(<span class="string">"Unable to get port for run loop mode queue (%d)"</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看入参的超时时间，如果是在可取范围内的，就设置一个定时器，如果时间到了就跳到__CFRunLoopTimeout处理超时后要做的事。</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">timeout_context</span> *<span class="title">timeout_context</span> = (<span class="title">struct</span> __<span class="title">timeout_context</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">timeout_context</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        seconds = <span class="number">0.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0U</span>LL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</span><br><span class="line">	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">queue</span>);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">	timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">	dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets ownership of context</span></span><br><span class="line">	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        <span class="keyword">uint64_t</span> ns_at = (<span class="keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="number">1000000000U</span>LL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000U</span>LL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">		......</span><br><span class="line">        <span class="keyword">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>]; <span class="comment">// 消息缓存池</span></span><br><span class="line">        <span class="keyword">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line">        ......</span><br><span class="line">		__CFPortSet waitSet = rlm-&gt;_portSet; <span class="comment">// 需要监听的port</span></span><br><span class="line">	</span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">		<span class="comment">// 通知observers即将处理timer事件</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">// 通知observers即将处理source0事件</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">		<span class="comment">// 执行当前runloop链表内的每个block任务,即CFRunLoopPerformBlock加入的block任务</span></span><br><span class="line">		__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">		<span class="comment">// 处理source0事件</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">// 如果有再次处理block任务</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0U</span>LL == timeout_context-&gt;termTSR);</span><br><span class="line">		<span class="comment">// 如果有source1，处理source1事件</span></span><br><span class="line">        <span class="comment">// 循环中第一次的循环didDispatchPortLastTime为YES，所以这个分支在第一次循环的时候不会进入</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">// 通知observers即将休眠</span></span><br><span class="line">		<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        <span class="comment">// 设置为休眠状态</span></span><br><span class="line">		__CFRunLoopSetSleeping(rl);</span><br><span class="line"></span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">		__CFRunLoopModeUnlock(rlm);</span><br><span class="line">		__CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? <span class="number">0.0</span> : CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 睡眠中，有个循环接收端口消息</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 内部调用mach_msg函数接收消息，以便接收到消息立刻唤醒runloop，如果没有消息，就让线程休眠</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">            <span class="comment">// 如果收到来自runloop queue队列的事件，里面一般都是timer相关事件</span></span><br><span class="line">            <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">                <span class="comment">// 按个取出任务执行</span></span><br><span class="line">                <span class="keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_timerFired) &#123;</span><br><span class="line">      </span><br><span class="line">                    rlm-&gt;_timerFired = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Go ahead and leave the inner loop.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line"></span><br><span class="line">        rl-&gt;_sleepTime += (poll ? <span class="number">0.0</span> : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line"></span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">		__CFRunLoopUnsetSleeping(rl);</span><br><span class="line">       <span class="comment">// 通知observers即将醒来</span></span><br><span class="line">		<span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理收到的消息</span></span><br><span class="line">handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        <span class="comment">// 被timer相关唤醒，处理timer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123; <span class="comment">// 如果是主线程任务，处理主线程任务。</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 内部是_dispatch_main_queue_callback_4CF</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">voucher_t</span> previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (<span class="keyword">void</span> *)voucherCopy, os_release);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="comment">// 有source1事件处理，就处理source1事件</span></span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">				<span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">				sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">				<span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">		    		(<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">		    		CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">				&#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Restore the previous voucher</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 处理加入到loop的block</span></span><br><span class="line">		__CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">	    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123; <span class="comment">// 如果runloop被停止</span></span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123; <span class="comment">// 如果mode被停止</span></span><br><span class="line">	    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">	    retVal = kCFRunLoopRunStopped;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; <span class="comment">// 如果模式里是空的</span></span><br><span class="line">	    retVal = kCFRunLoopRunFinished;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">free</span>(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;启动runloop主要流程</p>
<ol>
<li>通知observers即将进入runloop</li>
<li>通知observers即将处理timers事件</li>
<li>通知observers即将处理source事件<ul>
<li>处理blocks</li>
<li>处理source0</li>
</ul>
</li>
<li>通知observers即将休眠(内部有个循环接收消息)</li>
<li>通知observers结束休眠，并回到第2步</li>
<li>处理消息<ul>
<li>处理timer事件</li>
<li>处理主线程任务</li>
<li>处理blocks</li>
<li>回到第2步</li>
</ul>
</li>
<li>通知observers即将退出runloop</li>
</ol>
<h1 id="0x05-使用"><a href="#0x05-使用" class="headerlink" title="0x05 使用"></a>0x05 使用</h1><h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>&emsp;&emsp;在RunLoop中，关于定时器经常遇到的问题就是滑动的时候定时器就不走动了。解决方案也是很熟悉，把timer加入<code>NSRunLoopCommonModes</code> 或者同时加入到<code>NSDefaultRunLoopMode</code> 和<code>UITrackingRunLoopMode</code> 。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">或者</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中<code>NSRunLoopCommonModes</code>其实是一个mode集合，里面包括所有的被标记为<code>common</code>的mode，比如<code>NSDefaultRunLoopMode</code>、<code>UITrackingRunLoopMode</code>。</p>
<p>&emsp;&emsp;RunLoop同一时刻下只能跑在一个mode上，所以Timer不走动就是因为如果只加入到一种mode下，切换到别的mode，比如滑动页面就会切换到<code>UITrackingRunLoopMode</code>，Timer就因为在该模式下没有注册，所以不会响应Timer事件。</p>
<h3 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h3><p>&emsp;&emsp;比如子线程内请求一个网络数据，但是等待完成需要等一会，这就会导致得到数据的时候子线程就被回收掉了。要想子线程一直存在，我们可以利用RunLoop，在子线程写下如下代码就可以使得线程保活。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">[runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[runLoop run];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是这样又会有一个问题，我们看下对于<code>run</code>方法的描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Puts the receiver into a permanent loop, during which time it processes data from all attached input sources.</span><br><span class="line">If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</span><br><span class="line">Manually removing all known input sources and timers from the run loop is not a guarantee that the run loop will exit. macOS can install and remove additional input sources as needed to process requests targeted at the receiver’s thread. Those sources could therefore prevent the run loop from exiting.</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;简单来说就是<code>run</code>方法内部是个无限循环，无限调用<code>runMode:beforeDate:</code>方法，并且即时删除mode下所有的source和timer也不能停止。如果创建多个线程，并都通过run启用RunLoop，就会造成内存泄露的问题，如果想要其变得可控，官方也给了建议，自己手动写了while，并且通过一个全局变量来控制什么时候结束这个循环。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> shouldKeepRunning = <span class="literal">YES</span>; <span class="comment">// global</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *theRL = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="keyword">while</span> (shouldKeepRunning &amp;&amp; [theRL runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]]);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;停止RunLoop的伪代码可以写成这样的</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">self</span>.shouldKeepRunning = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们总结一下启动RunLoop的几种方式</p>
<ul>
<li><p><code>run</code></p>
<blockquote>
<p>无限循环，终止不掉</p>
</blockquote>
</li>
<li><p><code>runUntilDate:</code></p>
<blockquote>
<p>内部同样重复调用<code>runMode:beforeDate:</code>，但是时间到了就结束，不再调用；或者通过<code>CFRunLoopStop</code>结束</p>
</blockquote>
</li>
<li><p><code>runMode:beforeDate:</code></p>
<blockquote>
<p>只调用一次；或者通过<code>CFRunLoopStop</code>结束</p>
</blockquote>
</li>
</ul>
<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>&emsp;&emsp;我们知道<code>[NSRunLoop currentRunLoop]</code>用来获取当前RunLoop，如果没有就会创建一个RunLoop，我们看下其内部汇编代码，发现会自动开启AutoreleasePool。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Foundation</span>`+[NSRunLoop(NSRunLoop) currentRunLoop]:</span><br><span class="line">    <span class="number">0x1853c7ea4</span> &lt;+<span class="number">0</span>&gt;:  stp    x20, x19, [<span class="built_in">sp</span>, #-<span class="number">0x20</span>]!</span><br><span class="line">    <span class="number">0x1853c7ea8</span> &lt;+<span class="number">4</span>&gt;:  stp    x29, x30, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="number">0x1853c7eac</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">add </span>   x29, <span class="built_in">sp</span>, <span class="number">#0x10</span>            <span class="comment">; =0x10 </span></span><br><span class="line">    <span class="number">0x1853c7eb0</span> &lt;+<span class="number">12</span>&gt;: <span class="keyword">mov </span>   x0, <span class="number">#0x0</span></span><br><span class="line">    <span class="number">0x1853c7eb4</span> &lt;+<span class="number">16</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x185416114</span>               <span class="comment">; NSPushAutoreleasePool</span></span><br><span class="line">    <span class="number">0x1853c7eb8</span> &lt;+<span class="number">20</span>&gt;: <span class="keyword">mov </span>   x19, x0</span><br><span class="line">    <span class="number">0x1853c7ebc</span> &lt;+<span class="number">24</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x18495545c</span>               <span class="comment">; CFRunLoopGetCurrent</span></span><br><span class="line">    <span class="number">0x1853c7ec0</span> &lt;+<span class="number">28</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x184958a74</span>               <span class="comment">; _CFRunLoopGet2</span></span><br><span class="line">    <span class="number">0x1853c7ec4</span> &lt;+<span class="number">32</span>&gt;: <span class="keyword">mov </span>   x20, x0</span><br><span class="line">    <span class="number">0x1853c7ec8</span> &lt;+<span class="number">36</span>&gt;: <span class="keyword">mov </span>   x0, x19</span><br><span class="line">    <span class="number">0x1853c7ecc</span> &lt;+<span class="number">40</span>&gt;: <span class="keyword">bl </span>    <span class="number">0x185416118</span>               <span class="comment">; NSPopAutoreleasePool</span></span><br><span class="line">    <span class="number">0x1853c7ed0</span> &lt;+<span class="number">44</span>&gt;: <span class="keyword">mov </span>   x0, x20</span><br><span class="line">    <span class="number">0x1853c7ed4</span> &lt;+<span class="number">48</span>&gt;: ldp    x29, x30, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="number">0x1853c7ed8</span> &lt;+<span class="number">52</span>&gt;: ldp    x20, x19, [<span class="built_in">sp</span>], <span class="number">#0x20</span></span><br><span class="line">    <span class="number">0x1853c7edc</span> &lt;+<span class="number">56</span>&gt;: ret</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/21/深入分析Runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/21/深入分析Runtime/" itemprop="url">深入分析Runtime</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-21T08:46:24+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp; &emsp; Objective-C作为一门动态语言，其核心就是Runtime。本篇将从源码着手，分析Runtime的几个关键地方，使得我们可以更好的理解Runtime的运行机制。我们所有的类都继承于NSObject，所以我们先把结构列出来</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个OC对象都有一个isa成员</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isa又是一个obc_class的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             </span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc_class又继承objc_object</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp; &emsp; 所以NSObject的结构可以大致看成下面这样的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    isa_t isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             </span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-isa"><a href="#0x01-isa" class="headerlink" title="0x01 isa"></a>0x01 isa</h1><p>&emsp;&emsp;在ARM64之前，isa是直接指向类对象或元类对象的地址，但是在ARM64的时候，isa包含了更多的信息。isa_t是一个共用体(union)，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits; <span class="comment">// unsigned long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;作为共用体，所有成员共享一块区域。uintptr_t表示的是unsigned long，大小是8个字节，其作为共用体里最大的成员，所以这个共用体也占据8个字节的大小，可能这里有些人会觉得疑惑，明明struct里有9个uintptr_t成员，怎么会共用体才8个字节。要解释这个问题，我们需要知道位域这个概念。</p>
<p>&emsp;&emsp;位域，是指信息在存储时，并不需要占用一个完整的字节，我们可以指定其大小。这样做的目的可以使得我们可以节省空间。举个例子，假设我们养一个宠物，给它设定三个属性，分别为吃饭了没，喝水了没，洗澡了没。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> eat;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> drink;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> sleep;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们知道，BOOL占用一个字节，三个属性占用了三个字节。对于这三个属性的值非真即假，用三个字节我觉得很浪费，那么如何使用位域更节省的使用空间呢？对于一个属性非真即假，我们用二进制就可以来满足，1个字节又有8位，所以三个属性的结果只需要3位即可满足。比如睡觉在最后一位，喝水倒数第二位，睡觉倒数第三位，假如满足吃饭的条件，值就是0b0000 0001。如果满足吃饭也满足喝水，值就是0b0000 0011，以此类推。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEat:(<span class="built_in">BOOL</span>)eat;</span><br><span class="line">- (<span class="keyword">void</span>)setDrink:(<span class="built_in">BOOL</span>)drink;</span><br><span class="line">- (<span class="keyword">void</span>)setSleep:(<span class="built_in">BOOL</span>)sleep;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">BOOL</span>)eat;</span><br><span class="line">-(<span class="built_in">BOOL</span>)drink;</span><br><span class="line">-(<span class="built_in">BOOL</span>)sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> bits; <span class="comment">// 共用体占据1个字节</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> eat : <span class="number">1</span>; <span class="comment">// 指定占据1位</span></span><br><span class="line">            <span class="keyword">bool</span> drink : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> sleep : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;_action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEat:(<span class="built_in">BOOL</span>)eat &#123;</span><br><span class="line">    <span class="keyword">if</span> (eat) &#123;</span><br><span class="line">        _action.bits |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>); <span class="comment">// 1 &lt;&lt; 0即0000 0001;或上1将对应位设置为1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _action.bits &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>); <span class="comment">// ~(1 &lt;&lt; 0)即1111 1110;与上，将对应为设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDrink:(<span class="built_in">BOOL</span>)drink &#123;</span><br><span class="line">    <span class="keyword">if</span> (drink) &#123;</span><br><span class="line">        _action.bits |= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>); <span class="comment">// 1 &lt;&lt; 1，左移1位，即0000 0010;或上1将对应位设置为1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _action.bits &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">1</span>); <span class="comment">// ~(1 &lt;&lt; 1)即1111 1101;与上，将对应为设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSleep:(<span class="built_in">BOOL</span>)sleep &#123;</span><br><span class="line">    <span class="keyword">if</span> (sleep) &#123;</span><br><span class="line">        _action.bits |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">// 1 &lt;&lt; 2即0000 0100;或上1将对应位设置为1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _action.bits &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">// ~(1 &lt;&lt; 2)即1111 1011;与上，将对应为设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)eat &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(_action.bits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)); <span class="comment">// 与上,来进行取值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)drink &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(_action.bits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)sleep &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(_action.bits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    Animal *a = [Animal new];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"宠物%@，%@，%@"</span>, [a eat] ? <span class="string">@"有吃饭"</span>:<span class="string">@"没有吃饭"</span>, [a drink] ? <span class="string">@"有喝水"</span>:<span class="string">@"没有喝水"</span>, [a sleep] ? <span class="string">@"有睡觉"</span>:<span class="string">@"没有睡觉"</span>]);</span><br><span class="line">    [a setEat:<span class="literal">YES</span>];</span><br><span class="line">    [a setDrink:<span class="literal">NO</span>];</span><br><span class="line">    [a setSleep:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"宠物%@，%@，%@"</span>, [a eat] ? <span class="string">@"有吃饭"</span>:<span class="string">@"没有吃饭"</span>, [a drink] ? <span class="string">@"有喝水"</span>:<span class="string">@"没有喝水"</span>, [a sleep] ? <span class="string">@"有睡觉"</span>:<span class="string">@"没有睡觉"</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">24.118022</span>+<span class="number">0800</span> testData[<span class="number">67088</span>:<span class="number">104712921</span>] 宠物没有吃饭，没有喝水，没有睡觉</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-21</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">24.119529</span>+<span class="number">0800</span> testData[<span class="number">67088</span>:<span class="number">104712921</span>] 宠物有吃饭，没有喝水，有睡觉</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;回到isa_t共用体，我们详细解释下里面每一位的意思：</p>
<ul>
<li><p>nonpointer，占据1位</p>
<blockquote>
<p>0 : 直接执行类地址或者元类地址</p>
<p>1：包含更多信息</p>
</blockquote>
</li>
<li><p>has_assoc，占据1位</p>
<blockquote>
<p>0：没有关联对象</p>
<p>1：有关联对象</p>
</blockquote>
</li>
<li><p>has_cxx_dtor，占据1位</p>
<blockquote>
<p>0：没有C++类的析构函数</p>
<p>1：有C++类的析构函数</p>
</blockquote>
</li>
<li><p>shiftcls， 占据33位</p>
<blockquote>
<p>类地址或元类地址，具体值的算法= isa的地址 &amp; 0x0000000ffffffff8</p>
</blockquote>
</li>
<li><p>magic，占据1位</p>
<blockquote>
<p>0：对象没有完成初始化</p>
<p>1：对象完成初始化</p>
</blockquote>
</li>
<li><p>weakly_referenced，占位1位</p>
<blockquote>
<p>0：没有被弱引用指向</p>
<p>1：有被弱引用指向</p>
</blockquote>
</li>
<li><p>deallocating，占据1位</p>
<blockquote>
<p>0：没有正在被释放</p>
<p>1：正在被释放</p>
</blockquote>
</li>
<li><p>has_sidetable_rc，占据1位</p>
<blockquote>
<p>0：引用计数器可以被保存在isa里</p>
<p>1：引用计数器太大，不能保存在isa里</p>
</blockquote>
</li>
<li><p>extra_rc，占据19位</p>
<blockquote>
<p>存储引用计数 - 1的值</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;首先，证明在ARM64上isa已经不是直接指向类对象或元类对象，测试代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    Animal *a = [Animal new];</span><br><span class="line">    Class cls = object_getClass(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印a-&gt;isa的值</span></span><br><span class="line">(lldb) p/x a-&gt;isa</span><br><span class="line">(Class) $<span class="number">1</span> = <span class="number">0x000001a1025496d5</span></span><br><span class="line"><span class="comment">// 打印cls的值</span></span><br><span class="line">(lldb) p/x cls</span><br><span class="line">(Class) $<span class="number">0</span> = <span class="number">0x00000001025496d0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们发现的确isa的地址跟类地址的值是不一致的，要通过isa拿到真实的类地址需要与上0x0000000ffffffff8</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p/x <span class="number">0x000001a1025496d5</span> &amp; <span class="number">0x0000000ffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">2</span> = <span class="number">0x00000001025496d0</span> <span class="comment">// 即cls的地址值</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将0x0000000ffffffff8转换成二进制值</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p/t <span class="number">0x0000000ffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">3</span> = <span class="number">0</span>b0000000000000000000000000000111111111111111111111111111111111000</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;与上面说的shiftcls一致，即倒数第四位开始的33位。我们知道如果要取值，就是与1进行取与操作</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x000001a1025496d</span>  = <span class="number">0</span>b0000000000000000000000011010000100000010010101001001011011010101</span><br><span class="line"><span class="number">0x0000000ffffffff8</span> = <span class="number">0</span>b0000000000000000000000000000111111111111111111111111111111111000</span><br><span class="line">    	&amp;		   = <span class="number">0</span>b0000000000000000000000000000000100000010010101001001011011010000</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;接着，我们设置一下关联对象，证明has_assoc是否会变为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置前:<span class="number">0b0000000000000000000000011010000100000010010101001001011011010101</span>  <span class="comment">// 倒数第二位为0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Animal *a = [Animal <span class="keyword">new</span>];</span><br><span class="line">objc_setAssociatedObject(a, @selector(age), @<span class="number">100</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">设置后:<span class="number">0b0000000000000000000000011010000100000000010010011001011011101111</span> <span class="comment">// 倒数第二位为1</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其他位就不一一做实验了。</p>
<h1 id="0x02-方法查找流程"><a href="#0x02-方法查找流程" class="headerlink" title="0x02 方法查找流程"></a>0x02 方法查找流程</h1><p><img src="isa_super.png" alt="isa和superClass关系示意图"> </p>
<p>&emsp;&emsp;在之前的Category文章里，其实已经提到这个，所有的调用流程如上图所示。我们只需要记住，实例对象只保存成员变量的值，实例对象的方法(比如<code>- (void)eat;</code>)保存在其类对象的方法表里，以及协议信息和成员变量信息(名字，大小等)也是保存在类对象对应的协议表和成员变量表中。而类方法(比如<code>+ (void)eat</code>)，则保存在元类(meta-class)的的方法表中。</p>
<p>&emsp;&emsp;所以下文的表述中，如果说的是类的方法表，说明找的是实例方法；如果说的是元类的方法表，说明找的是类方法。</p>
<h1 id="0x03-objc-msgSend"><a href="#0x03-objc-msgSend" class="headerlink" title="0x03 objc_msgSend"></a>0x03 objc_msgSend</h1><p>&emsp;&emsp;objc_msgSend是通过汇编代码实现的，Objective-C中调用方法实际都是走的objc_msgSend函数，所以这个函数是会被十分频繁的调用，以汇编实现将提升效率。</p>
<p>&emsp;&emsp;我们首先写下测试代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal *a = [Animal new];</span><br><span class="line">[a eat];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;符号断点在eat方法上，看下objc_msgSend汇编代码，所有方法调用都会带两个参数，一个是self，即调用者，第二个是_cmd，即调用方法，分别保存在x0和x1寄存器里。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">libobjc.A.dylib</span>`objc_msgSend:</span><br><span class="line">	<span class="comment">; x0即调用者Animal对象，#0x0即nil，也就是Animal对象是不是为0</span></span><br><span class="line">-&gt;  <span class="number">0x183c5c900</span> &lt;+<span class="number">0</span>&gt;:   <span class="keyword">cmp </span>   x0, <span class="number">#0x0</span>   </span><br><span class="line">	<span class="comment">; 如果是nil，就跳转到0x183c5c96c地址处继续执行</span></span><br><span class="line">    <span class="number">0x183c5c904</span> &lt;+<span class="number">4</span>&gt;:   <span class="keyword">b.le </span>  <span class="number">0x183c5c96c</span>  </span><br><span class="line">    <span class="comment">; 相当于a-&gt;isa的地址保存到x13寄存器。x0表示Animal实例对象a的地址，[x0]表示a-&gt;isa的地址</span></span><br><span class="line">    <span class="number">0x183c5c908</span> &lt;+<span class="number">8</span>&gt;:   <span class="keyword">ldr </span>   x13, [x0]</span><br><span class="line">    <span class="comment">; 这个上面提过，isa地址 与上 #0xffffffff8得到类对象地址，并将类对象的地址保存到x16寄存器</span></span><br><span class="line">    <span class="number">0x183c5c90c</span> &lt;+<span class="number">12</span>&gt;:  <span class="keyword">and </span>   x16, x13, <span class="number">#0xffffffff8</span></span><br><span class="line">    <span class="comment">; 在类对象地址偏移16个字节的位置，读取16个字节，分别放进x10寄存器和x11寄存器，详细看下面注解①</span></span><br><span class="line">    <span class="number">0x183c5c910</span> &lt;+<span class="number">16</span>&gt;:  ldp    x10, x11, [x16, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="comment">; w11保存的是cache_t结构体的mask成员，也就是将_cmd的低32位与mask做与运算。目的是取出方法的在散列表中的位置，保存到x12寄存器的低32位</span></span><br><span class="line">    <span class="number">0x183c5c914</span> &lt;+<span class="number">20</span>&gt;:  <span class="keyword">and </span>   w12, w1, w11</span><br><span class="line">    <span class="comment">; x10保存着散列表的首地址，x12保存着方法的位置(假设为index)，lsl #4表示左移4位，相当于乘以16，而且散列表每个成员(bucket_t)也正好占用16个字节，所以方法的实际地址 = 首地址 + index * 16。结果保存到x12寄存器</span></span><br><span class="line">    <span class="number">0x183c5c918</span> &lt;+<span class="number">24</span>&gt;:  <span class="keyword">add </span>   x12, x10, x12, <span class="keyword">lsl </span><span class="number">#4</span></span><br><span class="line">    <span class="comment">;取出x12地址开始的16个字节，前8个字节保存到x9寄存器，后8个字节保存到x17寄存器。我们知道x12保存的是我们所调用的方法在散列表中的地址，其结构是bucket_t结构体，所以方法名key保存在x9寄存器，方法地址imp保存在x17寄存器。</span></span><br><span class="line">    <span class="number">0x183c5c91c</span> &lt;+<span class="number">28</span>&gt;:  ldp    x9, x17, [x12]</span><br><span class="line">    <span class="comment">; 比较_cmd名字和散列表中所找到的方法的名字是否一致</span></span><br><span class="line">    <span class="number">0x183c5c920</span> &lt;+<span class="number">32</span>&gt;:  <span class="keyword">cmp </span>   x9, x1</span><br><span class="line">    <span class="comment">; 如果不一致，就跳转到0x183c5c92c地址</span></span><br><span class="line">    <span class="number">0x183c5c924</span> &lt;+<span class="number">36</span>&gt;:  <span class="keyword">b.ne </span>  <span class="number">0x183c5c92c</span>               <span class="comment">; &lt;+44&gt;</span></span><br><span class="line">    <span class="comment">; 如果名字一致，就直接跳转到方法的实现地址。	</span></span><br><span class="line">    <span class="number">0x183c5c928</span> &lt;+<span class="number">40</span>&gt;:  <span class="keyword">br </span>    x17</span><br><span class="line">    <span class="comment">; 之前如果方法和找到的缓存方法的名字不一样，就来到了这里，如果x9是0，那就执行_objc_msgSend_uncached函数</span></span><br><span class="line">    <span class="number">0x183c5c92c</span> &lt;+<span class="number">44</span>&gt;:  <span class="keyword">cbz </span>   x9, <span class="number">0x183c5cc00</span>           <span class="comment">; _objc_msgSend_uncached</span></span><br><span class="line">    <span class="comment">; x10保存是散列表首地址，x12保存的是当前back_t成员的地址</span></span><br><span class="line">    <span class="number">0x183c5c930</span> &lt;+<span class="number">48</span>&gt;:  <span class="keyword">cmp </span>   x12, x10</span><br><span class="line">    <span class="comment">; 如果x12跟x10值一样，说明散列表已经遍历完了, 跳转到0x183c5c940</span></span><br><span class="line">    <span class="number">0x183c5c934</span> &lt;+<span class="number">52</span>&gt;:  <span class="keyword">b.eq </span>  <span class="number">0x183c5c940</span>               <span class="comment">; &lt;+64&gt;</span></span><br><span class="line">    <span class="comment">; 如果x12跟x10值不一致，说明没遍历结束，[x12, #-0x10]!往前移动16个字节，即来到前一个bucket_t成员。</span></span><br><span class="line">    <span class="number">0x183c5c938</span> &lt;+<span class="number">56</span>&gt;:  ldp    x9, x17, [x12, #-<span class="number">0x10</span>]!</span><br><span class="line">    <span class="comment">; 跳转到上面的cmp x9, x1，继续比较方法名字是否一致</span></span><br><span class="line">    <span class="number">0x183c5c93c</span> &lt;+<span class="number">60</span>&gt;:  <span class="keyword">b </span>     <span class="number">0x183c5c920</span>               <span class="comment">; &lt;+32&gt;</span></span><br><span class="line">    <span class="comment">; 散列表遍历完成后，会来到这里。w11是掩码mask，将掩码左移4位，即左移16个字节，我们知道掩码保存的是散列表的长度减1。x12此时是散列表首地址，两者相加再次保存进x12寄存器，也就是x12保存的就是散列表最后一个成员的地址。</span></span><br><span class="line">    <span class="number">0x183c5c940</span> &lt;+<span class="number">64</span>&gt;:  <span class="keyword">add </span>   x12, x12, w11, uxtw <span class="number">#4</span></span><br><span class="line">    <span class="comment">; 同&lt;+28&gt;</span></span><br><span class="line">    <span class="number">0x183c5c944</span> &lt;+<span class="number">68</span>&gt;:  ldp    x9, x17, [x12]</span><br><span class="line">    <span class="comment">; 比较名字</span></span><br><span class="line">    <span class="number">0x183c5c948</span> &lt;+<span class="number">72</span>&gt;:  <span class="keyword">cmp </span>   x9, x1</span><br><span class="line">    <span class="comment">; 不一致就执行_objc_msgSend_uncached</span></span><br><span class="line">    <span class="number">0x183c5c94c</span> &lt;+<span class="number">76</span>&gt;:  <span class="keyword">b.ne </span>  <span class="number">0x183c5c954</span>               <span class="comment">; &lt;+84&gt;</span></span><br><span class="line">    <span class="comment">; 一致就调用方法，接下来就跟前面差不多了，后面不做解释</span></span><br><span class="line">    <span class="number">0x183c5c950</span> &lt;+<span class="number">80</span>&gt;:  <span class="keyword">br </span>    x17</span><br><span class="line">    <span class="number">0x183c5c954</span> &lt;+<span class="number">84</span>&gt;:  <span class="keyword">cbz </span>   x9, <span class="number">0x183c5cc00</span>           <span class="comment">; _objc_msgSend_uncached</span></span><br><span class="line">    <span class="number">0x183c5c958</span> &lt;+<span class="number">88</span>&gt;:  <span class="keyword">cmp </span>   x12, x10</span><br><span class="line">    <span class="comment">; 如果又回到了表头，则跳转到0x183c5c968处</span></span><br><span class="line">    <span class="number">0x183c5c95c</span> &lt;+<span class="number">92</span>&gt;:  <span class="keyword">b.eq </span>  <span class="number">0x183c5c968</span>               <span class="comment">; &lt;+104&gt;</span></span><br><span class="line">    <span class="number">0x183c5c960</span> &lt;+<span class="number">96</span>&gt;:  ldp    x9, x17, [x12, #-<span class="number">0x10</span>]!</span><br><span class="line">    <span class="number">0x183c5c964</span> &lt;+<span class="number">100</span>&gt;: <span class="keyword">b </span>     <span class="number">0x183c5c948</span>               <span class="comment">; &lt;+72&gt;</span></span><br><span class="line">    <span class="comment">; 即执行_objc_msgSend_uncached函数</span></span><br><span class="line">    <span class="number">0x183c5c968</span> &lt;+<span class="number">104</span>&gt;: <span class="keyword">b </span>     <span class="number">0x183c5cc00</span>               <span class="comment">; _objc_msgSend_uncached</span></span><br><span class="line">    <span class="number">0x183c5c96c</span> &lt;+<span class="number">108</span>&gt;: <span class="keyword">b.eq </span>  <span class="number">0x183c5c9a4</span>               <span class="comment">; &lt;+164&gt;</span></span><br><span class="line">    <span class="number">0x183c5c970</span> &lt;+<span class="number">112</span>&gt;: <span class="keyword">mov </span>   x10, #-<span class="number">0x1000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c974</span> &lt;+<span class="number">116</span>&gt;: <span class="keyword">cmp </span>   x0, x10</span><br><span class="line">    <span class="number">0x183c5c978</span> &lt;+<span class="number">120</span>&gt;: <span class="keyword">b.hs </span>  <span class="number">0x183c5c990</span>               <span class="comment">; &lt;+144&gt;</span></span><br><span class="line">    <span class="number">0x183c5c97c</span> &lt;+<span class="number">124</span>&gt;: <span class="keyword">adrp </span>  x10, <span class="number">209389</span></span><br><span class="line">    <span class="number">0x183c5c980</span> &lt;+<span class="number">128</span>&gt;: <span class="keyword">add </span>   x10, x10, <span class="number">#0x270</span>          <span class="comment">; =0x270 </span></span><br><span class="line">    <span class="number">0x183c5c984</span> &lt;+<span class="number">132</span>&gt;: <span class="keyword">lsr </span>   x11, x0, <span class="number">#60</span></span><br><span class="line">    <span class="number">0x183c5c988</span> &lt;+<span class="number">136</span>&gt;: <span class="keyword">ldr </span>   x16, [x10, x11, <span class="keyword">lsl </span><span class="number">#3</span>]</span><br><span class="line">    <span class="number">0x183c5c98c</span> &lt;+<span class="number">140</span>&gt;: <span class="keyword">b </span>     <span class="number">0x183c5c910</span>               <span class="comment">; &lt;+16&gt;</span></span><br><span class="line">    <span class="number">0x183c5c990</span> &lt;+<span class="number">144</span>&gt;: <span class="keyword">adrp </span>  x10, <span class="number">209389</span></span><br><span class="line">    <span class="number">0x183c5c994</span> &lt;+<span class="number">148</span>&gt;: <span class="keyword">add </span>   x10, x10, <span class="number">#0x2f0</span>          <span class="comment">; =0x2f0 </span></span><br><span class="line">    <span class="number">0x183c5c998</span> &lt;+<span class="number">152</span>&gt;: <span class="keyword">ubfx </span>  x11, x0, <span class="number">#52</span>, <span class="number">#8</span></span><br><span class="line">    <span class="number">0x183c5c99c</span> &lt;+<span class="number">156</span>&gt;: <span class="keyword">ldr </span>   x16, [x10, x11, <span class="keyword">lsl </span><span class="number">#3</span>]</span><br><span class="line">    <span class="number">0x183c5c9a0</span> &lt;+<span class="number">160</span>&gt;: <span class="keyword">b </span>     <span class="number">0x183c5c910</span>               <span class="comment">; &lt;+16&gt;</span></span><br><span class="line">    <span class="number">0x183c5c9a4</span> &lt;+<span class="number">164</span>&gt;: <span class="keyword">mov </span>   x1, <span class="number">#0x0</span></span><br><span class="line">    <span class="number">0x183c5c9a8</span> &lt;+<span class="number">168</span>&gt;: <span class="keyword">movi </span>  <span class="built_in">d0</span>, <span class="number">#0000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c9ac</span> &lt;+<span class="number">172</span>&gt;: <span class="keyword">movi </span>  <span class="built_in">d1</span>, <span class="number">#0000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c9b0</span> &lt;+<span class="number">176</span>&gt;: <span class="keyword">movi </span>  <span class="built_in">d2</span>, <span class="number">#0000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c9b4</span> &lt;+<span class="number">180</span>&gt;: <span class="keyword">movi </span>  <span class="built_in">d3</span>, <span class="number">#0000000000000000</span></span><br><span class="line">    <span class="number">0x183c5c9b8</span> &lt;+<span class="number">184</span>&gt;: ret    </span><br><span class="line">    <span class="number">0x183c5c9bc</span> &lt;+<span class="number">188</span>&gt;: <span class="keyword">nop</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>注解①</strong> 回到NSObject结构，我们可以发现偏移16个字节就是cache_t成员的位置。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    isa_t isa; <span class="comment">// 8个字节</span></span><br><span class="line">    Class superclass; <span class="comment">// class其实也就是isa_t，也是8个字节</span></span><br><span class="line">    cache_t cache;              </span><br><span class="line">    class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache_t结构体</span></span><br><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets; <span class="comment">// 指针8个字节，指向一个散列表</span></span><br><span class="line">    mask_t _mask; <span class="comment">// 掩码。 mask_t 即uint32_t，是4个字节。表示的是散列表长度 - 1，类似于数组，数组长度为n，但是取值从0开始的，所以需要n-1。</span></span><br><span class="line">    mask_t _occupied; <span class="comment">// 4个字节。表示的缓存方法的个数</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket_t结构体</span></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">    cache_key_t _key; <span class="comment">// 方法名，cache_key_t即unsigned long，8个字节</span></span><br><span class="line">    IMP _imp; <span class="comment">// 方法的实现地址，指针8个字节</span></span><br><span class="line">    ......</span><br><span class="line">&#125;; <span class="comment">// bucket_t占用16个字节</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以，我们可以发现cache成员位置开始取16个字节，其实就是把散列表bucket_t的首地址保存到x10寄存器；我们知道一个寄存器占用8个字节，所以mask掩码保存到x11寄存器的低32位，occupied保存到x11寄存器的高32位。</p>
<p>&emsp;&emsp;上面的流程总结如下：</p>
<ul>
<li>判断对象是否为空</li>
<li>取到isa地址</li>
<li>根据isa地址拿到类对象的地址</li>
<li>来到缓存成员cache_t的地址，为的是开始遍历缓存散列表</li>
<li>计算出我们调用方法在散列表的位置index</li>
<li>根据散列表首地址和散列表成员长度计算出方法在散列表的具体地址：方法地址 = 首地址 + 成员长度 * index</li>
<li>比较我们调用的方法名字和散列表中找到的方法的名字是否一致，如果方法名字为空(说明肯定没被缓存过)，那么就跳转到_objc_msgSend_uncached函数，一般第一次调用方法都会执行到这里的时候就跳转走了。</li>
<li>如果调用的方法有名字(说明被缓存过了)，且一致的话就直接调用函数执行地址。</li>
<li>不一致的话，往前找前一个成员，也是进行名字比较。依次类推，直到来到首地址。</li>
<li>如果来到首地址，这时候还是没找到跟我们调用方法名字一致的散列表成员，就扩大搜索范围，来到散列表尾部再往前一个个遍历，查找与调用方法名字一致的散列表成员。</li>
<li>第二次来到表头还是没找到，就调用_objc_msgSend_uncached函数。</li>
</ul>
<p>&emsp;&emsp;前面说到，如果缓存里找不到缓存，就会调用_objc_msgSend_uncached，我们看下源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">// THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">// Out-of-band x16 is the class to search</span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">br	x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;源码里有一个MethodTableLookup的宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">	......</span><br><span class="line">	bl	__class_lookupMethodAndLoadCache3</span><br><span class="line">	......</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;里面调用c函数__class_lookupMethodAndLoadCache3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为缓存里没找到，所以入参cache为NO</span></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj,</span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找主要在这个函数里面</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果cache为YES，显然这里是NO</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    runtimeLock.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果类还没被构造好，即class_rw_t结构体还没被初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        runtimeLock.write();</span><br><span class="line"></span><br><span class="line">        realizeClass(cls);</span><br><span class="line"></span><br><span class="line">        runtimeLock.unlockWrite();</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果类还是没初始化，一般第一次来到某个函数，就会执行一次也是唯一一次的initialize方法。</span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertReading();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 再次尝试在本类缓存中查找，如果找到了就结束本函数</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是没在缓存中找到，就来到类的方法表中进行查找，如果找到了，在调用者缓存中保存，然后结束本函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试到父类的缓存表中查找，如果父类缓存表中没有找到，就去父类的方法表查找</span></span><br><span class="line">    <span class="comment">// 这是一个for循环，所以会遍历直到基类，即NSObject结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> attempts = unreasonableClassCount();</span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//    cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 方法表中如果找到了，在缓存中保存，然后结束本函数</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 都没有找到，进入动态方法解析流程：首先看看是否元类，是元类调用resolveClassMethod方法和resolveInstanceMethod方法，如果不是元类调用resolveInstanceMethod方法</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 如果是resolveClassMethod方法或resolveInstanceMethod方法也没被调用，直接调用转发机制。</span></span><br><span class="line">    <span class="comment">// 即先调用forwardingTargetForSelector，如果这个方法返回nil，继续调用methodSignatureForSelector，如果返回不为空继续调用forwardInvocation；如果还是为空，调用doesNotRecognizeSelector，则闪退报错</span></span><br><span class="line">    <span class="comment">// _objc_msgForward_impcache会在下文做解释</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断不是元类，调用resolveInstanceMethod方法</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是元类，首先调用resolveClassMethod方法，再次从类或者方法列表中查找，如果还是没有，再次调用resolveInstanceMethod方法</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;_objc_msgForward_impcache又是一个汇编函数</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">b </span>     <span class="number">0x183c5cda0</span>               <span class="comment">; _objc_msgForward</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;内部就是调用_objc_msgForward函数，里面就是跳转到CoreFoundation里的CF_forwarding_prep_0</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x183c5cda0</span> &lt;+<span class="number">0</span>&gt;:  <span class="keyword">adrp </span>  x17, <span class="number">209389</span></span><br><span class="line">    <span class="number">0x183c5cda4</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">ldr </span>   x17, [x17, <span class="number">#0x168</span>]</span><br><span class="line">-&gt;  <span class="number">0x183c5cda8</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">br </span>    x17</span><br><span class="line"></span><br><span class="line"><span class="comment">; 读取x17寄存器的值，即_CF_forwarding_prep_0函数</span></span><br><span class="line">(lldb) register read x17</span><br><span class="line">     x17 = <span class="number">0x000000018497a3c0</span>  CoreFoundation`_CF_forwarding_prep_0</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;_CF_forwarding_prep_0继续会调用<code>___forwarding___</code>函数，</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">CoreFoundation</span>`_CF_forwarding_prep_0:</span><br><span class="line">	<span class="comment">; 保存fp和lr寄存器</span></span><br><span class="line">-&gt;  <span class="number">0x18497a3c0</span> &lt;+<span class="number">0</span>&gt;:   stp    x29, x30, [<span class="built_in">sp</span>, #-<span class="number">0x10</span>]!</span><br><span class="line">    <span class="number">0x18497a3c4</span> &lt;+<span class="number">4</span>&gt;:   <span class="keyword">mov </span>   x29, <span class="built_in">sp</span></span><br><span class="line">    <span class="number">0x18497a3c8</span> &lt;+<span class="number">8</span>&gt;:   <span class="keyword">sub </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0xd0</span>             <span class="comment">; =0xd0 </span></span><br><span class="line">    <span class="number">0x18497a3cc</span> &lt;+<span class="number">12</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q7</span>, [<span class="built_in">sp</span>, <span class="number">#0xc0</span>]</span><br><span class="line">    <span class="number">0x18497a3d0</span> &lt;+<span class="number">16</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q6</span>, [<span class="built_in">sp</span>, <span class="number">#0xb0</span>]</span><br><span class="line">    <span class="number">0x18497a3d4</span> &lt;+<span class="number">20</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q5</span>, [<span class="built_in">sp</span>, <span class="number">#0xa0</span>]</span><br><span class="line">    <span class="number">0x18497a3d8</span> &lt;+<span class="number">24</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q4</span>, [<span class="built_in">sp</span>, <span class="number">#0x90</span>]</span><br><span class="line">    <span class="number">0x18497a3dc</span> &lt;+<span class="number">28</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q3</span>, [<span class="built_in">sp</span>, <span class="number">#0x80</span>]</span><br><span class="line">    <span class="number">0x18497a3e0</span> &lt;+<span class="number">32</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q2</span>, [<span class="built_in">sp</span>, <span class="number">#0x70</span>]</span><br><span class="line">    <span class="number">0x18497a3e4</span> &lt;+<span class="number">36</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q1</span>, [<span class="built_in">sp</span>, <span class="number">#0x60</span>]</span><br><span class="line">    <span class="number">0x18497a3e8</span> &lt;+<span class="number">40</span>&gt;:  <span class="keyword">str </span>   <span class="built_in">q0</span>, [<span class="built_in">sp</span>, <span class="number">#0x50</span>]</span><br><span class="line">    <span class="number">0x18497a3ec</span> &lt;+<span class="number">44</span>&gt;:  <span class="keyword">str </span>   x8, [<span class="built_in">sp</span>, <span class="number">#0x40</span>]</span><br><span class="line">    <span class="number">0x18497a3f0</span> &lt;+<span class="number">48</span>&gt;:  <span class="keyword">str </span>   x7, [<span class="built_in">sp</span>, <span class="number">#0x38</span>]</span><br><span class="line">    <span class="number">0x18497a3f4</span> &lt;+<span class="number">52</span>&gt;:  <span class="keyword">str </span>   x6, [<span class="built_in">sp</span>, <span class="number">#0x30</span>]</span><br><span class="line">    <span class="number">0x18497a3f8</span> &lt;+<span class="number">56</span>&gt;:  <span class="keyword">str </span>   x5, [<span class="built_in">sp</span>, <span class="number">#0x28</span>]</span><br><span class="line">    <span class="number">0x18497a3fc</span> &lt;+<span class="number">60</span>&gt;:  <span class="keyword">str </span>   x4, [<span class="built_in">sp</span>, <span class="number">#0x20</span>]</span><br><span class="line">    <span class="number">0x18497a400</span> &lt;+<span class="number">64</span>&gt;:  <span class="keyword">str </span>   x3, [<span class="built_in">sp</span>, <span class="number">#0x18</span>]</span><br><span class="line">    <span class="number">0x18497a404</span> &lt;+<span class="number">68</span>&gt;:  <span class="keyword">str </span>   x2, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="comment">; sp偏移8位开始的8位，存放方法，即_cmd</span></span><br><span class="line">    <span class="number">0x18497a408</span> &lt;+<span class="number">72</span>&gt;:  <span class="keyword">str </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">    <span class="comment">; sp开始的8位保存对象，即self</span></span><br><span class="line">    <span class="number">0x18497a40c</span> &lt;+<span class="number">76</span>&gt;:  <span class="keyword">str </span>   x0, [<span class="built_in">sp</span>]</span><br><span class="line">    <span class="comment">; sp保存到x0</span></span><br><span class="line">    <span class="number">0x18497a410</span> &lt;+<span class="number">80</span>&gt;:  <span class="keyword">mov </span>   x0, <span class="built_in">sp</span></span><br><span class="line">    <span class="number">0x18497a414</span> &lt;+<span class="number">84</span>&gt;:  <span class="keyword">mov </span>   x1, <span class="number">#0x0</span></span><br><span class="line">    <span class="comment">; 跳转到___forwarding___函数</span></span><br><span class="line">    <span class="number">0x18497a418</span> &lt;+<span class="number">88</span>&gt;:  <span class="keyword">bl </span>    <span class="number">0x184a94064</span>               <span class="comment">; ___forwarding___</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;里面进行转发流程，如果转发流程中的方法都没被实现，那么调用调用doesNotRecognizeSelector方法，程序就此闪退。汇编还是比较好理解，所以直接阅读一部分汇编代码，如果有兴趣阅读全部的汇编代码，只需要自己下符号断点，自己观察即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">CoreFoundation`___forwarding___:</span><br><span class="line">    0x184a94064 &lt;+0&gt;:    stp    x26, x25, [sp, #-0x50]!</span><br><span class="line">    0x184a94068 &lt;+4&gt;:    stp    x24, x23, [sp, #0x10]</span><br><span class="line">    0x184a9406c &lt;+8&gt;:    stp    x22, x21, [sp, #0x20]</span><br><span class="line">    0x184a94070 &lt;+12&gt;:   stp    x20, x19, [sp, #0x30]</span><br><span class="line">    0x184a94074 &lt;+16&gt;:   stp    x29, x30, [sp, #0x40]</span><br><span class="line">    0x184a94078 &lt;+20&gt;:   add    x29, sp, #0x40            ; =0x40 </span><br><span class="line">    0x184a9407c &lt;+24&gt;:   sub    sp, sp, #0x10             ; =0x10 </span><br><span class="line">    0x184a94080 &lt;+28&gt;:   mov    x24, x1</span><br><span class="line">    ; 在_CF_forwarding_prep_0函数里，sp保存到了x0里面，这里又将地址赋值给了x20</span><br><span class="line">    0x184a94084 &lt;+32&gt;:   mov    x20, x0</span><br><span class="line">    0x184a94088 &lt;+36&gt;:   adrp   x8, 174263</span><br><span class="line">    0x184a9408c &lt;+40&gt;:   ldr    x8, [x8, #0x770]</span><br><span class="line">    0x184a94090 &lt;+44&gt;:   ldr    x8, [x8]</span><br><span class="line">    0x184a94094 &lt;+48&gt;:   stur   x8, [x29, #-0x48]</span><br><span class="line">    ; 从x20的地址开始取16位字节分别存到x19和x22，在在_CF_forwarding_prep_0函数里sp开始的16个字节分别存了self和_cmd，所以x19就是self，x22就是_cmd</span><br><span class="line">    0x184a94098 &lt;+52&gt;:   ldp    x19, x22, [x20]</span><br><span class="line">-&gt;  0x184a9409c &lt;+56&gt;:   tbz    x19, #0x3f, 0x184a940b8   ; &lt;+84&gt;</span><br><span class="line">    0x184a940a0 &lt;+60&gt;:   ubfx   x8, x19, #60, #3</span><br><span class="line">    0x184a940a4 &lt;+64&gt;:   cmp    x8, #0x7                  ; =0x7 </span><br><span class="line">    0x184a940a8 &lt;+68&gt;:   ubfx   x9, x19, #52, #8</span><br><span class="line">    0x184a940ac &lt;+72&gt;:   add    x9, x9, #0x8              ; =0x8 </span><br><span class="line">    0x184a940b0 &lt;+76&gt;:   csel   x8, x8, x9, ne</span><br><span class="line">    0x184a940b4 &lt;+80&gt;:   cbz    w8, 0x184a9441c           ; &lt;+952&gt;</span><br><span class="line">    ;将self移到x0寄存器</span><br><span class="line">    0x184a940b8 &lt;+84&gt;:   mov    x0, x19</span><br><span class="line">    ;调用object_getClass函数，获取Class对象，返回结果保存在x0</span><br><span class="line">    0x184a940bc &lt;+88&gt;:   bl     0x183c466c4               ; object_getClass</span><br><span class="line">    ; 将返回结果保存在x21</span><br><span class="line">    0x184a940c0 &lt;+92&gt;:   mov    x21, x0</span><br><span class="line">    ; 根据class对象得到字符串</span><br><span class="line">    0x184a940c4 &lt;+96&gt;:   bl     0x183c51810               ; class_getName</span><br><span class="line">    0x184a940c8 &lt;+100&gt;:  mov    x23, x0</span><br><span class="line">    0x184a940cc &lt;+104&gt;:  adrp   x8, 199366</span><br><span class="line">    ; 得到SEL对象forwardingTargetForSelector:并保存到x25</span><br><span class="line">    0x184a940d0 &lt;+108&gt;:  ldr    x25, [x8, #0x340]</span><br><span class="line">    ; 将class对象保存到x0</span><br><span class="line">-&gt;  0x184a940d4 &lt;+112&gt;:  mov    x0, x21</span><br><span class="line">	; 将sel对象保存到x1</span><br><span class="line">    0x184a940d8 &lt;+116&gt;:  mov    x1, x25</span><br><span class="line">    ; 调用class_respondsToSelector方法，是否实现了得到SEL对象forwardingTargetForSelector:方法</span><br><span class="line">    0x184a940dc &lt;+120&gt;:  bl     0x183c47550               ; class_respondsToSelector</span><br><span class="line">    0x184a940e0 &lt;+124&gt;:  cbz    w0, 0x184a94100           ; &lt;+156&gt;</span><br><span class="line">    0x184a940e4 &lt;+128&gt;:  mov    x0, x19</span><br><span class="line">    0x184a940e8 &lt;+132&gt;:  mov    x1, x25</span><br><span class="line">-&gt;  0x184a940ec &lt;+136&gt;:  mov    x2, x22</span><br><span class="line">	; 如果实现了就调用得到SEL对象forwardingTargetForSelector:方法</span><br><span class="line">    0x184a940f0 &lt;+140&gt;:  bl     0x183c5c900               ; objc_msgSend</span><br><span class="line">    ; 后面流程大致差不多，如果没实现得到SEL对象forwardingTargetForSelector:方法，就看下有没有methodSignatureForSelector方法，如果实现了methodSignatureForSelector方法，看下有没有调用forwardInvocation:....</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这部分流程总结如下：</p>
<ul>
<li>再次从缓存查找一次。</li>
<li>如果缓存还是没找到，去类对象的方法表里查找方法，如果找到，就保存到缓存，并执行这个方法。</li>
<li>如果类对象方法表里也没找到，就先去父类的缓存表里找，如果缓存表也没找到，就取找父类的方法表，如果找到，同样缓存方法到缓存，如果还是没找到，继续往上一层父类查找。</li>
<li>以此类推，直到找到基类，即NSObject类的方法表。</li>
<li>到了基类还是没找到，那么就先判断自己是不是元类，不是元类的话调用resolveInstanceMethod方法；是元类的话，先调用resolveClassMethod方法，接着去类的方法表一层一层查找有没有实现这个实例方法，如果也没找到就调用resolveInstanceMethod方法。</li>
<li>如果resolveInstanceMethod方法或者resolveClassMethod方法也没被调用，开启转发流程。</li>
<li>先调用forwardingTargetForSelector，如果这个方法返回nil，继续调用methodSignatureForSelector，如果返回不为空继续调用forwardInvocation；如果还是为空，调用doesNotRecognizeSelector，则闪退报错</li>
</ul>
<h1 id="0x04-Runtime的初始化"><a href="#0x04-Runtime的初始化" class="headerlink" title="0x04 Runtime的初始化"></a>0x04 Runtime的初始化</h1><p>&emsp;&emsp;这部分内容在Category文章里粗略讲述过一遍，这里将会带着源码详细走下初始化流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;load_images函数其实就是调用类的<code>+load</code>方法，这里不重复介绍，Category文章里讲的很详细了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们直接看如何加载Mach-O信息，通过map_images函数获取所有的类相关的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">map_images_nolock</span><span class="params">(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 之前做的操作，就是读取Mach-O的信息</span></span><br><span class="line">     _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Mach-O信息加载进来后，就要从数据段里读取相应的内容，并将构建成我们具体使用的类，我们的类，协议，分类等 都在数据段里，如下图。</p>
<p><img src="Data_Objc_CatList.png" alt="数据段信息示意图"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">uint32_t</span> hIndex;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    Class *resolvedFutureClasses = nil;</span><br><span class="line">    <span class="keyword">size_t</span> resolvedFutureClassCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> doneOnce;</span><br><span class="line">    <span class="function">TimeLogger <span class="title">ts</span><span class="params">(PrintImageTimes)</span></span>;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: found %d classes during launch"</span>, totalClasses);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// namedClasses</span></span><br><span class="line">        <span class="comment">// Preoptimized classes don't go in this table.</span></span><br><span class="line">        <span class="comment">// 4/3 is NXMapTable's load factor</span></span><br><span class="line">        <span class="keyword">int</span> namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line"></span><br><span class="line">        ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: first time tasks"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类的信息</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! mustReadClasses(hi)) &#123;</span><br><span class="line">            <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">        <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">		<span class="comment">// 从数据段的__objc_classlist里查找有哪些类，项目里有多少类，这里就有多少</span></span><br><span class="line">        <span class="keyword">classref_t</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// 得到类</span></span><br><span class="line">            Class cls = (Class)classlist[i];</span><br><span class="line">            <span class="comment">// 以类名有key，类为value注册进一个类映射表</span></span><br><span class="line">            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">                <span class="comment">// 跟objc_getFutureClass有关，这里可以忽略</span></span><br><span class="line">                resolvedFutureClasses = (Class *)</span><br><span class="line">                    <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                            (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover classes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修复类列表和懒加载类列表还没映射的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="comment">// 获取被引用的类，只有项目里被import的才会在这里出现</span></span><br><span class="line">            <span class="comment">// 所以_getObjc2ClassList得到的总数 - _getObjc2ClassRefs得到的总数 = 项目中没有被用到的类，可以做优化参考。</span></span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            <span class="comment">// 在类映射表重新映射</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新映射被引用的父类</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: remap classes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取被引用的方法列表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">    sel_lock();</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;isPreoptimized()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">        SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">        UnfixedSelectors += count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">            <span class="comment">// 在方法映射表中注册</span></span><br><span class="line">            sels[i] = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sel_unlock();</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up selector references"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取协议列表</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols();</span><br><span class="line">        <span class="keyword">bool</span> isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">// 在协议映射表中注册</span></span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover protocols"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取被引用的协议，并重新映射</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up @protocol references"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现+load的类列表</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">            _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = remapClass(classlist[i]);</span><br><span class="line">            <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 构造类信息，只有被构造好的类才可以被使用</span></span><br><span class="line">            realizeClass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: realize non-lazy classes"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取分类列表</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">			<span class="comment">// 如果类映射表里没有分类对应的类，报错</span></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理分类</span></span><br><span class="line">            <span class="comment">// 首先，注册分类到其目标类</span></span><br><span class="line">            <span class="comment">// 其次，重建类的方法表、协议表和成员变量表</span></span><br><span class="line">            <span class="keyword">bool</span> classExists = NO;</span><br><span class="line">            <span class="comment">// 实例信息</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将分类表插入到分类映射表里，供后面取出使用加入到类的方法表、协议表等</span></span><br><span class="line">                <span class="comment">// 因为此时类的结构还没被构造完成，就算要加也加不进去，所以先保存下</span></span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="comment">// 如果类已经被构造好，比如有实现+load方法的类会被先构造好，那么这里就需要重建类的结构，把类的方法、协议等重新加入进类的方法表、协议表里，并且刷新</span></span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 类信息</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover categories"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 勾建所有类的信息，以便其可以被使用</span></span><br><span class="line">    <span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">        realizeAllClasses();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EACH_HEADER</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态链接所有的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">realizeAllClasses</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi; hi = hi-&gt;getNext()) &#123;</span><br><span class="line">        realizeAllClassesInImage(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">realizeAllClassesInImage</span><span class="params">(header_info *hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    <span class="keyword">classref_t</span> *classlist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;areAllClassesRealized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">	<span class="comment">// 动态链接类，其类处于可用状态</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        realizeClass(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hi-&gt;setAllClassesRealized(YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRealized()) <span class="keyword">return</span> cls;</span><br><span class="line">    assert(cls == remapClass(cls));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取RO信息</span></span><br><span class="line">    ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line">    <span class="comment">// 之前类的信息是只读的，这时候构建成可读可写的</span></span><br><span class="line">    rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">    cls-&gt;setData(rw);</span><br><span class="line"></span><br><span class="line">    isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line"></span><br><span class="line">    rw-&gt;version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类和元类也需要构建</span></span><br><span class="line">    supercls = realizeClass(remapClass(cls-&gt;superclass));</span><br><span class="line">    metacls = realizeClass(remapClass(cls-&gt;ISA()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新被重新映射的父类和元类</span></span><br><span class="line">    cls-&gt;superclass = supercls;</span><br><span class="line">    cls-&gt;initClassIsa(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转实例变量的偏移和布局</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    cls-&gt;setInstanceSize(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;setHasCxxDtor();</span><br><span class="line">        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接这个类到父类的父子关系表中</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addRootClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分类数据，比如方法表、协议表加载进类的方法表、协议表中。是前插操作，具体分类的文章里有说够</span></span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methodizing for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: methodizing class '%s' %s"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 附加属性</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 附加协议</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附加分类信息</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats-&gt;count; i++) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"CLASS: attached category %c%s(%s)"</span>, </span><br><span class="line">                             isMeta ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), cats-&gt;<span class="built_in">list</span>[i].cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过上面的源代码，可以知道，我们的类的都是从Mach-O得到的，一开始还没被动态链接，所以这个类是不能被使用的，整个初始化流程可以总结如下：</p>
<ul>
<li>通过Mach-O数据区里的<code>__objc_classlist</code>段，获取所有类，并注册进一个类映射表，通过这个表以后可以根据类名可以很快的得到这个类。</li>
<li>读取数据区<code>__objc_selrefs</code>段，获取所有被引用的方法，并注册进一个方法映射表</li>
<li>读取数据区<code>__objc_protolist</code>段，获取所有协议，并注册进一个协议映射表</li>
<li>读取数据区<code>__objc_nlclslist</code>段，获取所有实现了+(void)load的类，并提前链接好类，使得这个类已经准备好被使用</li>
<li>读取数据区<code>__objc_catlist</code>段，获取所有分类，并注册进一个分类映射表</li>
<li>链接所有类，使得所有类做好被使用的准备。其中包括开辟class_rw_t区，使得类的数据可以即可读又可以写，并且排列好父子关系链，最后将分类的信息前插进类的各个信息表中。</li>
</ul>
<h1 id="0x05-property分析"><a href="#0x05-property分析" class="headerlink" title="0x05 @property分析"></a>0x05 @property分析</h1><p>&emsp;&emsp;@property定义的属性，我们知道在不是分类的情况下，会自动生成getter、setter和成员变量。其实这一切都是在编译器完成的，虽然这块不涉及runtime，但是前面我们知道类构建的时候会基于class_ro_t结构重新生成一个class_rw_t结构。而class_ro_t保存的其实就是编译期类的信息，其中包括属性拆解后的信息。</p>
<p>&emsp;&emsp;定义测试代码如下</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;clang转成c++代码看下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> instanceStart;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> instanceSize;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ivarLayout;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">baseMethods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">objc_protocol_list</span> *<span class="title">baseProtocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ivar_list_t</span> *<span class="title">ivars</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *weakIvarLayout;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">isa</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">superclass</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *cache;</span><br><span class="line">	<span class="keyword">void</span> *vtable;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_ro_t</span> *<span class="title">ro</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员变量表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">ivar_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ivar_t</span> <span class="title">ivar_list</span>[2];</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_ivar_t</span>),</span><br><span class="line">	<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 属性age和name变成了_age和_name的成员变量</span></span><br><span class="line">	&#123;&#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_Animal$_age, <span class="string">"_age"</span>, <span class="string">"i"</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">	 &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_Animal$_name, <span class="string">"_name"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[4];</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">4</span>,</span><br><span class="line">    <span class="comment">// 生成对应的setter和get方法</span></span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">"age"</span>, <span class="string">"i16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_age&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setAge:"</span>, <span class="string">"v20@0:8i16"</span>, (<span class="keyword">void</span> *)_I_Animal_setAge_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"name"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_name&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setName:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_Animal_setName_&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 属性表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[2];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">	<span class="number">2</span>,</span><br><span class="line">	&#123;&#123;<span class="string">"age"</span>,<span class="string">"Ti,N,V_age"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N,V_name"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化_class_ro_t结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">class_ro_t</span> _<span class="title">OBJC_CLASS_RO_</span>$_<span class="title">Animal</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = &#123;</span></span><br><span class="line">	<span class="number">0</span>, __OFFSETOFIVAR__(struct Animal, _age), <span class="keyword">sizeof</span>(struct Animal_IMPL), </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="string">"Animal"</span>,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_INSTANCE_METHODS_Animal,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_ivar_list_t</span> *)&amp;_OBJC_$_INSTANCE_VARIABLES_Animal,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Animal,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过转换的代码可以很清楚看到，属性的确是在编译期被拆解到class_ro_t结构的各个表中。我们看下成员变量表的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">ivar_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ivar_t</span> <span class="title">ivar_list</span>[2];</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_ivar_t</span>),</span><br><span class="line">	<span class="number">2</span>, <span class="comment">// 表内元素个数</span></span><br><span class="line">	&#123;&#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_Animal$_age, <span class="string">"_age"</span>, <span class="string">"i"</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">	 &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_Animal$_name, <span class="string">"_name"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;ivar_list装的是ivar_t，其结构如下，拿上面第一个ivar_t结构举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset; <span class="comment">// 成员的偏移地址，对应&amp;OBJC_IVAR_$_Animal$_age</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 名字，对应"_age"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type; <span class="comment">// 类型，对应"i"</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw; <span class="comment">//内存对齐， 对应2</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size; <span class="comment">// 对应4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>OBJC_IVAR_$_Animal$_age</code>表示成员的偏移地址，这样做的好处是只要拿到实例的地址，再加上偏移地址就能直接访问成员变量，快速的进行取值和赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> OBJC_IVAR_$_Animal$_age __attribute__ ((used, section (<span class="string">"__DATA,__objc_ivar"</span>))) = __OFFSETOFIVAR__(struct Animal, _age);</span><br></pre></td></tr></table></figure>
<hr>
<p>&emsp;&emsp;其他方法表和属性表初始化也类似，这里不做复述，但是我们看到在方法表中还有这样的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;(struct objc_selector *)<span class="string">"age"</span>, <span class="string">"i16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_age&#125;,</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;i16@0:8是什么样的格式，这其实是@encode指令，可以将具体的类型表示成字符串编码。</p>
<p><img src="encode.png" alt="encode示意图"> </p>
<p>&emsp;&emsp;那么i16@0:8是什么意思呢？</p>
<blockquote>
<p>i：表示返回int类型</p>
<p>16：表示整个方法占据16个字节</p>
<p>@：表示第一个参数，即对象，方法中默认带两个参数self和_cmd，这里就是指self</p>
<p>0：表示其从偏移位置0开始的8个字节，之前说过这个方法占据16个字节，self占据其中8个字节</p>
<p>：:表示第二个参数，是一个方法，即_cmd</p>
<p>8：表示偏移位置8开始的8个字节，即方法占据16个字节的后8个字节。</p>
</blockquote>
<p>&emsp;&emsp;v20@0:8i16再来一个setter方法</p>
<blockquote>
<p>v：表示返回void</p>
<p>20：表示整个方法占据20字节</p>
<p>@：表示第一个参数对象，即self，占据8个字节</p>
<p>0：表示对象从偏移值0开始占据8个字节</p>
<p>：表示第二个参数，是一个方法，即_cmd</p>
<p>8：表示方法是从偏移值8开始占据8个字节</p>
<p>i：表示第三个参数，int类型的参数</p>
<p>16：表示第三个参数从偏移值16开始占据4个字节</p>
</blockquote>
<p>&emsp;&emsp;所有参数加起来的确是20个字节。继续回到这个方法表中，_I_Animal_age就是函数的实际执行地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;(struct objc_selector *)<span class="string">"age"</span>, <span class="string">"i16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_age&#125;,</span><br></pre></td></tr></table></figure>
<p>&emsp;这里也验证了默认带的两个参数：self、cmd。<code>OBJC_IVAR_$_Animal$_age</code>前面说过表示的是成员变量的偏移地址。，通过self+偏移地址直接拿到值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _I_Animal_age(Animal * self, SEL _cmd) &#123; </span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_Animal$_age)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不同于getter，setter的执行函数内部是这样的，拿到成员变量偏移地址后赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Animal_setAge_(Animal * self, SEL _cmd, <span class="keyword">int</span> age) &#123; </span><br><span class="line">    (*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_Animal$_age)) = age; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果我自己实现了setter方法，代码又会如何变化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换代码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Animal_setAge_(Animal * self, SEL _cmd, <span class="keyword">int</span> age) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;setter方法就变成了自己定义的方法了，如果里面不写<code>_age = age</code>，那不会对成员变量_age进行赋值。</p>
<hr>
<p>&emsp;&emsp;在回来说下属性表，之前说过对方法的定义上，苹果有一套自己的@encode指令，属性同样也有这样的@endcode指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[2];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Animal __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">	<span class="number">2</span>,</span><br><span class="line">	&#123;&#123;<span class="string">"age"</span>,<span class="string">"Ti,N,V_age"</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N,V_name"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其参照表如下</p>
<p><img src="encode_property.png" alt="encode示意图"> </p>
<p>&emsp;&emsp;<code>Ti,N,V_age</code>的理解如下</p>
<blockquote>
<p>T：类型，后面紧跟着的就是对应类型</p>
<p>i：int类型</p>
<p>N：nonatomic</p>
<p>V_age：对应的变量名是_age</p>
</blockquote>
<p>&emsp;&emsp;<code>T@\&quot;NSString\&quot;,C,N,V_name</code>，对于这样的可以理解为如下，对于我们定义属性时的<code>@property(nonatomic, copy) NSString *name</code>是不是一一对应了。</p>
<blockquote>
<p>T@\”NSString\”：类型是个OC对象，对象名是NSString</p>
<p>C：copy</p>
<p>N：nonatomic</p>
<p>V_name：对应的变量名是_name</p>
</blockquote>
<hr>
<p>&emsp;&emsp;我们已经知道属性在编译期会自动被拆成成员变量、setter、getter以及相关属性信息放到各个对应的表中。那么我们在运行时想要创建一个属性，下面这样做可以吗？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        class_addIvar([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log2(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span>*)), <span class="keyword">@encode</span>(<span class="built_in">NSString</span> *));</span><br><span class="line">        objc_property_attribute_t attrs[] = &#123; &#123; <span class="string">"T"</span>, <span class="string">"@\"NSString\""</span> &#125;, &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;, &#123; <span class="string">"V"</span>, <span class="string">"_name"</span> &#125; &#125;;</span><br><span class="line">        class_addProperty([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"name"</span>, attrs, <span class="number">3</span>);</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(name), (IMP)nameGetter, <span class="string">"@@:"</span>);</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(setName:), (IMP)nameSetter, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *nameGetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>);</span><br><span class="line">    <span class="keyword">return</span> object_getIvar(<span class="keyword">self</span>, ivar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> nameSetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *name) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>);</span><br><span class="line">    <span class="keyword">id</span> oldName = object_getIvar(<span class="keyword">self</span>, ivar);</span><br><span class="line">    <span class="keyword">if</span> (oldName != name) object_setIvar(<span class="keyword">self</span>, ivar, [name <span class="keyword">copy</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;答案是不可以，问题出在class_addIvar函数里，所在添加ivar的类有一个是<code>RW_CONSTRUCTING</code>的标签。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL  <span class="title">class_addIvar</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!type) type = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (name  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">""</span>)) name = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 来到这里返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (!(cls-&gt;data()-&gt;flags &amp; RW_CONSTRUCTING)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((name  &amp;&amp;  getIvar(cls, name))  ||  size &gt; UINT32_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么在哪里设置了这个标签，<code>objc_allocateClassPair</code>函数里调用的<code>objc_initializeClassPair_internal</code>函数里设置了这个标签，而<code>objc_allocateClassPair</code>则是我们动态生成一个类的时候用到的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cls, meta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getClass(name)  ||  !verifySuperclass(superclass, <span class="literal">true</span><span class="comment">/*rootOK*/</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate new classes.</span></span><br><span class="line">    cls  = alloc_class_for_subclass(superclass, extraBytes);</span><br><span class="line">    meta = alloc_class_for_subclass(superclass, extraBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme mangle the name if it looks swift-y?</span></span><br><span class="line">    objc_initializeClassPair_internal(superclass, name, cls, meta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">objc_initializeClassPair_internal</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, Class cls, Class meta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set basic info</span></span><br><span class="line"></span><br><span class="line">    cls-&gt;data()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    meta-&gt;data()-&gt;flags = RW_CONSTRUCTING | RW_COPIED_RO | RW_REALIZED | RW_REALIZING;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以要想使用class_addIvar必须是动态生成的一个类，还不是一个在编译期就存在的类。</p>
<h4 id="一个特殊的例子"><a href="#一个特殊的例子" class="headerlink" title="一个特殊的例子"></a>一个特殊的例子</h4><p>&emsp;&emsp;下面的例子中，程序是否可以正常运行，如果可以正常运行，那么得出的结果会是什么？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)print &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"动物的名字叫：%@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *a = <span class="string">@"占位数据，测试中...."</span>;</span><br><span class="line">    </span><br><span class="line">    Class cls = [Animal <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj print];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行程序后，我们可以看到print方法顺利被调用，但是结果有点出乎预料</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动物的名字叫：占位数据，测试中....</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面已经说过，我们方法的调用首先是取isa地址，取到isa地址后，isa地址与上 #0xffffffff8得到类对象地址。而此例中，我们获取到类对象后，然后<code>&amp;cls</code>也取到了Animal类对象地址。从这里开始流程上就跟Animal实例对象调用print方法一致了，所以可以顺利调用print方法。</p>
<p>&emsp;&emsp;为了我验证说的，我们首先实例化一个Aniaml对象</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Animal *animal = [Animal new];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印animal的地址</span></span><br><span class="line">(lldb) p animal</span><br><span class="line">(Animal *) $<span class="number">0</span> = <span class="number">0x00000001d0007f00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个地址保存的第一个位置就是isa，看过class结构都清楚isa是第一个成员</span></span><br><span class="line"><span class="comment">// isa的地址为0x000001a50000e59d</span></span><br><span class="line">(lldb) x/<span class="number">4</span>g <span class="number">0x170000c80</span></span><br><span class="line"><span class="number">0x1d0007f00</span>: <span class="number">0x000001a104b8659d</span> <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x1d0007f10</span>: <span class="number">0xbadd7e6de908bead</span> <span class="number">0x0000000000000000</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 与上&amp; 0xffffffff8得到类对象地址</span></span><br><span class="line">(lldb) p/x <span class="number">0x000001a104b8659d</span>  &amp; <span class="number">0xffffffff8</span></span><br><span class="line">(<span class="keyword">long</span>) $<span class="number">1</span> = <span class="number">0x0000000104b86598</span> <span class="comment">// 记住这个类地址</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 我们打断点读取obj的地址为</span></span><br><span class="line">(lldb) po obj</span><br><span class="line">&lt;Animal: <span class="number">0x16b287978</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj保存的是cls指针的地址，实际上obj就是指向cls的。要想重新拿回cls对象的地址，需要看看这个地址保存的内容是什么</span></span><br><span class="line"><span class="comment">// 我们的类对象地址再次出现了</span></span><br><span class="line">(lldb) x/<span class="number">4</span>g <span class="number">0x16b287978</span></span><br><span class="line"><span class="number">0x16b287978</span>: <span class="number">0x0000000104b86598</span> <span class="number">0x00000001d0007f00</span></span><br><span class="line"><span class="number">0x16b287988</span>: <span class="number">0x0000000104b84330</span> <span class="number">0x000000016b2879e0</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以<code>[(__bridge id)obj print];</code>的时候，汇编代码中[x0]取的就是<code>0x0000000104b86598</code>，<code>0x0000000104b86598</code> &amp; <code>0xffffffff8</code>还是<code>0x0000000104b86598</code>，剩下的步骤就跟<code>[animal print]</code>流程一样的，最后调用成功。</p>
<p>&emsp;&emsp;我们的函数栈关系如下：</p>
<p><img src="stack_layout_01.png" alt="函数栈示意图"> </p>
<p>​    那么，为什么打印结果会那么奇怪呢？我们先看下正常实例调用流程是怎么样的</p>
<p><img src="stack_layout_02.png" alt="函数栈示意图"> </p>
<p>&emsp;&emsp;我们变量a指向 <code>Animal</code>实例对象所在的内存地址。调用<code>self.name</code>的时候，对象内存中第二个8个字节保存的就是变量<code>_name</code>的值，第一个8个字节肯定是isa。</p>
<p>&emsp;&emsp;那么同样的，在我们这个例子里，我们的obj指向的是cls的地址，读取<code>_name</code>就是读取cls地址开始的第二个8个字节。</p>
<p><img src="stack_layout_03.png" alt="函数栈示意图"> </p>
<p>&emsp;&emsp;我们证明下我们之前说的，断点打在print方法内，打印obj指向的内存的内容，<code>0x000000010007e5a8</code>是第一个8个字节，指的是isa指针；<code>0x000000010007c340</code>是第二个8个字节，就是我们字符串的内容，<code>self.name</code>读取的就是这块字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po self</span><br><span class="line">&lt;Animal: <span class="number">0x16fd8f970</span>&gt;</span><br><span class="line"></span><br><span class="line">(lldb) x/<span class="number">4</span>g <span class="number">0x16fd8f970</span></span><br><span class="line"><span class="number">0x16fd8f970</span>: <span class="number">0x000000010007e5a8</span> <span class="number">0x000000010007c340</span></span><br><span class="line"><span class="number">0x16fd8f980</span>: <span class="number">0x000000016fd8f9d8</span> <span class="number">0x0000000000000001</span></span><br><span class="line">(lldb) po <span class="number">0x000000010007c340</span></span><br><span class="line">占位数据，测试中....</span><br></pre></td></tr></table></figure>
<h1 id="0x06-Super"><a href="#0x06-Super" class="headerlink" title="0x06 Super"></a>0x06 Super</h1><p>&emsp;&emsp;super在我们项目中用的熟的不能再熟了，比如调用父类的方法。这里我们先举个例子，有个继承自NSObject的类，下面的打印猜猜会是什么样的？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)print &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self class is %@\n"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self superclass is %@\n"</span>, [<span class="keyword">self</span> superclass]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super class is %@\n"</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super superclass is %@\n"</span>, [<span class="keyword">super</span> superclass]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个细节很多人很容易忽视掉，我们发现[self class]、[self superclass]和[super class]、[super superclass]打印结果其实是一样的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">17.169031</span>+<span class="number">0800</span> testData[<span class="number">59785</span>:<span class="number">156959813</span>] <span class="keyword">self</span> <span class="keyword">class</span> is Animal</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">17.169237</span>+<span class="number">0800</span> testData[<span class="number">59785</span>:<span class="number">156959813</span>] <span class="keyword">self</span> superclass is <span class="built_in">NSObject</span></span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">17.169353</span>+<span class="number">0800</span> testData[<span class="number">59785</span>:<span class="number">156959813</span>] <span class="keyword">super</span> <span class="keyword">class</span> is Animal</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">17.169484</span>+<span class="number">0800</span> testData[<span class="number">59785</span>:<span class="number">156959813</span>] <span class="keyword">super</span> superclass is <span class="built_in">NSObject</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那要解开这个原因，我们还是得先将代码转换一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Animal_print(Animal * self, SEL _cmd) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_Animal_cb9872_mi_0, ((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"class"</span>)));</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_Animal_cb9872_mi_1, ((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"superclass"</span>)));</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_Animal_cb9872_mi_2, ((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Animal"</span>))&#125;, sel_registerName(<span class="string">"class"</span>)));</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_Animal_cb9872_mi_3, ((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Animal"</span>))&#125;, sel_registerName(<span class="string">"superclass"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有个__rw_objc_super结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> &#123;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">object</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">superClass</span>;</span> </span><br><span class="line">	__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;调用super的时候消息接收者实际了一个<code>__rw_objc_super</code>对象，赋值的时候<code>__rw_objc_super</code>对象的object实际是self，superClass实际是class_getSuperclass(objc_getClass(“Animal”))，即NSObject。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Animal"</span>))&#125;, sel_registerName(<span class="string">"class"</span>))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;消息发送通过<code>objc_msgSendSuper</code>，但是真机调试中我们发现，实际调用的是<code>objc_msgSendSuper2</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100799638</span> &lt;+<span class="number">64</span>&gt;:  bl     <span class="number">0x100799f64</span>               ; symbol stub <span class="keyword">for</span>: objc_msgSendSuper2</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样<code>objc_msgSendSuper2</code>是一个汇编函数，我们需要看下其实现过程，这里其实只要看一行就够了</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">libobjc.A.dylib</span>`objc_msgSendSuper2:</span><br><span class="line">	<span class="comment">; x0即__rw_objc_super对象，取出16位分别给x0和x16寄存器，我们知道__rw_objc_super装了两个对象一个object和superClass，所以x0寄存器里装的就是self</span></span><br><span class="line">    <span class="number">0x183c5cb00</span> &lt;+<span class="number">0</span>&gt;:   ldp    x0, x16, [x0]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据函数调用约定，x0装的是消息接收者，所以实际消息接收者是self。所以[self class]和[super class]，实际消息接收者都是self，那么这两个的区别就是[self class]从自己的方法表开始查找方法，而[super class]是直接从父类的方法表开始查找方法。</p>
<h1 id="0x07-isKindOfClass-amp-isMemberOfClass"><a href="#0x07-isKindOfClass-amp-isMemberOfClass" class="headerlink" title="0x07 isKindOfClass &amp; isMemberOfClass"></a>0x07 isKindOfClass &amp; isMemberOfClass</h1><p>&emsp;&emsp;有如下测试代码，其结果如何？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Animal *animal = [Animal new];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">BOOL</span> a = [animal isKindOfClass:[animal <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> b = [animal isMemberOfClass:[animal <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> c = [animal isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> d = [animal isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> e = [Animal isKindOfClass:[Animal <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> f = [Animal isMemberOfClass:[Animal <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> g = [Animal isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line"><span class="built_in">BOOL</span> h = [Animal isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不卖关子，结果如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">① a = YES;</span><br><span class="line">② b = YES;</span><br><span class="line">③ c = YES;</span><br><span class="line">④ d = NO;</span><br><span class="line">⑤ e = NO;</span><br><span class="line">⑥ f = NO;</span><br><span class="line">⑦ g = YES;</span><br><span class="line">⑧ h = NO;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;分析为什么结果之前，我们先看下源代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((id)self) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object_getClass如果传入类对象，得到元类对象</span></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;源代码可以看出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实例方法：</span><br><span class="line">isKindOfClass： 从自己类对象开始遍历父类对象，如果跟cls相等，就返回YES</span><br><span class="line">isMemberOfClass：直接判断自己类对象与cls是否相等</span><br><span class="line"></span><br><span class="line">类方法：</span><br><span class="line">isKindOfClass： 从自己元类对象开始遍历父类元类对象，如果跟cls相等，就返回YES</span><br><span class="line">isMemberOfClass：直接判断自己元类对象与cls是否相等</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据上面得出的结论，我们的例子可以分析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animal是实例对象，其类对象是Animal，[animal class]即Animal，所以返回YES</span></span><br><span class="line">BOOL a = [animal isKindOfClass:[animal class]];</span><br><span class="line"><span class="comment">// animal是实例对象，其类对象是Animal，[animal class]即Animal，所以返回YES</span></span><br><span class="line">BOOL b = [animal isMemberOfClass:[animal class]];</span><br><span class="line"><span class="comment">// animal是实例对象，其类对象是Animal，遍历的时候回找到NSObject，所以返回YES</span></span><br><span class="line">BOOL c = [animal isKindOfClass:[NSObject class]];</span><br><span class="line"><span class="comment">// animal是实例对象，其类对象是Animal，[NSObject class]即NSObject，两者不相等，所以返回NO</span></span><br><span class="line">BOOL d = [animal isMemberOfClass:[NSObject class]];</span><br><span class="line"><span class="comment">// Animal是类对象，内部是比较元类对象，而[Animal class]是类对象，遍历只是找此元类对象的父类，两者肯定不相等，所以返回NO</span></span><br><span class="line">BOOL e = [Animal isKindOfClass:[Animal class]];</span><br><span class="line"><span class="comment">// Animal是类对象，内部是比较元类对象，而[Animal class]是类对象，两者比较肯定不相等，所以返回NO</span></span><br><span class="line">BOOL f = [Animal isMemberOfClass:[Animal class]];</span><br><span class="line"><span class="comment">// Animal是类对象，内部是比较元类对象，而[NSObject class]是类对象，遍历的时候查找元类对象的父类，然而又因为NSObject是基类，我们知道元类查找父类的时候，当找到元类的基类也没找到的话，会指向类对象，所以Animal元类对象查找super的时候找到NSObject元类对象的时候，发现还是不匹配，会继续匹配NSObject的类对象，而这时[NSObject class]就是NSObject类对象，所以相等，返回YES。</span></span><br><span class="line">BOOL g = [Animal isKindOfClass:[NSObject class]];</span><br><span class="line"><span class="comment">// 因为没有遍历，元类对象跟类对象肯定不相等，所以返回NO</span></span><br><span class="line">BOOL h = [Animal isMemberOfClass:[NSObject class]];</span><br></pre></td></tr></table></figure>
<h1 id="0x08-方法交换"><a href="#0x08-方法交换" class="headerlink" title="0x08 方法交换"></a>0x08 方法交换</h1><p>&emsp;&emsp;首先看下方法的结构信息，包含了函数实现的具体地址IMP。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以其实很好猜了，交换imp地址就能完成方法交换操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m1  ||  !m2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">	<span class="comment">// 交换</span></span><br><span class="line">    IMP m1_imp = m1-&gt;imp;</span><br><span class="line">    m1-&gt;imp = m2-&gt;imp;</span><br><span class="line">    m2-&gt;imp = m1_imp;</span><br><span class="line">	<span class="comment">// 缓存刷新下</span></span><br><span class="line">    flushCaches(nil);</span><br><span class="line"></span><br><span class="line">    updateCustomRR_AWZ(nil, m1);</span><br><span class="line">    updateCustomRR_AWZ(nil, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x09-Hook-Block"><a href="#0x09-Hook-Block" class="headerlink" title="0x09 Hook Block"></a>0x09 Hook Block</h1><p>&emsp;&emsp;我们知道可以通过<code>method_exchangeImplementations</code>可以hook我们OC方法。那么如果我想要hook block又该如何实现呢？</p>
<p>&emsp;&emsp;之前Block篇里我们知道block结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">xxxx_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="comment">// 下面两个是可选的，是捕获对象的时候会被加入到这个结构</span></span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __xxxx_block_impl_0*, struct __xxx_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __xxxx_block_impl_0*);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">xxx_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">xxx_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过<a href="https://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">官方的ABI</a>，我们看到对其完整定义如下，signature描述了方法的参数类型和返回值类型等信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_literal_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa; </span><br><span class="line">    <span class="keyword">int</span> flags; <span class="comment">// 标志位</span></span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;       </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;         </span><br><span class="line">    <span class="comment">// optional helper functions</span></span><br><span class="line">    <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);     </span><br><span class="line">    <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src);             </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;                        </span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以我们可以自己定义一个这样的结构体，然后将block对象强转为这样的结构体，这样我们就可以拿到block对象的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">blockDescription</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> block_size;</span><br><span class="line">&#125;*BlockDescription;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">blockMemoryDescription</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *blockImpl);</span><br><span class="line">&#125;*BlockMemoryDescription;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">blockSignDescription</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *signature;</span><br><span class="line">&#125;*BlockSignDescription;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">    BlockDescription description;</span><br><span class="line">&#125;HBlock, *PHBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应block对象的flag成员</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>),</span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>),</span><br><span class="line">    BLOCK_HAS_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// IFF BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE =     (<span class="number">1</span> &lt;&lt; <span class="number">30</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们知道进入消息转发流程后，会调用<code>NSBlock</code>的<code>methodSignatureForSelector</code>和<code>hookForwardInvocation</code>方法，<code>NSBlock</code>是官方的对象所以我们不能进行修改，所以需要替换<code>methodSignatureForSelector</code>和<code>hookForwardInvocation</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXCHANGE_METHOD(originalM, replaceM) \</span></span><br><span class="line">&#123;   Class <span class="class"><span class="keyword">class</span> = [<span class="title">NSObject</span> <span class="title">class</span>];</span> \</span><br><span class="line">    Class swizzledClass = [HookBlock class];\</span><br><span class="line">    SEL originalSelector = @selector(originalM);\</span><br><span class="line">    SEL swizzledSelector = @selector(replaceM); \</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector); \</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(swizzledClass, swizzledSelector); \</span><br><span class="line">    BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); \</span><br><span class="line">    <span class="keyword">if</span> (success) &#123; \</span><br><span class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);\</span><br><span class="line">    &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hookBlock:(id)block &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    EXCHANGE_METHOD(methodSignatureForSelector:, hookMethodSignatureForSelector:)</span><br><span class="line">    EXCHANGE_METHOD(forwardInvocation:, hookForwardInvocation:)</span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">// 强转为自定义的block结构</span></span><br><span class="line">    PHBlock hBlock = (__bridge PHBlock)(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换原来的block实现"><a href="#替换原来的block实现" class="headerlink" title="替换原来的block实现"></a>替换原来的block实现</h3><p>&emsp;&emsp;现在有这样一个需求，我拦截block后，需要替换其原本实现，我们原本定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>(^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"很高兴认识你"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HookBlock *hook = [HookBlock <span class="keyword">new</span>];</span><br><span class="line">    [hook hookBlock:testBlock];</span><br><span class="line"></span><br><span class="line">    testBlock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果正常调用，将会打印<code>很高兴认识你</code>，我们现在想要改变其打印为<code>很讨厌认识你</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hookBlock:(id)block &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    EXCHANGE_METHOD(methodSignatureForSelector:, hookMethodSignatureForSelector:)</span><br><span class="line">    EXCHANGE_METHOD(forwardInvocation:, hookForwardInvocation:)</span><br><span class="line">&#125;);</span><br><span class="line">    PHBlock hBlock = (__bridge PHBlock)(block);</span><br><span class="line">    </span><br><span class="line">    Method replaceMethod = class_getInstanceMethod([self class], @selector(replaceBlock));</span><br><span class="line">    IMP replaceMethodIMP = method_getImplementation(replaceMethod);</span><br><span class="line">    hBlock-&gt;FuncPtr = replaceMethodIMP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)replaceBlock &#123;</span><br><span class="line">    NSLog(@<span class="string">"很讨厌认识你"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行后，可以看到成功替换了实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-23</span> <span class="number">20</span>:<span class="number">55</span>:<span class="number">31.041306</span>+<span class="number">0800</span> testData[<span class="number">29327</span>:<span class="number">25955322</span>] 很讨厌认识你</span><br></pre></td></tr></table></figure>
<h3 id="打印block的参数"><a href="#打印block的参数" class="headerlink" title="打印block的参数"></a>打印block的参数</h3><p>&emsp;&emsp;我们再次改变需求，这次我们想要先打印下block的参数，然后再调用其实现方法。</p>
<p>&emsp;&emsp;先看下初始化代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>(^testBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        NSString *result = [NSString stringWithFormat:@<span class="string">"%d + %d = %d"</span>, a, b, a + b];</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, result);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HookBlock *hook = [HookBlock <span class="keyword">new</span>];</span><br><span class="line">    [hook hookBlock:testBlock];</span><br><span class="line"></span><br><span class="line">    testBlock(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们首先拦截block，然后进入消息转发流程，根据<code>NSMethodSignature</code>可以获得参数类型，根据<code>NSInvocation</code>可以获得参数值，所以我们的实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hookBlock:(id)block &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    EXCHANGE_METHOD(methodSignatureForSelector:, hookMethodSignatureForSelector:)</span><br><span class="line">    EXCHANGE_METHOD(forwardInvocation:, hookForwardInvocation:)</span><br><span class="line">&#125;);</span><br><span class="line">    PHBlock hBlock = (__bridge PHBlock)(block);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存原来实现函数地址</span></span><br><span class="line">    objc_setAssociatedObject(block, <span class="string">"originImp"</span>, [NSValue valueWithPointer:hBlock-&gt;FuncPtr], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    <span class="comment">// 指向进入消息转发流程的函数地址</span></span><br><span class="line">    hBlock-&gt;FuncPtr = _objc_msgForward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)hookMethodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    PHBlock block = (__bridge PHBlock)self;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> *desc = (<span class="keyword">uint8_t</span> *)block-&gt;description;</span><br><span class="line">    desc += <span class="keyword">sizeof</span>(struct _blockDescription);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(block-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">        desc += <span class="keyword">sizeof</span>(struct _blockMemoryDescription);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BlockSignDescription signDesc = (BlockSignDescription)desc;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * signature = signDesc-&gt;signature;</span><br><span class="line">    <span class="keyword">return</span> [NSMethodSignature signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hookForwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    PHBlock block = (__bridge PHBlock)self;</span><br><span class="line">    </span><br><span class="line">    NSMethodSignature *methodSignature = [anInvocation methodSignature];</span><br><span class="line">    NSInteger numberOfArguments = [methodSignature numberOfArguments];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">1</span>; i &lt; numberOfArguments; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *argTypeName = [methodSignature getArgumentTypeAtIndex:i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (argTypeName[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'@'</span>: &#123;</span><br><span class="line">                __unsafe_unretained id type;</span><br><span class="line">                [anInvocation getArgument:&amp;type atIndex:i];</span><br><span class="line">                NSLog(@<span class="string">"%@"</span>, [NSString stringWithFormat:@<span class="string">"第%@个参数值为%@"</span>, @(i), type]);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TYPE_ARG(_typeSymbol, _type) \</span></span><br><span class="line">    <span class="keyword">case</span> _typeSymbol: &#123; \</span><br><span class="line">        _type type; \</span><br><span class="line">        [anInvocation getArgument:&amp;type atIndex:i]; \</span><br><span class="line">        NSString *result = [NSString stringWithFormat:@<span class="string">"第%@个参数值为%@"</span>, @(i), @(type)];       \</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, result); \</span><br><span class="line">    &#125;<span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'i'</span>, <span class="keyword">int</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'I'</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'l'</span>, <span class="keyword">long</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'L'</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'q'</span>, <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'Q'</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'f'</span>, <span class="keyword">float</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'d'</span>, <span class="keyword">double</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'B'</span>, BOOL);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'c'</span>, <span class="keyword">char</span>);</span><br><span class="line">                DATA_TYPE_ARG(<span class="string">'C'</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新调用自己的实现</span></span><br><span class="line">    NSValue *pointerValue = objc_getAssociatedObject(anInvocation.target, <span class="string">"originImp"</span>);</span><br><span class="line">    block-&gt;FuncPtr = pointerValue.pointerValue;</span><br><span class="line">    [anInvocation invoke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/15/浅谈ARM64汇编/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/浅谈ARM64汇编/" itemprop="url">浅谈ARM64汇编</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T09:38:02+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/逆向/" itemprop="url" rel="index">
                    <span itemprop="name">逆向</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-精简指令集RISC（Reduced-Instruction-Set-Computer）"><a href="#0x01-精简指令集RISC（Reduced-Instruction-Set-Computer）" class="headerlink" title="0x01 精简指令集RISC（Reduced Instruction Set Computer）"></a>0x01 精简指令集RISC（Reduced Instruction Set Computer）</h1><p>&emsp;&emsp;ARM是RISC的代表，RISC具有以下几个特点：</p>
<ul>
<li>简单的指令集：只提供很有限的操作  </li>
<li>等长指令集：执行指令速度快且性能稳定，可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。  </li>
<li>Load/Store架构：CPU并不会对内存中的数据进行操作，所有的计算都要求在寄存器中完成，而寄存器和内存的通信由Load/Store指令完成。  </li>
<li>更多的寄存器：基于RISC的处理器具有更多的通用寄存器可以使用，且每个寄存器都可以进行数据存储或寻址。  </li>
<li>效率更高：RISC指令集能够非常有效地适合于采用流水线、超流水线和超标量技术，从而实现指令集并行操作，提高处理器的性能。</li>
</ul>
<h1 id="0x02-寄存器"><a href="#0x02-寄存器" class="headerlink" title="0x02 寄存器"></a>0x02 寄存器</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>&emsp;&emsp;寄存器是CPU的一个组成部分，里面存放着指令、数据和地址等供CPU计算使用，速度比内存快。寄存器分为通用寄存器和专用寄存器。</p>
<ul>
<li><p>通用寄存器</p>
<ul>
<li><p>提供了31个64位通用寄存器，x0 ~ x30。</p>
</li>
<li><p>可以通过w0 ~ w30来访问这31个64位寄存器的低32位，写入时会将高32位清零。</p>
<blockquote>
<p>注：后面文章中wn其实也可以代表xn，它们之间只是位数不同。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>浮点寄存器</p>
<ul>
<li><p>v0 ~ v31，一共有32个浮点寄存器，每个寄存器大小是128位。分别可以用的方式来访问不同的位数。可以通过Bn、Hn、Sn、Dn、Qn来访问不同的位数。</p>
<blockquote>
<p>Bn：8位</p>
<p>Hn：16位</p>
<p>Sn：32位</p>
<p>Dn：64位</p>
<p>Qn：128位</p>
</blockquote>
</li>
</ul>
</li>
<li><p>特殊寄存器</p>
<ul>
<li><p>程序计数器</p>
<ul>
<li>pc，保存着当前CPU执行指令的地址。不能用作算数指令的源或目的地以及用作加载或存储指令。</li>
</ul>
</li>
<li><p>堆栈指针</p>
<ul>
<li>sp，即x31，指向堆栈的顶部。sp不能被大多数指令引用， 但一些算术指令，例如ADD指令，可以读写当前的堆栈指针来调整函数中的堆栈指针。每个异常级别都有一个专用的SP寄存器。</li>
<li>fp，即x29，帧指针，指向当前frame的栈底，也就是高地址。</li>
</ul>
</li>
<li><p>链接寄存器</p>
<ul>
<li>lr，即x30，存储着函数的返回地址。</li>
</ul>
</li>
<li><p>程序状态寄存器</p>
<p>在汇编中通过状态寄存器来控制分支的执行。</p>
<ul>
<li>cpsr：与其他寄存器不太一样，其他寄存器用来存储数据的，但是这个寄存器是，按位起作用的，每一位都有专门的含义。</li>
<li>spsr：当发生异常时，cpsr会存入spsr直到异常恢复再复制回cpsr。</li>
</ul>
<p><img src="CPSR01.png" alt="状态寄存器示意图1"> </p>
<p><img src="CPSR02.png" alt="状态寄存器示意图2"> </p>
</li>
</ul>
</li>
</ul>
<h3 id="2-模式与异常等级"><a href="#2-模式与异常等级" class="headerlink" title="2. 模式与异常等级"></a>2. 模式与异常等级</h3><h4 id="2-1-模式"><a href="#2-1-模式" class="headerlink" title="2.1 模式"></a>2.1 模式</h4><ul>
<li>用户模式(USR): ARM处理器正常程序执行状态。  </li>
<li>快速中断模式(FIQ): 高速数据传输或通道处理。  </li>
<li>外部中断模式(IRQ): 通用的中断处理。  </li>
<li>管理模式(supervisor): 操作系统使用的保护模式。  </li>
<li>数据访问终止模式(abort): 当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。</li>
<li>系统模式(system): 运行具有特权的操作系统任务。</li>
<li>未定义指令终止模式(UND)：当未定义的指令执行时进入该模式。</li>
<li>hyp：用于虚拟化扩展。</li>
<li>monitor：用于Security扩展。</li>
</ul>
<h4 id="2-2-异常等级"><a href="#2-2-异常等级" class="headerlink" title="2.2 异常等级"></a>2.2 异常等级</h4><ul>
<li>EL0：非特权用户模式</li>
<li>EL1：操作系统内核</li>
<li>EL2：Hypervisor，虚拟扩展</li>
<li>EL3：Secure Monitor，安全扩展。实现EL0和EL1的Secure和Non-Secure之间的切换，可起到物理屏障安全隔离作用。</li>
</ul>
<h4 id="2-3-模式与异常等级之间的关系"><a href="#2-3-模式与异常等级之间的关系" class="headerlink" title="2.3 模式与异常等级之间的关系"></a>2.3 模式与异常等级之间的关系</h4><ul>
<li><p>user模式：只能在EL0执行</p>
</li>
<li><p>monitor模式：只能在Secure的EL3执行</p>
</li>
<li><p>hyp模式：只能在Non-Secure的EL2执行，虚拟机。</p>
</li>
<li><p>system，supervisor，abort，undefined，IRQ，FIQ模式：依赖于Secure模式</p>
<p><img src="ExpetionLevel1.png" alt="状态寄存器示意图1"> </p>
</li>
</ul>
<h1 id="0x02-指令"><a href="#0x02-指令" class="headerlink" title="0x02 指令"></a>0x02 指令</h1><p>&emsp;&emsp;我们首先工程里创建一个.h文件和一个.s文件</p>
<p><img src="sample_create.png" alt="创建的文件示意图"> </p>
<p>&emsp;&emsp;接着，在头文件声明一个test方法</p>
<p><img src="header_declarm.png" alt="头文件示意图"> </p>
<p>&emsp;&emsp;汇编文件里，声明一个global，表示_test那块指令是可以暴露出给外面调用的</p>
<p><img src="assemble_declarm.png" alt="汇编文件示意图"> </p>
<p>&emsp;&emsp;准备工作结束后，以后使用的时候就加入asm.h头文件就可以调用相关函数。接着，我们开始认识一些常用的指令</p>
<h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>&emsp;&emsp;mov指令的格式为：mov{条件}{s} 目的寄存器，源操作数</p>
<p>&emsp;&emsp;mov指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。其中s选项决定指令的操作是否影响CPSR中条件标志位的值，当没有s时指令不更新CPSR中条件标志位的值。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">8</span></span><br><span class="line"><span class="keyword">mov </span>w2, w1</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w1</span><br><span class="line">      w1 = <span class="number">8</span></span><br><span class="line">(lldb) register read/d w2</span><br><span class="line">      w2 = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="mvn"><a href="#mvn" class="headerlink" title="mvn"></a>mvn</h4><p>&emsp;&emsp;mvn指令的格式为：mvn{条件}{s} 目的寄存器，源操作数</p>
<p>&emsp;&emsp;mvn指令可完成从另一个寄存器被移位的寄存器或将一个立即数加载到目的寄存器。与mov指令不同之处是在传送之前按位被取反了，即把一个被取反的值传送到目的寄存器中。 其中s选项决定指令的操作是否影响CPSR中条件标志位的值，当没有s时指令不更新CPSR中条件标志位的值。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">0</span></span><br><span class="line"><span class="keyword">mvn </span>w2, w1</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w2</span><br><span class="line">      w2 = -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>&emsp;&emsp;add指令的格式为：add{条件}{s} 目的寄存器，操作数1，操作数2</p>
<p>&emsp;&emsp;add指令用于把两个操作数相加，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">2</span></span><br><span class="line"><span class="keyword">mov </span>w2, <span class="number">4</span></span><br><span class="line"><span class="keyword">add </span>w0, w1, w2</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w0</span><br><span class="line">      w0 = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h4 id="adc"><a href="#adc" class="headerlink" title="adc"></a>adc</h4><p>&emsp;&emsp;adc指令的格式为：adc{条件}{s} 目的寄存器，操作数1，操作数2</p>
<p>&emsp;&emsp;adc指令用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。它使用一个进位标志位，这样就可以做比64位大的数的加法，注意不要忘记设置s后缀来更改进位标志。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</p>
<h4 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h4><p>&emsp;&emsp;sub指令的格式为：sub{条件}{s} 目的寄存器，操作数1，操作数2</p>
<p>&emsp;&emsp;sub指令用于把操作数1减去操作数2，并将结果存放到目的寄存器。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令可用于有符号数或无符号数的减法运算。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">4</span></span><br><span class="line"><span class="keyword">mov </span>w2, <span class="number">2</span></span><br><span class="line"><span class="keyword">sub </span>w0, w1, w2</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w0</span><br><span class="line">      w0 = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="sbc"><a href="#sbc" class="headerlink" title="sbc"></a>sbc</h4><p>&emsp;&emsp;sbc指令的格式为：sbc{条件}{s} 目的寄存器，操作数1，操作数2</p>
<p>&emsp;&emsp;sbc指令用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置s后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。</p>
<h4 id="mul"><a href="#mul" class="headerlink" title="mul"></a>mul</h4><p>&emsp;&emsp;mul指令的格式为：mul{条件}{s} 目的寄存器，操作数1，操作数2</p>
<p>&emsp;&emsp;mul指令完成将操作数1与操作数2的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。其中，操作数1和操作数2均为64位的有符号或无符号数。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">4</span></span><br><span class="line"><span class="keyword">mov </span>w2, <span class="number">2</span></span><br><span class="line"><span class="keyword">mul </span>w0, w1, w2</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w0</span><br><span class="line">      w0 = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>&emsp;&emsp;and指令的格式为：and{条件}{s} 目的寄存器，操作数1，操作数2</p>
<p>&emsp;&emsp;and指令用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于屏蔽操作数1的某些位。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">4</span></span><br><span class="line"><span class="keyword">and </span>w0, w1, <span class="number">3</span> <span class="comment">; 保持w1的0,1位，其余位清零</span></span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w0</span><br><span class="line">      w0 = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="orr"><a href="#orr" class="headerlink" title="orr"></a>orr</h4><p>&emsp;&emsp;orr指令的格式为：orr{条件}{s} 目的寄存器，操作数1，操作数2</p>
<p>&emsp;&emsp;orr指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于设置操作1的某些位。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">4</span></span><br><span class="line"><span class="keyword">orr </span>w0, w1, <span class="number">3</span>  <span class="comment">; 设置w1的0,1位，其余位保持不变</span></span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w0</span><br><span class="line">      w0 = <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="eor"><a href="#eor" class="headerlink" title="eor"></a>eor</h4><p>&emsp;&emsp;eor指令的格式为：eor{条件}{s} 目的寄存器，操作数1，操作数2</p>
<p>&emsp;&emsp;eor指令用于在两个操作数上进行逻辑异或运算，并把结果放置到目的寄存器中操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于反转操作数1的某些位。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">4</span></span><br><span class="line"><span class="keyword">eor </span>w0, w1, <span class="number">3</span> <span class="comment">; 反转w1的0,1位，其余位保持不变</span></span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w0</span><br><span class="line">      w0 = <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="tst"><a href="#tst" class="headerlink" title="tst"></a>tst</h4><p>&emsp;&emsp;tst指令的格式为：tst{条件} 操作数1，操作数2</p>
<p>&emsp;&emsp;tst指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位与运算，并根据运算结果更新CPSR中条件标志位的值。操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">0</span></span><br><span class="line"><span class="keyword">tst </span>w1, <span class="number">1</span></span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/t <span class="keyword">cpsr</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">cpsr </span>= <span class="number">0b01100000000000000000000000000000</span> <span class="comment">;执行tst命令之前</span></span><br><span class="line">(lldb) register read/t <span class="keyword">cpsr</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">cpsr </span>= <span class="number">0b01000000000000000000000000000000</span> <span class="comment">;执行tst命令之后</span></span><br></pre></td></tr></table></figure>
<h4 id="str"><a href="#str" class="headerlink" title="str"></a>str</h4><p>&emsp;&emsp;str指令的格式为：tst{条件}  源寄存器，&lt;存储器地址&gt;</p>
<p>&emsp;&emsp;str指令用于从源寄存器中将一个64位或32位(看使用rn还是wn)的字节数据传送到存储器中。</p>
<p>&emsp;&emsp;str的示例与ldr一起说明。</p>
<h4 id="ldr"><a href="#ldr" class="headerlink" title="ldr"></a>ldr</h4><p>&emsp;&emsp;ldr指令的格式为：ldr{条件}  目的寄存器，&lt;存储器地址&gt;</p>
<p>&emsp;&emsp;ldr指令用于从存储器中将一个64位或32位(看使用rn还是wn)的字节数据传送到目的寄存器中。当程序计数器pc作为目的寄存器时，指令从存储器中读取的字节数据被当做目的地址，从而可以实现程序流程的跳转。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">4</span></span><br><span class="line"><span class="keyword">str </span>w1, [<span class="built_in">sp</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">ldr </span>w0, [<span class="built_in">sp</span>, <span class="number">8</span>]</span><br><span class="line"><span class="symbol">ret</span></span><br><span class="line"></span><br><span class="line">// 调试结果</span><br><span class="line">(lldb) register read/d w0</span><br><span class="line">      w0 = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="b"><a href="#b" class="headerlink" title="b"></a>b</h3><p>&emsp;&emsp;b指令的格式为：b{条件} 目标地址</p>
<p>&emsp;&emsp;b指令是最简单的跳转指令。一个遇到一个b指令，ARM处理器将立即跳转到给定的目标地址，从那里继续执行。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> _test</span><br><span class="line"></span><br><span class="line"><span class="symbol">_test</span>:</span><br><span class="line"><span class="keyword">b </span>label</span><br><span class="line"><span class="keyword">mov </span>w2, <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">label</span>:</span><br><span class="line"><span class="keyword">mov </span>w0, <span class="number">3</span></span><br><span class="line"><span class="keyword">mov </span>w1, <span class="number">4</span></span><br><span class="line"><span class="symbol">ret</span></span><br></pre></td></tr></table></figure>
<h4 id="bl"><a href="#bl" class="headerlink" title="bl"></a>bl</h4><p>&emsp;&emsp;b指令的格式为：bl{条件} 目标地址</p>
<p>&emsp;&emsp;同样是跳转指令，但是在跳转之前，会在lr寄存器中保存pc的当前内容，因此，可以通过将lr的内容重新加载到pc中，来返回到跳转指令之后的那个指令处执行。</p>
<h1 id="0x03-栈"><a href="#0x03-栈" class="headerlink" title="0x03 栈"></a>0x03 栈</h1><h4 id="一个简单汇编代码"><a href="#一个简单汇编代码" class="headerlink" title="一个简单汇编代码"></a>一个简单汇编代码</h4><p>&emsp;&emsp;首先，我们看下最简单的汇编是什么样的，我们定义两个局部变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们Xcode的Debug -&gt; Debug Workflow -&gt; Always Show Disassembly，打开始终显示汇编，这样断点的时候就直接以汇编代码呈现了：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main</span>:</span><br><span class="line">    <span class="number">0x102eba73c</span> &lt;+<span class="number">0</span>&gt;:  <span class="keyword">sub </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x20</span>             <span class="comment">; =0x20 </span></span><br><span class="line">    <span class="number">0x102eba740</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">orr </span>   w8, wzr, <span class="number">#0x3</span></span><br><span class="line">    <span class="number">0x102eba744</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">orr </span>   w9, wzr, <span class="number">#0x2</span></span><br><span class="line">    <span class="number">0x102eba748</span> &lt;+<span class="number">12</span>&gt;: <span class="keyword">str </span>   wzr, [<span class="built_in">sp</span>, <span class="number">#0x1c</span>]</span><br><span class="line">    <span class="number">0x102eba74c</span> &lt;+<span class="number">16</span>&gt;: <span class="keyword">str </span>   w0, [<span class="built_in">sp</span>, <span class="number">#0x18</span>]</span><br><span class="line">    <span class="number">0x102eba750</span> &lt;+<span class="number">20</span>&gt;: <span class="keyword">str </span>   x1, [<span class="built_in">sp</span>, <span class="number">#0x10</span>]</span><br><span class="line">    <span class="number">0x102eba754</span> &lt;+<span class="number">24</span>&gt;: <span class="keyword">str </span>   w9, [<span class="built_in">sp</span>, <span class="number">#0xc</span>]</span><br><span class="line">    <span class="number">0x102eba758</span> &lt;+<span class="number">28</span>&gt;: <span class="keyword">str </span>   w8, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">-&gt;  <span class="number">0x102eba75c</span> &lt;+<span class="number">32</span>&gt;: <span class="keyword">ldr </span>   w8, [<span class="built_in">sp</span>, <span class="number">#0xc</span>]</span><br><span class="line">    <span class="number">0x102eba760</span> &lt;+<span class="number">36</span>&gt;: <span class="keyword">ldr </span>   w9, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">    <span class="number">0x102eba764</span> &lt;+<span class="number">40</span>&gt;: <span class="keyword">add </span>   w0, w8, w9</span><br><span class="line">    <span class="number">0x102eba768</span> &lt;+<span class="number">44</span>&gt;: <span class="keyword">add </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x20</span>             <span class="comment">; =0x20 </span></span><br><span class="line">    <span class="number">0x102eba76c</span> &lt;+<span class="number">48</span>&gt;: ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当然我们也可以直接用命令进行转换：</p>
<blockquote>
<p>xcrun -sdk iphoneos clang -S -arch arm64 main.m </p>
</blockquote>
<p>&emsp;&emsp;我们需要知道iOS是小端模式，所以汇编中的栈是由高地址向低地址传递数据，栈底是高地址，栈顶是低地址。在编译器生成汇编时，首先会计算需要的栈空间大小，并利用sp指针向低地址开辟相应的空间，在上面的汇编代码中，需要开辟0x20(即32)字节的栈空间。即，刚开始的栈如下图：</p>
<p><img src="stack_01.png" alt="初始化的栈示意图"> </p>
<p>&emsp;&emsp;这个例子中，我们会一行一行阅读汇编指令</p>
<ol>
<li>sub sp, sp, #0x20   ; sp指针往低地址移动32字节，sp指针指向了新地址</li>
</ol>
<p><img src="stack_02.png" alt="移动32字节的栈示意图"> </p>
<ol>
<li>orr w8, wzr, #0x3  ; 3与零寄存器取或，得到的值存到w8寄存器，这里就是把3放到w8寄存器</li>
<li>orr w9, wzr, #0x2  ; 2与零寄存器取或，得到的值存到w9寄存器，这里就是把2放到w9寄存器</li>
<li>str wzr, [sp, #0x1c]  ; 从sp地址+28个字节为基地址开始的4个字节内的数据用零寄存器内的数据填充</li>
<li>str w0, [sp, #0x18]  ; 从sp地址+24个字节为基地址开始的4个字节内的数据用w0寄存器内的数据填充</li>
<li>str x1, [sp, #0x10]  ; 从sp地址+16个字节为基地址开始的8个字节内的数据用x1寄存器内的数据填充</li>
<li>str w9, [sp, #0xc]   ; 从sp地址+12个字节为基地址开始的4个字节内的数据用w9寄存器内的值(即2)填充</li>
<li>str w8, [sp, #0x8]  ; 从sp地址+8个字节为基地址开始的4个字节内的数据用w8寄存器内的值(即3)填充</li>
<li>ldr w8, [sp, #0xc]  ; 把从sp地址+12个字节为基地址开始的4个字节的数据放到w8寄存器</li>
<li>ldr w9, [sp, #0x8]  ; 把从sp地址+8个字节为基地址开始的4个字节的数据放到w9寄存器</li>
<li>add w0, w8, w9  ; 把w8和w9寄存器内的值相加，保存到w0寄存器，即返回操作，return的值保存在w0寄存器。</li>
<li>add sp, sp, #0x20  ; sp指针往高地址移动32个字节，即回到最初的位置</li>
</ol>
<p><img src="stack_03.png" alt="数据入栈的栈示意图"> </p>
<p>&emsp;&emsp;这里还需要注意的是，我们的函数返回结果是保存在寄存器w0(如果是64位则是x0)中的，但也不是也只有这一个寄存器可以用作保存返回结果，w0~w7一共8个寄存器都是可以使用的。而且为什么需要开启32字节的栈空间，明明我们用不到那么多，那是因为ARM规定sp必须16字节对齐。</p>
<h4 id="堆栈平衡"><a href="#堆栈平衡" class="headerlink" title="堆栈平衡"></a>堆栈平衡</h4><p>&emsp;&emsp;前面的示例代码中，或许你对于代码开始时的sub sp, sp, #0x20和结束时的add sp, sp, #0x20感到好奇，其实这样做就是维持栈平衡，特别最后的add sp, sp, #0x20表示的就退栈，前面开辟了多少空间，函数调用结束的时候就需要恢复成函数调用前的样子。如果每次只有开辟空间，没有退栈操作，那么很快我们的栈将会被使用完毕。</p>
<p>&emsp;&emsp;这也就解释了，函数内的为什么变量都存在栈区，并且为什么函数调用结束后，函数内的变量就会被释放掉。</p>
<h4 id="函数的参数传递和调用约定"><a href="#函数的参数传递和调用约定" class="headerlink" title="函数的参数传递和调用约定"></a>函数的参数传递和调用约定</h4><p>&emsp;&emsp;那么在汇编代码中，参数是如何进行传递的？我们通过下面这段示例来了解下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">return</span> add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;将add函数转换成汇编代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add:</span></span><br><span class="line"><span class="keyword"> </span>   <span class="number">0x100c8e718</span> &lt;+<span class="number">0</span>&gt;:  <span class="keyword">sub </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x10</span>             <span class="comment">; =0x10 </span></span><br><span class="line">    <span class="number">0x100c8e71c</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">str </span>   w0, [<span class="built_in">sp</span>, <span class="number">#0xc</span>]</span><br><span class="line">    <span class="number">0x100c8e720</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">str </span>   w1, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">-&gt;  <span class="number">0x100c8e724</span> &lt;+<span class="number">12</span>&gt;: <span class="keyword">ldr </span>   w0, [<span class="built_in">sp</span>, <span class="number">#0xc</span>]</span><br><span class="line">    <span class="number">0x100c8e728</span> &lt;+<span class="number">16</span>&gt;: <span class="keyword">ldr </span>   w1, [<span class="built_in">sp</span>, <span class="number">#0x8</span>]</span><br><span class="line">    <span class="number">0x100c8e72c</span> &lt;+<span class="number">20</span>&gt;: <span class="keyword">add </span>   w0, w0, w1</span><br><span class="line">    <span class="number">0x100c8e730</span> &lt;+<span class="number">24</span>&gt;: <span class="keyword">add </span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x10</span>             <span class="comment">; =0x10 </span></span><br><span class="line">    <span class="number">0x100c8e734</span> &lt;+<span class="number">28</span>&gt;: ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在add函数内部打下断点，通过lldb的register指令读取下x0和x1寄存器的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="keyword">register</span> read/d w0</span><br><span class="line">      w0 = <span class="number">2</span></span><br><span class="line">(lldb) <span class="keyword">register</span> read/d w1</span><br><span class="line">      w1 = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以发现，函数参数是通过寄存器进行传递的，那么是不是如果函数参数很多很多，所有寄存器都可以用来保存函数参数？我们把示例改下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f, <span class="keyword">int</span> g, <span class="keyword">int</span> h, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> m) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> add(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add函数对应汇编如下：</span></span><br><span class="line">add:</span><br><span class="line">    <span class="number">0x10496e694</span> &lt;+<span class="number">0</span>&gt;:  sub    sp, sp, <span class="meta">#0x40             ; =0x40 </span></span><br><span class="line">    <span class="number">0x10496e698</span> &lt;+<span class="number">4</span>&gt;:  ldr    w8, [sp, <span class="meta">#0x50]</span></span><br><span class="line">    <span class="number">0x10496e69c</span> &lt;+<span class="number">8</span>&gt;:  ldr    w9, [sp, <span class="meta">#0x4c]</span></span><br><span class="line">    <span class="number">0x10496e6a0</span> &lt;+<span class="number">12</span>&gt;: ldr    w10, [sp, <span class="meta">#0x48]</span></span><br><span class="line">    <span class="number">0x10496e6a4</span> &lt;+<span class="number">16</span>&gt;: ldr    w11, [sp, <span class="meta">#0x44]</span></span><br><span class="line">    <span class="number">0x10496e6a8</span> &lt;+<span class="number">20</span>&gt;: ldr    w12, [sp, <span class="meta">#0x40]</span></span><br><span class="line">    <span class="number">0x10496e6ac</span> &lt;+<span class="number">24</span>&gt;: str    w0, [sp, <span class="meta">#0x3c]</span></span><br><span class="line">    <span class="number">0x10496e6b0</span> &lt;+<span class="number">28</span>&gt;: str    w1, [sp, <span class="meta">#0x38]</span></span><br><span class="line">    <span class="number">0x10496e6b4</span> &lt;+<span class="number">32</span>&gt;: str    w2, [sp, <span class="meta">#0x34]</span></span><br><span class="line">    <span class="number">0x10496e6b8</span> &lt;+<span class="number">36</span>&gt;: str    w3, [sp, <span class="meta">#0x30]</span></span><br><span class="line">    <span class="number">0x10496e6bc</span> &lt;+<span class="number">40</span>&gt;: str    w4, [sp, <span class="meta">#0x2c]</span></span><br><span class="line">    <span class="number">0x10496e6c0</span> &lt;+<span class="number">44</span>&gt;: str    w5, [sp, <span class="meta">#0x28]</span></span><br><span class="line">    <span class="number">0x10496e6c4</span> &lt;+<span class="number">48</span>&gt;: str    w6, [sp, <span class="meta">#0x24]</span></span><br><span class="line">    <span class="number">0x10496e6c8</span> &lt;+<span class="number">52</span>&gt;: str    w7, [sp, <span class="meta">#0x20]</span></span><br><span class="line">-&gt;  <span class="number">0x10496e6cc</span> &lt;+<span class="number">56</span>&gt;: ldr    w0, [sp, <span class="meta">#0x3c]</span></span><br><span class="line">    <span class="number">0x10496e6d0</span> &lt;+<span class="number">60</span>&gt;: ldr    w1, [sp, <span class="meta">#0x38]</span></span><br><span class="line">    <span class="number">0x10496e6d4</span> &lt;+<span class="number">64</span>&gt;: add    w0, w0, w1</span><br><span class="line">    <span class="number">0x10496e6d8</span> &lt;+<span class="number">68</span>&gt;: str    w12, [sp, <span class="meta">#0x1c]</span></span><br><span class="line">    <span class="number">0x10496e6dc</span> &lt;+<span class="number">72</span>&gt;: str    w9, [sp, <span class="meta">#0x18]</span></span><br><span class="line">    <span class="number">0x10496e6e0</span> &lt;+<span class="number">76</span>&gt;: str    w10, [sp, <span class="meta">#0x14]</span></span><br><span class="line">    <span class="number">0x10496e6e4</span> &lt;+<span class="number">80</span>&gt;: str    w11, [sp, <span class="meta">#0x10]</span></span><br><span class="line">    <span class="number">0x10496e6e8</span> &lt;+<span class="number">84</span>&gt;: str    w8, [sp, <span class="meta">#0xc]</span></span><br><span class="line">    <span class="number">0x10496e6ec</span> &lt;+<span class="number">88</span>&gt;: add    sp, sp, <span class="meta">#0x40             ; =0x40 </span></span><br><span class="line">    <span class="number">0x10496e6f0</span> &lt;+<span class="number">92</span>&gt;: ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;事实上，能用作保存函数参数的寄存器只有8个分别是w0~w7，其他都是保存到栈上了，加上前面已经提到过的函数返回结果保存在w0(当然你也可以写在w0~w7任意一个)。这种调用约定也称为ATPCS。</p>
<h4 id="函数跳转"><a href="#函数跳转" class="headerlink" title="函数跳转"></a>函数跳转</h4><p>&emsp;&emsp;回到之前的例子：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">return</span> add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">	<span class="comment">// 开辟32字节空间</span></span><br><span class="line">    <span class="number">0x10280e738</span> &lt;+<span class="number">0</span>&gt;:  sub    sp, sp, <span class="meta">#0x20    </span></span><br><span class="line">    <span class="comment">// 保存现场：x29表示fp寄存器，x30表示lr寄存器。从sp地址往高地址偏移16个字节的地址开始，用16个字节保存fp和lr寄存器。前8个字节保存fp寄存器，后8个字节保存lr寄存器。</span></span><br><span class="line">    <span class="number">0x10280e73c</span> &lt;+<span class="number">4</span>&gt;:  stp    x29, x30, [sp, <span class="meta">#0x10]		 </span></span><br><span class="line">    <span class="comment">// fp寄存器移动到从sp地址往高地址偏移16个字节的地址</span></span><br><span class="line">    <span class="number">0x10280e740</span> &lt;+<span class="number">8</span>&gt;:  add    x29, sp, <span class="meta">#0x10            ; =0x10 </span></span><br><span class="line">    <span class="number">0x10280e744</span> &lt;+<span class="number">12</span>&gt;: orr    w8, wzr, <span class="meta">#0x2</span></span><br><span class="line">    <span class="number">0x10280e748</span> &lt;+<span class="number">16</span>&gt;: orr    w9, wzr, <span class="meta">#0x3</span></span><br><span class="line">    <span class="number">0x10280e74c</span> &lt;+<span class="number">20</span>&gt;: stur   wzr, [x29, <span class="meta">#-0x4]</span></span><br><span class="line">    <span class="number">0x10280e750</span> &lt;+<span class="number">24</span>&gt;: str    w0, [sp, <span class="meta">#0x8]</span></span><br><span class="line">    <span class="number">0x10280e754</span> &lt;+<span class="number">28</span>&gt;: str    x1, [sp]</span><br><span class="line">    <span class="comment">// x8和x9寄存器内的值保存到x0和x1寄存器上，之前说过函数参数是通过前八位寄存器传递的</span></span><br><span class="line">    <span class="number">0x10280e758</span> &lt;+<span class="number">32</span>&gt;: mov    x0, x8</span><br><span class="line">    <span class="number">0x10280e75c</span> &lt;+<span class="number">36</span>&gt;: mov    x1, x9</span><br><span class="line">    <span class="number">0x10280e760</span> &lt;+<span class="number">40</span>&gt;: bl     <span class="number">0x10280e718</span>               ; add at main.m:<span class="number">12</span></span><br><span class="line">    <span class="comment">// 恢复现场：从sp地址往高地址偏移16个字节的地址开始的16个字节里面的数据，前8个字节保存到fp寄存器，后8个字节保存到lr寄存器</span></span><br><span class="line">    <span class="number">0x10280e764</span> &lt;+<span class="number">44</span>&gt;: ldp    x29, x30, [sp, <span class="meta">#0x10]</span></span><br><span class="line">    <span class="comment">// 退栈</span></span><br><span class="line">    <span class="number">0x10280e768</span> &lt;+<span class="number">48</span>&gt;: add    sp, sp, <span class="meta">#0x20             ; =0x20 </span></span><br><span class="line">    <span class="number">0x10280e76c</span> &lt;+<span class="number">52</span>&gt;: ret  </span><br><span class="line">        </span><br><span class="line">add:</span><br><span class="line">    <span class="number">0x10280e718</span> &lt;+<span class="number">0</span>&gt;:  sub    sp, sp, <span class="meta">#0x10             ; =0x10 </span></span><br><span class="line">    <span class="number">0x10280e71c</span> &lt;+<span class="number">4</span>&gt;:  str    w0, [sp, <span class="meta">#0xc]</span></span><br><span class="line">    <span class="number">0x10280e720</span> &lt;+<span class="number">8</span>&gt;:  str    w1, [sp, <span class="meta">#0x8]</span></span><br><span class="line">-&gt;  <span class="number">0x10280e724</span> &lt;+<span class="number">12</span>&gt;: ldr    w0, [sp, <span class="meta">#0xc]</span></span><br><span class="line">    <span class="number">0x10280e728</span> &lt;+<span class="number">16</span>&gt;: ldr    w1, [sp, <span class="meta">#0x8]</span></span><br><span class="line">    <span class="number">0x10280e72c</span> &lt;+<span class="number">20</span>&gt;: add    w0, w0, w1</span><br><span class="line">    <span class="number">0x10280e730</span> &lt;+<span class="number">24</span>&gt;: add    sp, sp, <span class="meta">#0x10             ; =0x10 </span></span><br><span class="line">    <span class="number">0x10280e734</span> &lt;+<span class="number">28</span>&gt;: ret</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码流程大致是下面这样的：</p>
<p><img src="stack_04.png" alt="数据入栈的栈示意图"> </p>
<p>&emsp;&emsp;代码中，一开始做了保存现场的操作。首先讲下为什么要保存fp寄存器里的值？因为fp寄存器可能正在被之前一个函数用着，如果不保存，对调用本函数的函数其栈区就乱了，因为我们要知道的是sp与fp之间的空间就是函数的栈空间，所以必须保存已保证栈的正确性。</p>
<p>&emsp;&emsp;其次，为什么需要保存lr寄存器里的值，我们知道lr保存着函数返回地址，有了它，函数才能知道我结束后该跳转到哪里，假设我们不保存会有什么后面，但我们执行bl     0x10280e718这条指令的时候，bl指令会将bl下一条指令的地址保存进lr寄存器里，所以在这个例子里，bl执行完毕后会来到0x10280e764这个位置继续往后执行，如果后面没做恢复操作，在执行到ret指令后，会又来到0x10280e764这个位置一直死循环。所以只有之前保存过lr寄存器值，然后再后面又恢复数据给lr寄存器，ret指令才能正确跳转。</p>
<p>&emsp;&emsp;需要提一个概念，叶子函数和非叶子函数</p>
<ul>
<li>叶子函数：函数内部不再调用其他函数的函数</li>
<li>非叶子函数：函数内部还在调用其他函数的函数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/13/深入分析block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/深入分析block/" itemprop="url">深入分析block</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T14:38:50+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-Block结构"><a href="#0x01-Block结构" class="headerlink" title="0x01 Block结构"></a>0x01 Block结构</h1><p>&emsp;&emsp; 我们通过命令将Objective-C代码转换为C++代码，看下底层block的结构</p>
<blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp </p>
</blockquote>
<p>&emsp;&emsp;测试代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello Block"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;转换后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">    <span class="comment">// 构造函数，初始化这个结构体</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp; <span class="comment">// fp就是前面传进来的__main_block_func_0</span></span><br><span class="line">    Desc = desc; <span class="comment">// desc就是前面传进来的__main_block_desc_0_DATA</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block里面的函数，被解析成一个独立的函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_main_a5d38c_mi_0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block的描述信息，包括block大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体初始化并赋值</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;main函数中初始化了<code>__main_block_impl_0</code>结构体，通过与结构体同名的构造函数将函数实现(<code>__main_block_func_0</code>)地址和函数描述(<code>__main_block_desc_0_DATA</code>)地址传递进了<code>__main_block_impl_0</code>结构。</p>
<p>&emsp;&emsp;我们的block函数被转换成了单独了一个函数<code>__main_block_func_0</code>并赋值给block结构体内FuncPtr成员，这样做我们想必也知道以后要是调用这个函数，直接调用结构体的FuncPtr成员即可。为了证明这点，我们将测试代码改成如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello Block"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们继续转换代码，这次主要看下main函数里面的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>(*helloBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构体的FuncPtr成员来调用函数</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)helloBlock)-&gt;FuncPtr)((__block_impl *)helloBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;并且在前面的结构体内发现了isa，我们知道只要OC对象都会有一个isa指针，所以我们可以知道block本质上也是一个OC对象。</p>
<h1 id="0x02-捕获变量"><a href="#0x02-捕获变量" class="headerlink" title="0x02 捕获变量"></a>0x02 捕获变量</h1><h4 id="1-auto修饰词"><a href="#1-auto修饰词" class="headerlink" title="1. auto修饰词"></a>1. auto修饰词</h4><p>&emsp;&emsp;我们知道局部变量前面默认都是有个auto修饰符的，所以我们写下如下测试代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换代码</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> age; <span class="comment">// 结构体多了一个age成员</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age)<span class="comment">/* 成员变量的age在这里被赋值，初始化的时候外部会传值 */</span> &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// 使用的是__main_block_impl_0成员age</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_main_942932_mi_0, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 初始化，并把10传进结构体</span></span><br><span class="line">    <span class="keyword">void</span>(*helloBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)helloBlock)-&gt;FuncPtr)((__block_impl *)helloBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在转换代码里，结构体多了个名为age的成员变量，并且main函数里对block结构体初始化的时候就把10这个值传递进去了，取来用的时候直接调取结构体age这个成员变量。初始化完成后，结构体内的age成员和main函数里定义的age变量其实已经没啥关系了，所以这也是为什么，之后修改变量age这个值，block内读取age的值是不会变的。</p>
<h4 id="2-static修饰词"><a href="#2-static修饰词" class="headerlink" title="2. static修饰词"></a>2. static修饰词</h4><p>&emsp;&emsp;修改测试代码，加上static修饰词</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后的代码</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> *age; <span class="comment">// 同样是新增了age成员，不同的是这次是个指针</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *age = __cself-&gt;age; </span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_main_5c5d34_mi_0, (*age));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 初始化的时候，也是直接将地址传递进去</span></span><br><span class="line">    <span class="keyword">void</span>(*helloBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;age));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)helloBlock)-&gt;FuncPtr)((__block_impl *)helloBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这次，同样新增了一个age的成员变量，但是跟之前不同的是这次是一个指针成员，初始化的时候直接将变量的地址传递了进去，我们知道如果使用指针传递，我们可以随时随地的修改这个变量内的值，并且读取的时候也是被改变后的值，因为block内部直接访问的是变量的地址。所以，这里就跟前面不一样了，后面修改了值，调用block后，block内部读取变量的值是修改后的值。</p>
<h4 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h4><p>&emsp;&emsp;测试代码修改如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后的代码：</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>; <span class="comment">// 变量同时也放在了全局</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_main_4e4a2d_mi_0, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>(*helloBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)helloBlock)-&gt;FuncPtr)((__block_impl *)helloBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> IMAGE_INFO &#123; <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;转换后的代码里，全局变量同样还是全局变量，并没有被吸收进结构体内。既然是也是全局变量，那么这个变量也是想怎么改就怎么改，block内部读取的值也是最新被赋值的值。</p>
<h4 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a>property属性</h4><p>&emsp;&emsp;这次将代码修改为如下，方便可以添加属性：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, <span class="keyword">self</span>.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    helloBlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后的代码</span></span><br><span class="line"><span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_0* Desc;</span><br><span class="line">  ViewController *<span class="keyword">self</span>; <span class="comment">// 多了一个控制器自己的成员</span></span><br><span class="line">  __ViewController__viewDidLoad_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_0 *desc, ViewController *_<span class="keyword">self</span>, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="keyword">self</span>(_<span class="keyword">self</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_func_0(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0 *__cself) &#123;</span><br><span class="line">  ViewController *<span class="keyword">self</span> = __cself-&gt;<span class="keyword">self</span>; <span class="comment">// bound by copy</span></span><br><span class="line">		<span class="comment">// 通过runtime读取成员变量的值，所以也可以保证被修改的值，后面block内部读取的时候也是读取最新的</span></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_ViewController_bc83d3_mi_0, ((<span class="keyword">int</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)<span class="keyword">self</span>, sel_registerName(<span class="string">"age"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_copy_0(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0*dst, <span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="keyword">self</span>, (<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_dispose_0(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="keyword">self</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0*, <span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0*);</span><br><span class="line">&#125; __ViewController__viewDidLoad_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0), __ViewController__viewDidLoad_block_copy_0, __ViewController__viewDidLoad_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OC方法默认会传两个参数：self和SEL</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_viewDidLoad(ViewController * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(<span class="keyword">id</span>)<span class="keyword">self</span>, (<span class="keyword">id</span>)class_getSuperclass(objc_getClass(<span class="string">"ViewController"</span>))&#125;, sel_registerName(<span class="string">"viewDidLoad"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Block的时候传进去了self</span></span><br><span class="line">    <span class="keyword">void</span>(*helloBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__ViewController__viewDidLoad_block_impl_0((<span class="keyword">void</span> *)__ViewController__viewDidLoad_block_func_0, &amp;__ViewController__viewDidLoad_block_desc_0_DATA, <span class="keyword">self</span>, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)helloBlock)-&gt;FuncPtr)((__block_impl *)helloBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用属性的时候，block结构体多了一个self的成员变量，初始化的时候将控制器实例传递了进去。读取值的时候通过消息发送机制获取最新的成员变量的值。</p>
<h1 id="0x03-block类型"><a href="#0x03-block类型" class="headerlink" title="0x03 block类型"></a>0x03 block类型</h1><h4 id="1-NSGlobalBlock"><a href="#1-NSGlobalBlock" class="headerlink" title="1. NSGlobalBlock"></a>1. NSGlobalBlock</h4><p>&emsp;&emsp;block内部没有调用auto修饰符变量的block都是NSGlobalBlock类型。</p>
<p>&emsp;&emsp;这里不使用clang转换代码，因为block都是运行时确定的，所以通过打断点确定block类型。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello World"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lldb指令打印：</span></span><br><span class="line">(lldb) po [helloBlock <span class="keyword">class</span>]</span><br><span class="line">__NSGlobalBlock__</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 又或者使用static修饰符</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lldb指令打印：</span></span><br><span class="line">(lldb) po [helloBlock <span class="keyword">class</span>]</span><br><span class="line">__NSGlobalBlock__</span><br></pre></td></tr></table></figure>
<h4 id="2-NSStackBlock"><a href="#2-NSStackBlock" class="headerlink" title="2. NSStackBlock"></a>2. NSStackBlock</h4><p>&emsp;&emsp;首先，我们需要将Xcode里ARC改为MRC</p>
<p> <img src="ARC_Setting.png" alt="ARC修改"> </p>
<p>&emsp;&emsp;测试代码如下</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lldb指令打印：</span></span><br><span class="line">(lldb) po [helloBlock <span class="keyword">class</span>]</span><br><span class="line">__NSStackBlock__</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;也就是block内部使用了auto修饰符的都是 NSStackBlock类型。</p>
<h4 id="3-NSMallocBlock"><a href="#3-NSMallocBlock" class="headerlink" title="3. NSMallocBlock"></a>3. NSMallocBlock</h4><p>&emsp;&emsp;NSStackBlock调用copy得到的就是NSMallocBlock类型。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = [^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125; <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lldb指令打印</span></span><br><span class="line">(lldb) po [helloBlock <span class="keyword">class</span>]</span><br><span class="line">__NSMallocBlock__</span><br></pre></td></tr></table></figure>
<h1 id="0x04-Copy"><a href="#0x04-Copy" class="headerlink" title="0x04 Copy"></a>0x04 Copy</h1><p>&emsp;&emsp;在ARC下，下列情况会自动将block从栈区复制到堆区。</p>
<ul>
<li>block作为返回值</li>
<li>赋值给strong强引用对象</li>
<li>在Cocoa里作为方法的参数（包括GCD）。</li>
</ul>
<p>&emsp;&emsp;所以下面的情况，肯定不会自动复制到堆区</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lldb指令</span></span><br><span class="line">(lldb) po [helloBlock <span class="keyword">class</span>]</span><br><span class="line">__NSStackBlock__</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;那么，如果对Block的三种类型进行copy操作会有什么效果：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSGlobalBlock</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = [^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello World"</span>);</span><br><span class="line">    &#125; <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lldb指令</span></span><br><span class="line">(lldb) po [helloBlock <span class="keyword">class</span>]</span><br><span class="line">__NSGlobalBlock__</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSStackBlock上面已经说过</span></span><br><span class="line"><span class="comment">// NSMallocBlock还是NSMallocBlock</span></span><br></pre></td></tr></table></figure>
<p>&emsp; &emsp;所以三种block类型使用copy的结果如下：</p>
<ul>
<li>NSGlobalBlock使用copy还是NSGlobalBlock</li>
<li>NSStackBlock使用copy，变为NSMallocBlock</li>
<li>NSMallocBlock使用copy还是NSMallocBlock，只是引用计数+1</li>
</ul>
<p>&emsp;&emsp;我们知道ARC下，会自动将block从栈区拷贝到堆区，同时block内部的成员会调用copy函数将成员也拷贝到堆区。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    Animal *a = [Animal new];</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, a.age);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换代码</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  Animal *__<span class="keyword">strong</span> a; <span class="comment">// __strong 修饰，强引用</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, Animal *__<span class="keyword">strong</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  Animal *__<span class="keyword">strong</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_main_d37033_mi_0, ((<span class="keyword">int</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)a, sel_registerName(<span class="string">"age"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述里面多了copy函数和销毁函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    Animal *a = ((Animal *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"Animal"</span>), sel_registerName(<span class="string">"new"</span>));</span><br><span class="line">    <span class="keyword">void</span>(*helloBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)helloBlock)-&gt;FuncPtr)((__block_impl *)helloBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;copy函数内部会调用<code>_Block_object_assign</code>函数，这个函数会根据auto 对象的修饰符(strong，weak,unsafe_unretained)做出相应操作，形成强引用还是弱引用。这里先讲auto修饰的对象，当block被拷贝到堆区的时候，其内部也会调用<code>__main_block_copy_0</code>函数将内部的Animal *a对象也拷贝到堆区，同时引用计数+1，我们看下源码，<code>_Block_object_assign</code>函数第三个参数flag，这里是3，即BLOCK_FIELD_IS_OBJECT。其他的情况在__block修饰的时候讲。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个对象</span></span><br><span class="line">        BLOCK_FIELD_IS_OBJECT   =  <span class="number">3</span>,  </span><br><span class="line">        <span class="comment">// 一个block变量</span></span><br><span class="line">        BLOCK_FIELD_IS_BLOCK    =  <span class="number">7</span>,  </span><br><span class="line">        <span class="comment">// 被__block修饰的变量</span></span><br><span class="line">        BLOCK_FIELD_IS_BYREF    =  <span class="number">8</span>, </span><br><span class="line">        <span class="comment">// 被__weak修饰的变量，只能被辅助copy函数使用</span></span><br><span class="line">        BLOCK_FIELD_IS_WEAK     = <span class="number">16</span>, </span><br><span class="line">        <span class="comment">// block辅助函数调用，仅赋值，内部实现不进行retain或copy</span></span><br><span class="line">        BLOCK_BYREF_CALLER      = <span class="number">128</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag上层传了3，即BLOCK_FIELD_IS_OBJECT</span></span><br><span class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destAddr, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    ......</span><br><span class="line">   	<span class="comment">// 也就是来到这里</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) &#123;</span><br><span class="line">       <span class="comment">// 持有对象</span></span><br><span class="line">        _Block_retain_object(object);</span><br><span class="line">        _Block_assign((<span class="keyword">void</span> *)object, destAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们可以看到其内部通过<code>_Block_retain_object</code>函数强引用了Animal *a对象。那么还有一种__weak修饰的变量，代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    __<span class="keyword">weak</span> Animal *a = [Animal new];</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, a.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    helloBlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后的代码：</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  Animal *__<span class="keyword">weak</span> a;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, Animal *__<span class="keyword">weak</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  Animal *__<span class="keyword">weak</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_main_39c8fe_mi_0, ((<span class="keyword">int</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)a, sel_registerName(<span class="string">"age"</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，Animal *a是被weak修饰的，所以block对a成员的持有是弱引用。所以我们需要记住，auto修饰的对象，如果不是weak修饰过的，那么block内部会对对象强引用。那么先看下面这段代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Animal *a = [Animal new];</span><br><span class="line">    &#125; <span class="comment">// 出了这个括号，对象会被销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对象会在出了对象后被销毁，那么如下代码会发生什么，出了括号后会被销毁吗？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        Animal *a = [Animal new];</span><br><span class="line">        helloBlock = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, a.age);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@""</span>);<span class="comment">// 断点在这里，会发生什么</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据上面讲的，想必大家都知道这里Animal对象不会被销毁。因为auto修饰的对象，会被block强引用。</p>
<p>&emsp;&emsp;还有一个，如果要从堆上移出会调用block内部的dispose函数，内部调用<code>_Block_object_dispose</code>函数，会自动释放引用的auto变量，作用类似于release，具体不详细表述了。</p>
<h1 id="0x05-block修饰符"><a href="#0x05-block修饰符" class="headerlink" title="0x05 __block修饰符"></a>0x05 __block修饰符</h1><p>&emsp;&emsp;前面我们说过，通过static修饰的局部变量和全局变量被block捕获后，外部修改变量的值后，block内部读取的时候也是最新的值，但是实际需求中，我只是临时使用下这个变量，函数执行完毕后，这个变量销毁就可以了，不希望变量被放到全局区，所以这时候需要通过<code>__block</code>来修饰。</p>
<h3 id="1-修饰局部变量"><a href="#1-修饰局部变量" class="headerlink" title="1. 修饰局部变量"></a>1. 修饰局部变量</h3><p>&emsp;&emsp;还是代码走起</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    __block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        helloBlock = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换代码</span></span><br><span class="line"><span class="comment">// 变量被转换成这种结构体了</span></span><br><span class="line"> <span class="keyword">struct</span> __Block_byref_age_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa; <span class="comment">// 有isa，可以理解为被转换后，在内部，该变量变成了一个OC对象</span></span><br><span class="line">__Block_byref_age_0 *__forwarding; <span class="comment">// 指向该实例自身的指针</span></span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> age; <span class="comment">// 原来的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_age_0 *age; <span class="comment">// block修饰的变量，变成了一个结构体</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_age_0 *_age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_age_0 *age = __cself-&gt;age; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_main_264df2_mi_0, (age-&gt;__forwarding-&gt;age));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;age, (<span class="keyword">void</span>*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;age, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    	<span class="comment">// 初始化__Block_byref_age_0，并把age地址传给forwarding，说明forwarding是指向自己的</span></span><br><span class="line">        __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_age_0 age = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_age_0 *)&amp;age, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_age_0), <span class="number">10</span>&#125;;</span><br><span class="line">    	<span class="comment">// 初始化block函数</span></span><br><span class="line">        <span class="keyword">void</span>(*helloBlock)(<span class="keyword">void</span>) = __null;</span><br><span class="line">        &#123;</span><br><span class="line">            helloBlock = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_age_0 *)&amp;age, <span class="number">570425344</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 重新赋值，已经变成给结构体赋值了</span></span><br><span class="line">        (age.__forwarding-&gt;age) = <span class="number">20</span>;</span><br><span class="line">		<span class="comment">// 调用block函数</span></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)helloBlock)-&gt;FuncPtr)((__block_impl *)helloBlock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里就很有趣了，<code>__block</code>修饰的变量会被改成一个结构体，而且该结构含有isa成员，那么这个变量很明显被转换成一个OC对象了，原本的变量也被包含在这个对象内，而且对于这个成员的管理，block这个对象默认是强引用这个变量，这个是不同于没被<code>__block</code>修饰的变量。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal *a = [Animal new]; <span class="comment">// block会对其强引用</span></span><br><span class="line">__<span class="keyword">weak</span> Animal *b = [Animal new]; <span class="comment">// block会对其弱引用</span></span><br><span class="line">__block Animal *c = [Animal new]; <span class="comment">// block会对其强引用</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对<code>__block</code>修饰的变量的修改，也就是对这个对象的age成员的修改((age.__forwarding-&gt;age) = 20;)。同时这个对象还有一个forwarding指针，这个的作用就是指向自己，如果在栈区就指向在栈区的实例地址，如果在堆区就指向在堆区的实例地址，下面源代码里也会证明这一点：</p>
<p>  <img src="forwarding.png" alt="forwarding指针示意图">  </p>
<p>&emsp;&emsp;同时，也可以发现<code>_Block_object_assign</code>的第三个参数flag变为8了，即BLOCK_FIELD_IS_BYREF，继续看源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destAddr, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">	.......</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  &#123;</span><br><span class="line">        _Block_byref_assign_copy(destAddr, object, flags);</span><br><span class="line">    &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _Block_byref_assign_copy(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *arg, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> **<span class="title">destp</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> **)<span class="title">dest</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">src</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">arg</span>;</span></span><br><span class="line">        </span><br><span class="line">   <span class="comment">// 如果没有被引用，说明还没拷贝到堆上。这里的操作就是将block修饰的变量(即已经转换成的__Block_byref_age_0结构体)拷贝到堆上</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isWeak = ((flags &amp; (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK)) == (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK));</span><br><span class="line">        <span class="comment">// if its weak ask for an object (only matters under GC)</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">copy</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)_<span class="title">Block_allocator</span>(<span class="title">src</span>-&gt;<span class="title">size</span>, <span class="title">false</span>, <span class="title">isWeak</span>);</span></span><br><span class="line">        copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value; <span class="comment">// non-GC one for caller, one for stack</span></span><br><span class="line">        copy-&gt;forwarding = copy; <span class="comment">// patch heap copy to point to itself (skip write-barrier)</span></span><br><span class="line">        src-&gt;forwarding = copy;  <span class="comment">// patch stack to point to heap copy</span></span><br><span class="line">        copy-&gt;size = src-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> (isWeak) &#123;</span><br><span class="line">            copy-&gt;isa = &amp;_NSConcreteWeakBlockVariable;  <span class="comment">// mark isa field so it gets weak scanning</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            <span class="comment">// Trust copy helper to copy everything of interest</span></span><br><span class="line">            <span class="comment">// If more than one field shows up in a byref block this is wrong XXX</span></span><br><span class="line">            copy-&gt;byref_keep = src-&gt;byref_keep;</span><br><span class="line">            copy-&gt;byref_destroy = src-&gt;byref_destroy;</span><br><span class="line">            (*src-&gt;byref_keep)(copy, src);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// just bits.  Blast 'em using _Block_memmove in case they're __strong</span></span><br><span class="line">            _Block_memmove(</span><br><span class="line">                (<span class="keyword">void</span> *)&amp;copy-&gt;byref_keep,</span><br><span class="line">                (<span class="keyword">void</span> *)&amp;src-&gt;byref_keep,</span><br><span class="line">                src-&gt;size - <span class="keyword">sizeof</span>(struct Block_byref_header));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// __Block_byref_age_0已经拷贝到堆上了，只增加引用计数。因为可能多个block调用同一个对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将复制到堆上的变量地址赋值给__Block_byref_age_0的forwarding实例指针</span></span><br><span class="line">    <span class="comment">// 我们可以看到赋值到堆上，被转换的对象结构体里的forwarding指针被指向堆上地址了</span></span><br><span class="line">    _Block_assign(src-&gt;forwarding, (<span class="keyword">void</span> **)destp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们<code>__block</code>修饰的变量不仅被转换成一个对象结构体，并且第一次使用的时候还会被拷贝到堆上。这里还需要注意一个地方，就是如果是同一个变量被多个block捕获，那么这个变量在堆上只存在一份地址，block对其只是引用计数加1，而不是说多个block捕获这个变量，这个变量就会被多次拷贝到堆上。</p>
<p>&emsp;&emsp;最后，因为这个变量被拷贝到堆区了，所以需要将变量转换后的结构体里的forwarding指向这个堆区地址，由于只是拷贝操作，所以栈上存在一份，堆上也存在一份。因此，如果<code>__block</code>修饰的对象或变量在栈区，则forwarding执行栈区地址，如果被复制到的堆区，则栈上的forwarding指向堆区地址，被拷贝到堆上的对象的forwarding则指向自己在堆上的地址。</p>
<h3 id="2-修饰对象"><a href="#2-修饰对象" class="headerlink" title="2. 修饰对象"></a>2. 修饰对象</h3><p>&emsp;&emsp;同样的如果<code>__block</code>修饰的是对象的话，又会是什么样的结构？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    __block Animal *a = [Animal new];</span><br><span class="line">    a.age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>(^helloBlock)(<span class="keyword">void</span>) = <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        helloBlock = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, a.age);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    helloBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换代码</span></span><br><span class="line"> <span class="keyword">struct</span> __Block_byref_a_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> Animal *__<span class="keyword">strong</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_main_62a055_mi_0, ((<span class="keyword">int</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)(a-&gt;__forwarding-&gt;a), sel_registerName(<span class="string">"age"</span>)));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">        __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((Animal *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"Animal"</span>), sel_registerName(<span class="string">"new"</span>))&#125;;</span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)(a.__forwarding-&gt;a), sel_registerName(<span class="string">"setAge:"</span>), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">void</span>(*helloBlock)(<span class="keyword">void</span>) = __null;</span><br><span class="line">        &#123;</span><br><span class="line">            helloBlock = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)(a.__forwarding-&gt;a), sel_registerName(<span class="string">"setAge:"</span>), <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)helloBlock)-&gt;FuncPtr)((__block_impl *)helloBlock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</span><br><span class="line">    <span class="comment">// 参数131表示BLOCK_BYREF_CALLER|BLOCK_FIELD_IS_OBJECT</span></span><br><span class="line"> _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样block修饰的对象也被转换成一个结构体，这个结构体不同之处就是多了两个函数<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>，用来管理结构体的成员 Animal <em>a的内存，之前因为是变量所以不需要管理，只需要管理其所在的结构体内存就可以了。其他跟之前也一样，对象被拷贝到堆区。不同于<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>，<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>是用来管理Block_byref_a_0结构体内的Animal </em>a成员的声明周期，而<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>管理的是<code>__Block_byref_a_0</code>的生命周期。</p>
<p>&emsp;&emsp;我们看下多出两个函数的源码，里面同样调用了<code>_Block_object_assign</code>函数，只是flag变为了131，其实就是BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT，那么前面的40又是什么？首先dst指向的就是<code>__Block_byref_a_0</code>地址，回到这个结构体，发现+40其实就是成员Animal *a的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_a_0</span> &#123;</span></span><br><span class="line">      <span class="keyword">void</span> *__isa; <span class="comment">// 8</span></span><br><span class="line">    __Block_byref_a_0 *__forwarding; <span class="comment">// 8</span></span><br><span class="line">     <span class="keyword">int</span> __flags; <span class="comment">// 4</span></span><br><span class="line">     <span class="keyword">int</span> __size; <span class="comment">// 4</span></span><br><span class="line">     <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*); <span class="comment">// 8</span></span><br><span class="line">     <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*); <span class="comment">// 8</span></span><br><span class="line">     Animal *__strong a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;进入源码后就会执行如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destAddr, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; BLOCK_FIELD_IS_WEAK) == BLOCK_FIELD_IS_WEAK) &#123;</span><br><span class="line">            _Block_assign_weak(object, destAddr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 来到这个分支，只是赋值，因为之前已经移动到堆区了</span></span><br><span class="line">            _Block_assign((<span class="keyword">void</span> *)object, destAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;观察下面的测试代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">void</span>(^HelloBlock)(<span class="keyword">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) HelloBlock block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ① 这个构造block的函数</span></span><br><span class="line">- (<span class="keyword">void</span>)contructBlock1 &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② 另外一个构造block的函数</span></span><br><span class="line">- (<span class="keyword">void</span>)contructBlock2 &#123;</span><br><span class="line">    __block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> contructBlock1];</span><br><span class="line"><span class="comment">//  [self contructBlock2];</span></span><br><span class="line">    <span class="keyword">self</span>.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不卖关子，直接说结果，调用contructBlock1方法后再执行block，会闪退；而调用contructBlock2方法则是正常运行。这是因为static修饰的变量不会被block持有，离开作用域后再访问这个变量就会有问题；而__block修饰的变量，会被block持有，所以即使离开了作用域也没关系。</p>
<p>&emsp;&emsp;总结：</p>
<ul>
<li><p>当在栈上的时候block对象不会对auto和block修饰的变量强引用</p>
</li>
<li><p>当auto和block修饰的变量拷贝到堆上的时候，就会产生强引用</p>
<blockquote>
<p>_Block_object_assign((void<em>)&amp;dst-&gt;a, (void</em>)src-&gt;a, 3);</p>
<p>_Block_object_assign((void<em>)&amp;dst-&gt;a, (void</em>)src-&gt;a, 8);</p>
</blockquote>
</li>
<li><p>当auto和block修饰的变量需要从堆上移出的时候</p>
<blockquote>
<p>_Block_object_dispose((void*)src-&gt;a, 3);</p>
<p>_Block_object_dispose((void*)src-&gt;a, 8);</p>
</blockquote>
</li>
</ul>
<h1 id="0x06-循环引用"><a href="#0x06-循环引用" class="headerlink" title="0x06 循环引用"></a>0x06 循环引用</h1><p>&emsp;&emsp;首先，创建一份会循环引用的代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">void</span>(^HelloBlock)(<span class="keyword">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) HelloBlock block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, <span class="keyword">self</span>.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">self</span>.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里因为用到了强引用和弱引用，设计runtime，所以clang转换命令改为如下:</p>
<blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">ViewController__viewDidLoad_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">ViewController__viewDidLoad_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">   <span class="comment">// block强引用了self</span></span><br><span class="line">  ViewController *<span class="keyword">const</span> __strong self;</span><br><span class="line">  __ViewController__viewDidLoad_block_impl_0(<span class="keyword">void</span> *fp, struct __ViewController__viewDidLoad_block_desc_0 *desc, ViewController *<span class="keyword">const</span> __strong _self, <span class="keyword">int</span> flags=<span class="number">0</span>) : self(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_func_0(struct __ViewController__viewDidLoad_block_impl_0 *__cself) &#123;</span><br><span class="line">  ViewController *<span class="keyword">const</span> __strong self = __cself-&gt;self; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_ViewController_0193cf_mi_0, ((<span class="keyword">int</span> (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"age"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_copy_0(struct __ViewController__viewDidLoad_block_impl_0*dst, struct __ViewController__viewDidLoad_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;self, (<span class="keyword">void</span>*)src-&gt;self, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_dispose_0(struct __ViewController__viewDidLoad_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;self, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">ViewController__viewDidLoad_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __ViewController__viewDidLoad_block_impl_0*, struct __ViewController__viewDidLoad_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __ViewController__viewDidLoad_block_impl_0*);</span><br><span class="line">&#125; __ViewController__viewDidLoad_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __ViewController__viewDidLoad_block_impl_0), __ViewController__viewDidLoad_block_copy_0, __ViewController__viewDidLoad_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// viewDidLoad方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"ViewController"</span>))&#125;, sel_registerName(<span class="string">"viewDidLoad"</span>));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(id, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"setAge:"</span>), <span class="number">10</span>);</span><br><span class="line">    ((<span class="keyword">void</span> (*)(id, SEL, HelloBlock))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"setBlock:"</span>), ((<span class="keyword">void</span> (*)())&amp;__ViewController__viewDidLoad_block_impl_0((<span class="keyword">void</span> *)__ViewController__viewDidLoad_block_func_0, &amp;__ViewController__viewDidLoad_block_desc_0_DATA, self, <span class="number">570425344</span>)));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(id, SEL, <span class="keyword">int</span>))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"setAge:"</span>), <span class="number">20</span>);</span><br><span class="line">    ((HelloBlock (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"block"</span>))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们看到转换代码中，block结构体内是强引用了self。而self又本来就强引用block的，所以这就造成了循环引用。一般解决方法是加上__weak。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> ViewController *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, weakSelf.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">self</span>.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换代码</span></span><br><span class="line"><span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_0* Desc;</span><br><span class="line">  ViewController *__<span class="keyword">weak</span> weakSelf; <span class="comment">// 变为弱引用self了</span></span><br><span class="line">  __ViewController__viewDidLoad_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_0 *desc, ViewController *__<span class="keyword">weak</span> _weakSelf, <span class="keyword">int</span> flags=<span class="number">0</span>) : weakSelf(_weakSelf) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但block函数里同样是弱引用，这就会造成一个问题。如果block执行的时候self被销毁了，那么这里就要出问题了，所以这也就是为什么，需要在block里面强引用回self。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_func_0(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0 *__cself) &#123;</span><br><span class="line">  ViewController *__<span class="keyword">weak</span> weakSelf = __cself-&gt;weakSelf; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_ViewController_337367_mi_0, ((<span class="keyword">int</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)weakSelf, sel_registerName(<span class="string">"age"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;加上__weak，block结构体弱引用self了，这就解决了循环引用问题了。</p>
<p>&emsp;&emsp;同样，在MRC下，只要加上block修饰符也可以解决循环引用问题，如下代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __block ViewController *vc = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.block = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"小明今天%d岁"</span>, vc.age);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">self</span>.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">self</span>.block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换代码</span></span><br><span class="line"><span class="keyword">struct</span> __Block_byref_vc_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_vc_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> ViewController *__<span class="keyword">strong</span> vc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_vc_0 *vc; <span class="comment">// by ref</span></span><br><span class="line">  __ViewController__viewDidLoad_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __ViewController__viewDidLoad_block_desc_0 *desc, __Block_byref_vc_0 *_vc, <span class="keyword">int</span> flags=<span class="number">0</span>) : vc(_vc-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __ViewController__viewDidLoad_block_func_0(<span class="keyword">struct</span> __ViewController__viewDidLoad_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_vc_0 *vc = __cself-&gt;vc; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_fg_0_j9qb4d4fn9_wnf3fp9q40ssw1_56_T_ViewController_87e968_mi_0, ((<span class="keyword">int</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)(vc-&gt;__forwarding-&gt;vc), sel_registerName(<span class="string">"age"</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是因为，self被转换为一个结构体并复制到堆上，并且由<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>对这个self进行管理，需要注意的是MRC下<code>__Block_byref_vc_0</code>对<code>ViewController *vc</code>是弱引用，这不同于ARC。所以只要block执行完毕后，会调用<code>__ViewController_viewDidLoad_block_dispose_0</code>对<code>__Block_byref_vc_0</code>进行销毁，接着<code>__Block_byref_vc_0</code>会调用<code>__Block_byref_id_object_dispose</code>函数对self进行销毁，所以不存在循环引用的问题了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/11/探索iOS签名机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/探索iOS签名机制/" itemprop="url">探索iOS签名机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-11T16:27:56+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>&emsp;&emsp; 我们知道，数据如果是明文传递很容易被“窃听者”窃听，所以为了应对这种问题，我们通常会对数据进行加密。</p>
<p><img src="encrypt_simple.png" alt="简单加密过程示意图"></p>
<p>&emsp;&emsp;加密对数据的安全作用完全不可或缺。接下来我们将从简至繁，了解加密的过程。</p>
<h1 id="0x02-对称加密"><a href="#0x02-对称加密" class="headerlink" title="0x02 对称加密"></a>0x02 对称加密</h1><p>&emsp;&emsp;在对称加密中，加密者和解密者都是使用同一个密钥。</p>
<p><img src="symmetry_encrypt.png" alt="对称加密过程示意图"></p>
<p>&emsp;&emsp;常见的对称加密有如下几种：</p>
<ul>
<li><p>DES</p>
<blockquote>
<p>&emsp;&emsp;DES是一种将64位明文加密成64位密文的对称密码算法，密钥长度是56位。规格上来说，密钥长度是64位，但每隔7位会设置一个用于错误检查的位，因此密钥实际长度为56位。</p>
<p>&emsp;&emsp;由于每次只能加密64位数据，所以遇到比较大的数据，需要对DES加密进行反复。比如说要加密128位数据，首先先加密前64位，再对后64位进行加密。如果是更大的数据，以此类推。</p>
<p>&emsp;&emsp;由于目前已经可以短时间内被破解，所以不建议使用。</p>
</blockquote>
</li>
<li><p>3DES</p>
<blockquote>
<p>&emsp;&emsp;DES-EDE3，将DES重复3次所得到的一种密码算法，3次所使用的密钥都是不同的，也叫三重DES算法。缺点是处理速度不高，安全性也不足够高。</p>
</blockquote>
</li>
<li><p>AES</p>
<blockquote>
<p>&emsp;&emsp;取代DES成为新标准的一种对称密码算法。AES的密码长度有128、192、256位三种，在2000年时，Rijindael算法作为AES的实现。目前，AES已经逐步取代DES、3DES成为首选的对称密码算法。加密后文件大小翻倍，同样的，解密的时间要慢于加密的时间。</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;但是，在使用对称加密的时候会遇到密钥配送问题。我们说过对称加密使用的是同一个密钥进行加解密，那么加密者肯定需要将密钥发送给接收者，而这发送密钥的过程中，窃听者是可以窃取这个密钥的，这就是密钥配送问题。</p>
<p>&emsp;&emsp;解决密钥配送问题，一般有以下几种方案：</p>
<ul>
<li><p>事先约定好密钥</p>
</li>
<li><p>密钥分配中心</p>
</li>
<li><p>Diffie-Hellman密钥交换，这是一种密钥交换方法</p>
</li>
<li><p><strong>非对称加密</strong></p>
</li>
</ul>
<h1 id="0x03-非对称加密"><a href="#0x03-非对称加密" class="headerlink" title="0x03 非对称加密"></a>0x03 非对称加密</h1><p>&emsp;&emsp;非对称加密中，密钥分为加密密钥和解密密钥两种不同的密钥。非对称加密，也称公钥密码。</p>
<p>&emsp;&emsp;一般加密密钥是公开的，因此该密钥也称公钥；由消息接收者自己保管的解密密钥不能公开，一次该密钥也称私钥。</p>
<p>&emsp;&emsp;公钥和私钥是一一对应的，是不能单独生成的，一对公钥和密钥称为密钥对。由公钥加密的密文，必须使用与该公钥所对应的私钥才能解密；由私钥加密的密文，必须使用与该私钥所对应的公钥才能解密。</p>
<p><img src="asymmetric_encrypt01.png" alt="非对称加密过程示意图1"></p>
<p>&emsp;&emsp;为什么说非对称加密很好的解决了对称加密的密钥配送问题？这是因为由消息的接收者生成一对公钥和私钥，然后将公钥发给消息的发送者，最后消息的发送者进行加密，这样消息的接收者就可以用私钥进行解密，得到明文信息，如下图所示。</p>
<p><img src="asymmetric_encrypt02.png" alt="非对称加密过程示意图2"></p>
<p>&emsp;&emsp;目前使用自多的非对称加密是RSA。RSA原理可以参考<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">原理1</a>、<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">原理2</a>。</p>
<p>&emsp;&emsp;当然，非对称加密也不是完美的，对于数据比较大的来说，其效率会比较低，其解密所需时间大大慢于加密时间，那有没有又安全而且效率又高的方法呢？</p>
<h1 id="0x04-混合密码"><a href="#0x04-混合密码" class="headerlink" title="0x04 混合密码"></a>0x04 混合密码</h1><p>&emsp;&emsp;通过对称加密和非对称加密的结合，我们可以解决对称加密的密钥配送问题和非对称加密的解密效率慢的问题。https运用的其实就是这个混合加密技术。</p>
<p>&emsp;&emsp;加密的过程如下：</p>
<ul>
<li>消息接收者生成一对公钥和私钥</li>
<li>消息接收者将公钥发送给消息发送者</li>
<li>消息发送者随机生成一个对称加密的密钥</li>
<li>消息发送者用密钥加密消息</li>
<li>消息发送者用公钥对密钥进行加密</li>
<li>消息发送者将加密消息和加密了的密钥发送给消息接收者</li>
<li>消息接收者用私钥解密加密了的密钥</li>
<li>消息接收者用密钥解密消息</li>
</ul>
<p><img src="hybrid_cryptosystem.png" alt="混合密码示意图"></p>
<h1 id="0x05-单向散列函数"><a href="#0x05-单向散列函数" class="headerlink" title="0x05 单向散列函数"></a>0x05 单向散列函数</h1><p>&emsp;&emsp;单向散列函数，可以根据消息内容计算出散列值，散列值的长度和消息的长度无关，无论消息是1bit、1M、1G，计算出的散列值都是固定长度的。</p>
<p>&emsp;&emsp;也被称为消息摘要函数或哈希函数。输出的散列值，也被称为消息摘要或指纹。</p>
<p><img src="hash_function.png" alt="单向散列函数示意图"></p>
<p>&emsp;&emsp;单向散列函数具有以下特点：</p>
<ul>
<li>根据任意长度的消息，计算出固定长度的散列值</li>
<li>计算速度快</li>
<li>数据哪怕只有一点点不同，计算出的散列值也都不一样</li>
<li>具备单向性</li>
</ul>
<p>&emsp;&emsp;常见的单向散列函数：</p>
<ul>
<li><p>MD4、MD5</p>
<blockquote>
<p>产生128bit的散列值，目前已经不安全</p>
</blockquote>
</li>
<li><p>SHA-1</p>
<blockquote>
<p>产生160bit的散列值，目前已经不安全</p>
</blockquote>
</li>
<li><p>SHA-2</p>
<blockquote>
<p>SHA-256、SHA-384、SHA-512，散列值长度分别是256bit、384bit、512bit</p>
</blockquote>
</li>
<li><p>SHA-3</p>
<blockquote>
<p>最新标准</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;采用单向散列函数，是为了防止数据被篡改。比如我们下载软件的时候，厂家都会提供一个MD5值，我们下载软件后，计算出MD5值，来比对两个值是否一样来判断下载的软件有没有被改过。同样的应用场景还有app的登录口令加密，我们的用户密码不会明文进行传递的。</p>
<h1 id="0x06-数字签名"><a href="#0x06-数字签名" class="headerlink" title="0x06 数字签名"></a>0x06 数字签名</h1><p>&emsp;&emsp;前面我们已经可以通过单向散列函数来判断消息是否被篡改过，但还是一种情况？如何证明消息是对方本人发的，因为在前面非对称加密中我们提到消息接收者者将公钥发送出去，这样就导致任何发送者都可以拿来加密，对方可以被伪装、篡改或对方否认是自己发的等。</p>
<p>&emsp;&emsp;要证明消息是消息发送者发的，其实很简单，我们把过程反过来，用消息发送者的私钥进行加密，因为私钥是消息发送者本人持有的，再加上单向散列函数的过程就是数字签名过程，具体流程如下图：</p>
<p><img src="hybrid_hashFunction_cryptosystem.png" alt="数字签名示意图"></p>
<p>&emsp;&emsp;所以，整个数字签名流程里我们可以了解到：</p>
<ul>
<li><p>确保了消息的完整性</p>
</li>
<li><p>知道消息是否被篡改了</p>
</li>
<li><p>防止别人否认</p>
<p>&emsp;&emsp;但是，我们知道数字签名的流程前提是公钥是得属于真正的发送者，但是如果遇到中间人攻击，数字签名将会失效，那么什么是中间人攻击呢？</p>
<p><img src="middle_attack.png" alt="中间人攻击示意图"></p>
<p>&emsp;&emsp;这样公钥是不是发送者本人的不能保证了，那么这个又该如何解决？</p>
</li>
</ul>
<h1 id="0x07-证书"><a href="#0x07-证书" class="headerlink" title="0x07 证书"></a>0x07 证书</h1><p>&emsp;&emsp;为了解决中间人攻击这样的问题，我们需要一个权威组织或受信任的个人给自己的公钥加上数字签名，来确保公钥不会被替换。我们前面说过数字签名可以确保数据完整性，加上是受信任的组织给签上的数字签名，所以只要拿着受信任组织的公钥去解密这个数字签名，验证完整性就能确保拿到的对方的公钥是没被替换过的。</p>
<p>&emsp;&emsp;密码学中的证书叫做公钥证书，里面包含姓名、邮箱、本人公钥等个人信息。然后由认证机构施加数字签名。</p>
<p>&emsp;&emsp;CA就是这样能够证明“公钥是本人”的权威组织或个人。其作用如下：</p>
<p><img src="CA_Temple.png" alt="CA组织作用示意图"></p>
<h1 id="0x08-iOS签名"><a href="#0x08-iOS签名" class="headerlink" title="0x08 iOS签名"></a>0x08 iOS签名</h1><p>&emsp;&emsp;iOS签名的作用就是保证安装到用户手机上的app都是经过官方允许的。那么，我们的签名是如何被加上的呢？这就需要结合上面我们看到的知识。</p>
<p>&emsp;&emsp;首先，我们要生成Mac上的公钥和私钥，请求完成后会得到一个CertificateSigningRequest.certSigningRequest这样的文件。</p>
<p><img src="mac_certSigningRequest.png" alt="生成Mac上的公钥和私钥示意图"></p>
<p>&emsp;&emsp;然后，我们需要获得由苹果的私钥来给前面生成的Mac上的公钥进行签名后的证书，通过这些会生成开发者或者发布的cer证书，这些证书文件名是cer结尾的。</p>
<p><img src="apple_assign01.png" alt="生成Mac公钥证书示意图"></p>
<p><img src="apple_assign02.png" alt="生成Mac公钥证书示意图"></p>
<p><img src="apple_assign03.png" alt="生成Mac公钥证书示意图"></p>
<p><img src="apple_assign04.png" alt="生成Mac公钥证书示意图"></p>
<p>&emsp;&emsp;最后，需要生成mobileprovision描述文件，里面包含之前生成的的证书外，还包括设备信息、apple id、app权限等信息。</p>
<p>&emsp;&emsp;生成的入口如下，具体生成步骤不详细表述。</p>
<p><img src="apple_assign05.png" alt="生成mobileprovision证书示意图"></p>
<p><img src="apple_assign06.png" alt="生成mobileprovision证书示意图"></p>
<h2 id="签名流程"><a href="#签名流程" class="headerlink" title="签名流程"></a>签名流程</h2><p>&emsp;&emsp;所有的证书生成完毕后，具体的签名步骤是什么样的呢？iOS签名具体流程如下：</p>
<p><img src="apple_assign07.png" alt="iOS签名示意图"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leylfl.github.io/2018/05/09/深入分析Category/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝暮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝暮的闲暇时刻">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/深入分析Category/" itemprop="url">深入分析Category</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T16:27:11+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>​    em…..好像没啥说的，直接撸起袖子干代码。</p>
<p><img src="luxun.png" alt="前言示意图"> </p>
<h1 id="0x02-举个例子"><a href="#0x02-举个例子" class="headerlink" title="0x02 举个例子"></a>0x02 举个例子</h1><p>&emsp;&emsp; 首先，我们新建一个Animal类，然后再建一个Animal的分类。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部实现文件</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sleep &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 用clang命令将Animal转成底层代码看下：</p>
<blockquote>
<p>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Animal.m -o Animal-Arm.cpp </p>
</blockquote>
<p>&emsp;&emsp; 通过下面解析出来的内容，我们可以知道Category在底层是以_category_t的结构体存在的，分类的实例方法是在这个结构体的instance_methods成员变量内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Category结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">cls</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">method_list_t</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">prop_list_t</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Category结构体内的instance_methods指定为_OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Category</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_Animal_</span>$_<span class="title">Category</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="string">"Animal"</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Animal,</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Category,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将_category_t结构的cls指定为Animal类，相当于说明自己是Animal的分类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_Animal_$_Category(<span class="keyword">void</span> ) &#123;</span><br><span class="line">	_OBJC_$_CATEGORY_Animal_$_Category.cls = &amp;OBJC_CLASS_$_Animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面说的_OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Category就是这里</span></span><br><span class="line"><span class="comment">// 我们写在分类的sleep方法就在这个结构体内</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Animal_$_Category __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">"sleep"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_Animal_Category_sleep&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个保存在__Data段下__objc_catlist里的数组，长度为1，如果多个分类，这个数组长度延长</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>")))= &#123;</span></span><br><span class="line">	&amp;_OBJC_$_CATEGORY_Animal_$_Category,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 以此类推，我们同样可以知道Category里的属性、类方法、协议同样被存放在结构体_category_t内。但是结构里是没有存放变量的成员，所以从结构体也可以知道Category是不可以添加变量的，同样属性的setter和getter也只有声明，没有实现。所以这也解释了为什么分类不会自动生成getter和setter，以及为什么不能添加成员变量。</p>
<p>&emsp;&emsp;上面代码里我们也说过，会在Data段下生成一个保存在objc_catlist里的数组，我们通过Mach-O证实这一点。首先是没有分类的Category的Mach-O文件结构图，我们发现在Data段下没有objc_catlist：</p>
<p><img src="Data_Objc_CatList2.png" alt="没有Category的Mach-O示意图"> </p>
<p>&emsp;&emsp;而有分类的Category的Mach-O文件结构图里，明显多出了objc_catlist：</p>
<p><img src="Data_Objc_CatList1.png" alt="有Category的Mach-O示意图"> </p>
<p>&emsp;&emsp; 那么，Category我们知道是通过runtime在运行时被加载的，那么要继续深入挖掘的话，我们需要通过runtime源码进行了解。</p>
<h1 id="0x03-Category信息的加载"><a href="#0x03-Category信息的加载" class="headerlink" title="0x03 Category信息的加载"></a>0x03 Category信息的加载</h1><p>&emsp; &emsp; 程序启动的时候很多依赖库会在main函数执行之前被执行。比如Runtime所在的libObjc库，这些库都是统一由dyld进行加载的。Runtime的初始化函数在_objc_init 方法，我们首先看下_objc_init是怎么被执行到的，我们下一个_objc_init符号断点。</p>
<p>​        <img src="objc_init.png" alt="objc_init调用示意图"></p>
<p>&emsp;&emsp;我们可以看到，首先是dyld动态链接器启动，然后把Mach-O加载进来，进行读取操作包括我们的类、分类、方法等，然后libSystem库的初始化，里面包括了libobjc和libdispatch等库，所以libobjc库，也在这一刻初始化。接着看_objc_init方法的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line">	<span class="comment">// 注册dyld事件的监听</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;map_images对Mach-O中一些符号信息进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="comment">// 这个函数最终主要关注在_red_imgaes函数</span></span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取类信息、协议信息、分类信息等</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 选取代码片段</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 读取Category信息</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="comment">// _getObjc2CategoryList下面会展开</span></span><br><span class="line">        <span class="keyword">category_t</span> **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> classExists = NO;</span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立一个映射表。key是类名，value是Category表。因为可能一个类有多个Category</span></span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    <span class="comment">// 重建类的结构，分类里的属性、方法、协议等需要重新加入进类里原来的属性、方法、属性表中。下面会拆开这个函数讲解</span></span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">        <span class="comment">// 使得类处于可用状态</span></span><br><span class="line">        realizeAllClasses();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GETSECT是个宏定义，而__objc_catlist就是前面说的Data段下的</span></span><br><span class="line">GETSECT(_getObjc2CategoryList,        <span class="keyword">category_t</span> *,    <span class="string">"__objc_catlist"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETSECT(name, type, sectname)                                   \</span></span><br><span class="line">    <span class="function">type *<span class="title">name</span><span class="params">(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">size_t</span> *outCount)</span> </span>&#123;              \</span><br><span class="line">        <span class="keyword">return</span> getDataSection&lt;type&gt;(mhdr, sectname, nil, outCount);     \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    <span class="function">type *<span class="title">name</span><span class="params">(<span class="keyword">const</span> header_info *hi, <span class="keyword">size_t</span> *outCount)</span> </span>&#123;               \</span><br><span class="line">        <span class="keyword">return</span> getDataSection&lt;type&gt;(hi-&gt;mhdr(), sectname, nil, outCount); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里要讲下，如何重建类的结构，也就是 class_rw_t这个结构体。通过前插的方法，将分类的方法、属性、协议信息加入到类原本的方法、属性、协议结构中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重建类的结构</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重建的过程在这个函数里</span></span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        <span class="built_in">free</span>(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数很好理解，取出分类的属性、协议、方法信息。通过attachLists函数附加到类原本的结构里</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">attachCategories</span><span class="params">(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="comment">// 读取方法、属性、协议信息</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">	<span class="comment">// 将拿到的Category信息，附加到类结构中，如何附加在attachLists函数中</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="comment">// 先将原来的结构移动出足够空间。</span></span><br><span class="line">            <span class="comment">// 移动是一种前插行为，比如要添加10个方法进来，就需要将原来结构全部后移出10个位置，这样前面10个位置就空出来了</span></span><br><span class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">            <span class="comment">// 把数据填入移动空出的位置</span></span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            List* oldList = <span class="built_in">list</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因为是通过前插来调整类的结构信息，所以举个例子，比如分类中如果有跟类中一样的方法，就被插入到前面去了，执行方法的时候会去查找方法，但会首先找到分类的方法，所以这就是为什么执行的是分类的方法，而不是类里的方法，而这往往会给我们造成“被覆盖”的感觉，其实原来类的这个方法还是存在在类的方法结构中，只是排在后面而已，如果要执行这个类的方法，我们其实也可以做到的。</p>
<h1 id="0x04-Load方法"><a href="#0x04-Load方法" class="headerlink" title="0x04 Load方法"></a>0x04 Load方法</h1><p>&emsp;&emsp;回到前面，我们在说_objc_init的时候，map_images里面做了一些准备工作，让类处于待用状态，而我们或许也会注意到旁边还有一个load_images函数，那么这个函数是干嘛的？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line">    </span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;load_images函数其实就是调用类以及分类里面的load方法，因为是在程序启动的时候执行的，<strong>所以我们也能证实load方法执行时机最早，且只会执行一次</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">recursive_mutex_locker_t</span> lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 找到所有的load方法，先找类的，保存到loadable_classes表内；再找分类的，保存到loadable_categories表内。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">rwlock_writer_t</span> lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用load方法</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历loadable_classes表，拿到load方法，然后执行调用执行load方法</span></span><br><span class="line">            <span class="comment">// 所以原来类的load方法是早于分类的load方法</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 遍历loadable_categories表，拿到load方法，然后执行调用执行load方法</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;找到所有的load方法后，就要去执行load方法，这里只拿call_class_loads函数举例，call_category_loads其实是类似的。</p>
<p>&emsp;&emsp;从loadable_classes表中拿到每个类的load方法，然后直接执行。需要注意的是，这里是直接执行，而不是调用消息发送机制来执行方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// 拿到load方法</span></span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接调用执行，而不是走消息发送机制</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;正因为是直接执行load方法，不走objc_msgSend消息发送函数，所以也就不存在去方法表中查找方法的过程。所以分类的load方法，并不会”覆盖“原来类的load方法。而且源码里，首先执行的是原来类的load方法，其次执行分类的load方法，<strong>所以原来类的load方法执行时间早于分类的load方法</strong>。</p>
<h1 id="0x05-Initialize-方法"><a href="#0x05-Initialize-方法" class="headerlink" title="0x05 Initialize 方法"></a>0x05 Initialize 方法</h1><p>&emsp;&emsp;说到了load方法，就不得不提initialize方法，这两个方法经常拿在一起进行比较，这里也不例外，我们继续通过源码来挖掘什么时候开始执行initialize方法。</p>
<p>&emsp;&emsp;我们在initialize方法打个断点看下调用栈</p>
<p>​    <img src="initialize_call.png" alt="initialize调用示意图"></p>
<p>&emsp;&emsp;我们初始化一个对象的时候，常用的方法是alloc或者new，这两个方法都是通过消息发送来调用的。我们可以看到，在objc_msgSend的汇编代码中，调用了objc_msgSend_uncached。</p>
<p>&emsp;&emsp;在objc_msgSend_uncached里面，调用了MethodTableLookup这个宏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">br	x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;MethodTableLookup宏的定义如下：里面我们可以看到跳转到了__class_lookupMethodAndLoadCache3函数函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">	</span><br><span class="line">	// push frame</span><br><span class="line">	stp	fp, lr, [sp, #-16]!</span><br><span class="line">	mov	fp, sp</span><br><span class="line"></span><br><span class="line">	// save parameter registers: x0..x8, q0..q7</span><br><span class="line">	sub	sp, sp, #(10*8 + 8*16)</span><br><span class="line">	stp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	stp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	stp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	stp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	stp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	stp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	stp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	stp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	str	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	mov	x2, x16</span><br><span class="line">	// 跳转到__class_lookupMethodAndLoadCache3函数</span><br><span class="line">	bl	__class_lookupMethodAndLoadCache3</span><br><span class="line"></span><br><span class="line">	mov	x17, x0</span><br><span class="line">	</span><br><span class="line">	ldp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	ldp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	ldp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	ldp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	ldp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	ldp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	ldp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	ldp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	ldr	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	mov	sp, fp</span><br><span class="line">	ldp	fp, lr, [sp], #16</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;_class_lookupMethodAndLoadCache3里面又调用了lookUpImpOrForward函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;lookUpImpOrForward函数里面入参initialize接收的是YES，而且第一次进来的时候cls-&gt;isInitialized()是肯定为NO的。所以只当这个对象第一次调用objc_msgSend的时候肯定会调用_class_initialize函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// bool isInitialized() &#123;</span></span><br><span class="line">    <span class="comment">//    return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;_class_initialize函数里面首先调用父类的initialize方法，然后调用callInitialize函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 同时调用父类的initialize方法</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">		callInitialize(cls);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">			_objc_inform(<span class="string">"INITIALIZE: thread %p: finished +[%s initialize]"</span>,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">       	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过消息调用，执行initialize方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;调用方式来看，我们可以发现load方法是直接执行，而initialize方法是通过消息发送来执行的。所以在这里，我们可以知道有分类实现initialize方法的情况下，只会调用分类的initialize方法，原来的类的initialize方法并不会被执行，而且执行顺序是先执行父类的initialize方法，再执行子类的initialize方法。我们举个例子，新建Animal类、Animal分类、继承Animal的子类Dog、Dog分类。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span> description]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@-Category"</span>, [<span class="keyword">self</span> description]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span> description]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@-Category"</span>, [<span class="keyword">self</span> description]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-09</span> <span class="number">15</span>:<span class="number">35</span>:<span class="number">56.587531</span>+<span class="number">0800</span> testData[<span class="number">36930</span>:<span class="number">28695275</span>] Animal-Category</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-09</span> <span class="number">15</span>:<span class="number">35</span>:<span class="number">56.587665</span>+<span class="number">0800</span> testData[<span class="number">36930</span>:<span class="number">28695275</span>] Dog-Category</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;结果可以看到，如果有Category的情况下，都是先执行Category的initialize方法；其次先调用父类的initialize方法，再调用子类的initialize方法。同时，我们可以测试下，如果子类的initialize方法不实现，而只实现父类的initialize方法会有什么效果？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-09</span> <span class="number">15</span>:<span class="number">42</span>:<span class="number">46.513940</span>+<span class="number">0800</span> testData[<span class="number">37636</span>:<span class="number">28757829</span>] Animal-Category</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-09</span> <span class="number">15</span>:<span class="number">42</span>:<span class="number">46.514091</span>+<span class="number">0800</span> testData[<span class="number">37636</span>:<span class="number">28757829</span>] Animal-Category</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;父类的的initialize方法被执行了两次，这又是为什么呢？</p>
<h1 id="0x06-isa指针与SuperClass"><a href="#0x06-isa指针与SuperClass" class="headerlink" title="0x06 isa指针与SuperClass"></a>0x06 isa指针与SuperClass</h1><p>&emsp;&emsp;我们首先看下Class的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;指向objc_class结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             </span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自的objc_object里面只有一个isa。</span></span><br><span class="line"><span class="comment">// 所以相当于如下结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class _Nonnull isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="comment">// 调用过的方法会被保存到cache，下次调用的时候先从Cache查找，提高效率</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;             </span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    </span><br><span class="line">	<span class="comment">// class_rw_t是一个很重要的结构</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line">	<span class="comment">// 方法表</span></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="comment">// 属性表</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="comment">// 协议表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;受益于苹果开源，我们知道现在Class的结构如上面代码所示，而不是很多博客里的说到的这样的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是Objective-C 1.0的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> info;</span><br><span class="line">    <span class="keyword">uint32_t</span> instance_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_ivar_list</span> *<span class="title">ivars</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_method_list</span> **<span class="title">methodLists</span>;</span></span><br><span class="line">    Cache cache;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ivar_layout;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_class_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以我们可以看到上面结构中都有一个isa和superClass成员，之间的关系可以通过下面这张图概况。</p>
<p><img src="isa_super.png" alt="isa和superClass关系示意图"></p>
<p>&emsp;&emsp;那么isa的作用如下：</p>
<ul>
<li><p>实例对象的isa指向类</p>
<blockquote>
<p>调用实例方法时，会先通过isa找到类，再在类的方法表中找到这个实例方法进行调用。</p>
</blockquote>
</li>
<li><p>类的isa指针指向元类</p>
<blockquote>
<p>调用类方法时，先通过类的isa找到元类，再在元类的方法表中找到这个类方法进行调用。</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;同样superClass的作用，显而易见是找到父类，下面会通过例子详细了解调用过程，进行实验前，我们必须记住的是<strong>调用实例方法是到这个类的方法表中查找的</strong>，实例结构自己是不保存这些的，它只做值的存储，比如age属性，实例结构里面只保存age的值，比如20这样的。而<strong>调用类方法是到这个类的元类里的方法表进行查找的</strong>。仔细看下上面这张图就可以很好理解了。</p>
<p><strong>Example 实例对象调用自己的方法</strong></p>
<p>&emsp;&emsp;测试代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个过程是首先实例方法首先通过isa找到它的类对象，然后遍历类对象的方法表，找到eat方法进行调用。</p>
<p><strong>Example 实例对象调用父类的方法</strong></p>
<p>&emsp;&emsp;测试代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个过程是首先实例方法首先通过isa找到它的类对象，然后遍历类对象的方法表，但是方法表里并没有这个方法，于是通过superClass找到父类对象，再到父类的方法表里进行查找，最后找到eat方法进行调用。假设父类还是没有，再一层一层上去找，直到基类为止，如果还是没找到就报错 unrecognized selector sent 。</p>
<p><strong>Example 类对象调用自己的方法</strong></p>
<p>&emsp;&emsp;测试代码如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个过程是直接在自己的元类方法表里进行查找。同样的，如果是父类的类方法，就调用superClass找到父类对象，再到父类的元类里的方法表进行查找，直到基类元类为止，如果还是没找到就报错 unrecognized selector sent 。</p>
<p><strong>Example 一个特殊情况</strong></p>
<p>&emsp;&emsp;测试代码如下：这个例子里，只有NSObject实现eat的实例方法（OC里NSObject是所有类的基类），而调用方式是[Dog eat]这样的调用类方法，运行后结果如何？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [Dog eat];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;执行结果是成功运行了，为什么我明明调用的是类方法，而实例方法却被触发了。如果仔细看过上面图的话，我们可以发现，当调用类方法时，元类一层一层往上进行查找，如果基类的元类里面的方法表也没有，就会来到基类（NSObject）里面的方法表进行查找，我们知道类里面保存的是实例方法，所以就会调用test方法成功。</p>
<p>&emsp;&emsp;回到前面留下的问题，Category里没实现initialize方法，而只在类里面实现initialize方法，这个类的initialize方法为什么会被执行两次？回到_class_initialize这个函数里可以看到父类的一次执行是在这里执行的。而第二次是因为自己类的元类方法表里找不到initialize方法，所以去父类的元类方法表里进行查找了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 父类的initialize方法被执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">		callInitialize(cls);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">			_objc_inform(<span class="string">"INITIALIZE: thread %p: finished +[%s initialize]"</span>,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">       	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x07-objc-getAssociatedObject和objc-setAssociatedObject"><a href="#0x07-objc-getAssociatedObject和objc-setAssociatedObject" class="headerlink" title="0x07 objc_getAssociatedObject和objc_setAssociatedObject"></a>0x07 objc_getAssociatedObject和objc_setAssociatedObject</h1><p>&emsp;&emsp;我们知道分类里面可以添加property属性，但不会生成getter、settter方法和实例变量。所以给属性设置和获取值是通过objc_setAssociatedObject和objc_getAssociatedObject实现的。那么为何一定要通过这种方式实现，比如下面的代码会有什么问题？我们通过全局变量来控制：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_Age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    g_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> g_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;显然是有问题的，全局变量共用的是一份，如果创建多份实例，去修改这个g_Age，那么每个实例对象的age属性值不具备唯一性，我们通过测试代码看下运行结果：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    Animal *a = [[Animal alloc] init];</span><br><span class="line">    a.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生成b对象前,a对象的年龄是%@岁"</span>, @(a.age));</span><br><span class="line">    </span><br><span class="line">    Animal *b = [[Animal alloc] init];</span><br><span class="line">    b.age = <span class="number">15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生成b对象后,a对象的年龄是%@岁"</span>, @(a.age));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：我们发现对象a的age，被对象b改掉了</span></span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-09</span> <span class="number">18</span>:<span class="number">16</span>:<span class="number">11.724830</span>+<span class="number">0800</span> testData[<span class="number">4751</span>:<span class="number">54320510</span>] 生成b对象前,a对象的年龄是<span class="number">10</span>岁</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-09</span> <span class="number">18</span>:<span class="number">16</span>:<span class="number">11.725054</span>+<span class="number">0800</span> testData[<span class="number">4751</span>:<span class="number">54320510</span>] 生成b对象后,a对象的年龄是<span class="number">15</span>岁</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以上面这种方案肯定不行的。说到唯一性，肯定还会想到每个实例对象肯定都不同的，如果以对象为key的字典，那么就能确保唯一性，比如下面这样的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一份全局字典</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *g_AgeDict;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">    g_AgeDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    [g_AgeDict setValue:@(age) forKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *age = [g_AgeDict objectForKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>]];</span><br><span class="line">    <span class="keyword">return</span> age.intValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">    Animal *a = [[Animal alloc] init];</span><br><span class="line">    a.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生成b对象前,a对象的年龄是%@岁"</span>, @(a.age));</span><br><span class="line">    </span><br><span class="line">    Animal *b = [[Animal alloc] init];</span><br><span class="line">    b.age = <span class="number">15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"生成b对象后,a对象的年龄是%@岁"</span>, @(a.age));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-09</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">49.964833</span>+<span class="number">0800</span> testData[<span class="number">6293</span>:<span class="number">54441445</span>] 生成b对象前,a对象的年龄是<span class="number">10</span>岁</span><br><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-09</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">49.965028</span>+<span class="number">0800</span> testData[<span class="number">6293</span>:<span class="number">54441445</span>] 生成b对象后,a对象的年龄是<span class="number">10</span>岁</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们根据运行结果可以看到我们保证了唯一性，但是缺点也很明显，我们如果有多个属性，岂不是要创建很多全局的字典。那么我们又想到可以这样做：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *g_Dict;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">    g_Dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [g_Dict objectForKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>]];</span><br><span class="line">    <span class="keyword">if</span>(!dict) dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    </span><br><span class="line">    dict[<span class="string">@"age"</span>] = @(age);</span><br><span class="line">    </span><br><span class="line">    [g_Dict setValue:dict forKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [g_Dict objectForKey:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%p"</span>, <span class="keyword">self</span>]];</span><br><span class="line">    <span class="built_in">NSNumber</span> *age = dict[<span class="string">@"age"</span>];</span><br><span class="line">    <span class="keyword">return</span> age.intValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;虽然可以实现了我们的需求，但是这样写还是麻烦，那我们看看官方怎么做的，先看objc_setAssociatedObject源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span> </span>&#123;</span><br><span class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里面维护了一份全局关联哈希表，里面一个对象对应一份对象关联表。对象对应的对象关联表里保存的就是我们objc_setAssociatedObject设置的内容。</span></span><br><span class="line"><span class="keyword">void</span> _object_set_associative_reference(id object, <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;所以我们可以明白通过objc_setAssociatedObject设置值，其实就是往一份<strong>全局的哈希表</strong>中给自己所对应的<strong>关联表</strong>中以key为健值，设置以value为值的过程。同样objc_getAssociatedObject也是相同步骤，只是换成了取值而已。我们发现，跟我之前自己实现的方案思路是差不多的，但这个显然方便多了。 </p>
<p>&emsp;&emsp;category_t结构中是没有存放ivar表的，所以上述操作相当于给对象关联一个成员变量，只是在普通类中这个成员变量在ivar表中，而分类中这个成员变量被维护在一个哈希表中。我们以前经常说如何给分类添加一个属性，所以严谨的来说，我们添加的不是属性，而是手动的生成setter和getter方法，并且维护一个成员变量到一个哈希表中。分类的属性的信息是可以被存到分类的_prop_list_t表中的。</p>
<p>&emsp;&emsp;看完源码，我们再看下使用方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *ageKey = &amp;ageKey;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, ageKey, @(age), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *age = objc_getAssociatedObject(<span class="keyword">self</span>, ageKey);</span><br><span class="line">    <span class="keyword">return</span> age.intValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先看下第三个参数objc_AssociationPolicy ，它一共有以下几个值：</p>
<ul>
<li><p>OBJC_ASSOCIATION_ASSIGN </p>
<blockquote>
<p>相当于@property(nonatomic, assign)</p>
</blockquote>
</li>
<li><p>OBJC_ASSOCIATION_RETAIN_NONATOMIC </p>
<blockquote>
<p>相当于@property(nonatomic, strong)</p>
</blockquote>
</li>
<li><p>OBJC_ASSOCIATION_COPY_NONATOMIC </p>
<blockquote>
<p>相当于@property(nonatomic, copy)</p>
</blockquote>
</li>
<li><p>OBJC_ASSOCIATION_RETAIN </p>
<blockquote>
<p>相当于@property(atomic, strong)</p>
</blockquote>
</li>
<li><p>OBJC_ASSOCIATION_COPY </p>
<blockquote>
<p>相当于@property(atomic, copy)</p>
</blockquote>
</li>
</ul>
<p>&emsp;&emsp;再看下第二个参数key，我们看到需要一个const void *指针，也就是一个任意指针都可以，所以我们精简至如下也是可以的，不用创建那么多key也可以达到我们的需求：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(age), @(age), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *age = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="keyword">return</span> age.intValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">朝暮</p>
              <p class="site-description motion-element" itemprop="description">联系方式：leylfl@foxmail.com</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朝暮</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
